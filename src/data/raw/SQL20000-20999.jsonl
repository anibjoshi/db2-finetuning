{"id": "SQL20005N", "message": "The statement failed because the maximum number of internal identifiers has been exceeded for the object type.  Internal identifier limit: of limit . Object type: object-type .", "explanation": "When one of several types of database object is created, declared, or altered, an internal identifier is created to uniquely identify that object. There is an upper limit on the number of unique identifier that can be created. This message is returned when the limit for internal identifiers for this type of object has been exceeded.", "response": "Respond to this error by performing the following troubleshooting steps: Drop objects of type object-type that are no longer being used. If object-type is DECLARE TYPE, remove the type declarations within the current compound SQL (compiled) statement for any types that are not being used. If object-type is a workload management object, you can reset the numbering of the internal identifiers by performing the following steps: Extract the DDL statements that would reproduce your workload management objects by using the db2look utility, specifying the -wlm option. Drop all of the workload management objects of the specified type from the database. Recreate the workload management objects of the specified type using the information from the db2look utility generated file. sqlcode :  -20005 sqlstate :  54035", "version": "12.1"}
{"id": "SQL20010N", "message": "Mutation method method-ID is not allowed when the instance of the structured type is NULL.", "explanation": "The method method-ID is a mutator method that\n\tis specified with an instance of a structured type\n\tthat is null.  Mutator methods cannot be processed on a null instance.\n\tIn some cases, the method name is not available. The statement cannot be processed.", "response": "Determine the null instance that is used with a mutator method.\n\tUse a constructor function to create a non-null instance\n\tof the structured type before using any mutator methods on the instance. To determine the method name associated with the method-ID ,\n\tuse the following query: SELECT FUNCSHEMA, FUNCNAME,\n\t\t   SPECIFICNAME\n\t FROM SYSCAT.FUNCTIONS\n\t WHERE\n\t   FUNCID = INTEGER(\n\t\t\t\tmethod-ID\n\t\t\t\t) Copy to clipboard sqlcode :  -20010 sqlstate :  2202D", "version": "12.1"}
{"id": "SQL20011N", "message": "Transform group group-name is already defined for a subtype or supertype of data type type-name .", "explanation": "A transform group called group-name already exists\n\tfor a type in the same hierarchy as type-name . It may\n\tbe defined for a supertype or subtype of type-name . A\n\ttransform group name can only be used once within a structured type\n\thierarchy. The statement cannot be processed.", "response": "Change the name of the transform group. sqlcode :  -20011 sqlstate :  42739", "version": "12.1"}
{"id": "SQL20012N", "message": "Type type-name does not have any associated transform groups to drop.", "explanation": "There are no transforms defined for type-name .\n\tThere is nothing to drop. The statement did not drop any transform groups.", "response": "Ensure the name of the type (including any required\n\tqualifiers) is correctly specified in the SQL statement and\n\tthat the type exists. sqlcode :  -20012 sqlstate :  42740", "version": "12.1"}
{"id": "SQL20013N", "message": "The object super-object-name is not valid as a supertype, supertable, or superview of object sub-object-name .", "explanation": "If the statement resulting in the error is creating a type,\n\tthen super-object-name is a type that cannot be a supertype\n\tof sub-object-name because it is not a user-defined\n\tstructured type. If the statement resulting in the error is creating a table,\n\tthen super-object-name is a table that cannot be a\n\tsupertable of table sub-object-name because it is not defined as a typed table or the type of table super-object-name is not the direct supertype of the\n\ttype used in defining table sub-object-name . If the statement resulting in the error is creating a view,\n\tthen super-object-name is a view that cannot be a\n\tsuperview of view sub-object-name because it is not defined as a typed view or the type of view super-object-name is not the direct supertype of the\n\ttype used in defining view sub-object-name . The statement cannot be processed.", "response": "Specify a valid type, table, or view in the UNDER clause of the CREATE\n\tstatement. sqlcode :  -20013 sqlstate :  428DB", "version": "12.1"}
{"id": "SQL20014N", "message": "The transform group group-name transform-type transform function for type type-name is not valid. Reason code = reason-code .", "explanation": "The transform-type transform function in transform\n\tgroup group-name is not valid. The reason is based\n\ton the reason-code as follows. 1 There can only be one parameter for a FROM SQL transform function. 2 The parameter of a FROM SQL transform function must be of type type-name . 3 The RETURNS data type of a TO SQL transform function must be\n\tof type type-name . 4 The RETURNS type of a FROM SQL transform function that returns\n\ta scalar must be a built-in data type other than DECIMAL. 5 All of the RETURNS types of a FROM SQL transform function that returns\n\ta scalar must be built-in data types other than DECIMAL. 6 There must be at least one parameter for a TO SQL transform function. 7 The parameter types for a TO SQL transform function must all be built-in\n\tdata types other than DECIMAL. 8 The TO SQL transform function must be a scalar function. 9 The FROM SQL transform function must be written using LANGUAGE SQL,\n\tor must use another FROM SQL transform function that is written using\n\tLANGUAGE SQL. 10 The TO SQL transform function must be written using LANGUAGE\n\tSQL or use a TO SQL transform function that is written using\n\tLANGUAGE SQL. The statement cannot be processed.", "response": "1 Specify a FROM SQL transform function with a signature\n\tthat has only one parameter. 2 Specify a FROM SQL transform function where the type of\n\tthe parameter is the same as type-name . 3 Specify a TO SQL transform function where the RETURNS type is\n\tthe same as type-name . 4 Specify a FROM SQL transform function with a RETURNS type\n\tthat is a built-in data type other than DECIMAL. 5 Specify a FROM SQL transform function where each element\n\tof the row has a RETURNS type that is a built-in data type\n\tother than DECIMAL. 6 Specify a TO SQL transform function with a signature that has\n\tat least one parameter. 7 Specify a TO SQL transform function where all the parameter\n\ttypes are built-in data types other than DECIMAL. 8 Specify a TO SQL transform function that is a scalar function. 9 Specify a FROM SQL transform function that is written using LANGUAGE SQL,\n\tor that uses another FROM SQL transform function that is written using\n\tLANGUAGE SQL. 10 Specify a TO SQL transform function that is written using LANGUAGE\n\tSQL or that uses a TO SQL transform function that is written using\n\tLANGUAGE SQL. sqlcode :  -20014 sqlstate :  428DC", "version": "12.1"}
{"id": "SQL20015N", "message": "A transform group group-name is not defined for data type type-name .", "explanation": "A specified transform group group-name is\n\tnot defined for the data type type-name .\n\tThe data type type-name may have been explicitly\n\tspecified in the statement or may be implicit based on the use of a\n\tstructured type that requires the existence of the transform group\n\tfor the data type. If group-name is empty, either the TRANSFORM\n\tGROUP bind option or the CURRENT DEFAULT TRANSFORM GROUP special\n\tregister was not specified and therefore there was no transform\n\tfor type-name . The statement cannot be processed.", "response": "Define transform group transform-type for data\n\ttype type-name using the CREATE TRANSFORM statement.\n\tIf the error occurred when dropping the transform, no action is\n\trequired because the transform group did not exist for the data type. If group-name is empty, specify the TRANSFORM GROUP\n\tbind option on the CURRENT DEFAULT TRANSFORM GROUP special register. sqlcode :  -20015 sqlstate :  42741", "version": "12.1"}
{"id": "SQL20016N", "message": "The value of the inline length associated with type or column type-or-column-name is too small.", "explanation": "For the definition of structured type type-or-column-name , it has\n\tan INLINE LENGTH value specified that is smaller than the size\n\treturned by the constructor function (32 + 10 * number_of_attributes)\n\tfor the type and is less than 292. For the altering of column type-or-column-name ,\n\tthe INLINE LENGTH specified is smaller than the current inline length. The statement cannot be processed.", "response": "Specify an INLINE LENGTH value that is large enough. For a structured type, that is\n\tat least the size returned by the\n\tconstructor function for the type or is at least 292.\n\tFor a column, it must be larger than the current inline length.\n\tIf this error occurs when altering the type (or some supertype of this type)\n\tto add an attribute, either the attribute cannot be added or the type must\n\tbe dropped and re-created with a larger INLINE LENGTH value. sqlcode :  -20016 sqlstate :  429B2", "version": "12.1"}
{"id": "SQL20017N", "message": "Addition of this subtype exceeds the maximum number of levels of a type hierarchy.", "explanation": "The maximum number of levels in a type hierarchy is 99.\n\tAdding this type would exceed the maximum. The statement cannot be processed.", "response": "Do not add any more subtypes to this type hierarchy. sqlcode :  -20017 sqlstate :  54045", "version": "12.1"}
{"id": "SQL20018N", "message": "Row function function-name must return at most one row.", "explanation": "The function is a defined to return a single row.  The result of\n\tthe processing the function is more than one row.", "response": "Ensure that the function is defined in such a way that at most\n\tone row is returned. sqlcode :  -20018 sqlstate :  21505", "version": "12.1"}
{"id": "SQL20019N", "message": "The result type returned from the function body cannot be assigned to the data type defined in the RETURNS clause.", "explanation": "The data type of each column returned by the function body must be assignable to the corresponding column specified in the RETURNS clause. If the function is a scalar function, there is only one column.", "response": "Change the RETURNS type or the type returned from the function body so that the data types of corresponding columns are assignable. sqlcode :  -20019 sqlstate :  42866", "version": "12.1"}
{"id": "SQL20020N", "message": "Operation operation-type is not valid for typed tables.", "explanation": "The operation identified by operation-type cannot be performed on a typed table. The statement cannot be processed.", "response": "If it is an ALTER statement, remove the ADD COLUMN clause, ADD PERIOD clause,  or SET DATATYPE clause. Columns can only be added by re-defining the table with a structured type that includes the new column as an attribute.  Similarly, the data type of a column can only be changed by re-defining the table with a type that includes the column with a different data type. If it is a CREATE TABLE statement, remove the DISTRIBUTE BY RANDOM clause. Typed tables are not allowed to be created as random distribution tables. sqlcode :  -20020 sqlstate :  428DH", "version": "12.1"}
{"id": "SQL20021N", "message": "Inherited column or attribute name cannot be changed or dropped.", "explanation": "The value of name identifies either a column name or\n\tan attribute name (depending on the statement context) that is\n\tinherited from a typed table, typed view,\n\tor structured type above it in the table, view,\n\tor type hierarchy. In the CREATE TABLE statement, the WITH OPTIONS clause cannot be\n\tspecified for column name in the CREATE TABLE statement\n\tbecause it is inherited from a supertable in the table hierarchy. In the ALTER TABLE statement, the SET SCOPE clause or COMPRESS clause cannot be\n\tspecified for column name because it is inherited from\n\ta supertable in the table hierarchy. In the CREATE VIEW statement, the WITH OPTIONS clause cannot be\n\tspecified for column name in the CREATE VIEW statement\n\tbecause it is inherited from a superview in the view hierarchy. In the ALTER TYPE statement, the DROP ATTRIBUTE clause cannot be\n\tspecified for attribute name because it is inherited from\n\ta supertype in the type hierarchy. The statement cannot be processed.", "response": "The options for a column may only be set or altered for the table\n\tor view in the typed table hierarchy or typed view hierarchy where\n\tthe column is introduced.\n\tAn attribute can only be dropped from the data type in the type hierarchy\n\twhere the attribute was introduced. sqlcode :  -20021 sqlstate :  428DJ", "version": "12.1"}
{"id": "SQL20022N", "message": "The scope for the reference column column-name is already defined.", "explanation": "The scope for the reference column column-name cannot be added\n\tbecause it is already defined. The statement cannot be processed.", "response": "Remove the ADD SCOPE clause from the ALTER TABLE statement. sqlcode :  -20022 sqlstate :  428DK", "version": "12.1"}
{"id": "SQL20023N", "message": "Parameter parm-number of the external or sourced function has a scope defined.", "explanation": "A reference type parameter should not have a scope defined when used\n\twith external or sourced user defined functions. The statement cannot be processed.", "response": "Remove the SCOPE specification from the definition of the parameter. sqlcode :  -20023 sqlstate :  428DL", "version": "12.1"}
{"id": "SQL20024N", "message": "The scope table or view target-name is not defined with structured type type-name .", "explanation": "The scope table or view target-name is not valid for use as\n\tthe scope of this reference because it is: not a typed table or not a typed view or the type of the table or view is not the same as the target type\n\tof the REF type. The statement cannot be processed.", "response": "Specify the scope of the reference using a typed table or typed view\n\twith the same type as the target type of the REF type. sqlcode :  -20024 sqlstate :  428DM", "version": "12.1"}
{"id": "SQL20025N", "message": "SCOPE is not specified in the RETURNS clause of an external function or is specified in the RETURNS clause of a sourced function.", "explanation": "There are two possible causes: A reference type must have a scope defined when used as the result\n\tof a user-defined external function. A reference type cannot have a scope defined when used as the result\n\tof an user-defined sourced function.  The function will use the scope\n\tof the source function. The statement cannot be processed.", "response": "When defining an external function with a reference type as a returns\n\ttype, ensure that the SCOPE clause is specified.\n\tWhen defining SOURCED function with a reference type as a returns\n\ttype, ensure that the SCOPE clause is not specified. sqlcode :  -20025 sqlstate :  428DN", "version": "12.1"}
{"id": "SQL20026N", "message": "The type type-name is not a structured type or is not an instantiable structured type.", "explanation": "The statement requires a structured type that can be instantiated.\n\tThe type type-name is either: not a structured type; or a structured type that is defined as not instantiable. The statement cannot be processed.", "response": "Verify that the correct type name is used in the statement. sqlcode :  -20026 sqlstate :  428DP", "version": "12.1"}
{"id": "SQL20027N", "message": "The subtable or subview sub-object-name was not created because subtable or subview object-name with type type-name already exists.", "explanation": "Within a typed table or view hierarchy,\n\tonly one subtable or subview may exist of a particular\n\tsubtype.\n\tThe table or view sub-object-name cannot be created since there is\n\talready a table or view of type type-name defined.\n\tThe table or view that already exists is object-name . The statement cannot be processed.", "response": "Verify that the subtable or subview is being created with the\n\tcorrect type and that the subtable is being created under\n\tthe correct supertable or the subview is being created under\n\tthe correct superview. sqlcode :  -20027 sqlstate :  42742", "version": "12.1"}
{"id": "SQL20028N", "message": "The table or view table-name cannot have a different schema name from the other tables or views in the same hierarchy.", "explanation": "All tables in a typed table hierarchy must have\n\tthe same schema name and all views in a typed view\n\thierarchy must have the same schema name. The statement cannot be processed.", "response": "Verify that the schema name of the table or view is correct.  If a hierarchy\n\tname is specified, verify that its schema name matches the schema name of the\n\troot table or view.  If a subtable\n\tis being created, verify that it is being created under the correct supertable.\n\tIf a subview is being created, verify that it is being created under the correct\n\tsuperview. sqlcode :   -20028 sqlstate :  428DQ", "version": "12.1"}
{"id": "SQL20029N", "message": "operation cannot be applied to a subtable or subview.", "explanation": "The operation operation was applied to a table or view that is not the root of a table hierarchy or view hierarchy. The subtable or subview cannot be a random distribution table. The statement cannot be processed.", "response": "Specify the root table of the table hierarchy or root view of the view hierarchy in the operation. If the operation was DISTRIBUTE BY RANDOM, execute the CREATE TABLE statement again without the DISTRIBUTE BY RANDOM clause. sqlcode :  -20029 sqlstate :  428DR", "version": "12.1"}
{"id": "SQL20030N", "message": "Attributes of a structured type type-name cannot be added or dropped when a typed table, typed view, or index extension object-name is dependent on the type.", "explanation": "The attributes of a structured type cannot be added or dropped\n\tif a typed table or typed view of the structured type or any of\n\tits subtypes currently exists.\n\tAttributes of a structured type also cannot be added or dropped\n\twhen a column exists in the table that directly or indirectly uses type-name . Also, attributes of a structured type cannot\n\tbe added or dropped when the type type-name or one of\n\tits subtypes is used in an index extension.\n\tThe table, view, or index extension object-name is one table, view, or index extension that is dependent on the structured type type-name . There may be other tables, views, or index\n\textensions that are dependent on the type or one of its proper subtypes. The statement cannot be processed.", "response": "Verify that the right type is being altered or drop any tables, views,\n\tand index extensions that are dependent on the structured\n\ttype type-name . sqlcode :  -20030 sqlstate :  55043", "version": "12.1"}
{"id": "SQL20031N", "message": "Object may not be defined on a subtable.", "explanation": "Primary key and unique constraints can only be defined on the root\n\ttable of a typed table hierarchy.\n\tSimilarly, unique indexes can only be defined on the root table of a\n\ttyped table hierarchy. The statement cannot be processed.", "response": "Unique indexes, Primary key or unique constraints can only be\n\tdefined on the root table of a table hierarchy. sqlcode :  -20031 sqlstate :  429B3", "version": "12.1"}
{"id": "SQL20032N", "message": "Index on the specified columns cannot be defined on subtable table-name .", "explanation": "The columns specified for the index were all\n\tintroduced at a higher level in the typed table hierarchy than subtable table-name .  Therefore, the index cannot be created on\n\tthis subtable. The statement cannot be processed.", "response": "Determine the table in the table hierarchy where all of the columns\n\tare included for the first time.  Use this as the table name when\n\tcreating the index. sqlcode :  -20032 sqlstate :  428DS", "version": "12.1"}
{"id": "SQL20033N", "message": "An expression including partial-expression does not include a valid scoped reference.", "explanation": "The expression that includes partial-expression requires an\n\toperand that is reference type with a scope defined.\n\tIf the expression includes the DEREF function, the argument of the\n\tfunction must be a reference type with a scope defined. For the dereference operator (->), the left operand needs to be a\n\treference type with a scope defined. The statement cannot be processed.", "response": "Correct the SQL statement syntax so the operand or argument is a\n\treference type with a scope defined. sqlcode :  -20033 sqlstate :  428DT", "version": "12.1"}
{"id": "SQL20034N", "message": "The data type list-type-name is not included in a structured data type hierarchy that includes the data type left-type-name of the left operand of the TYPE predicate.", "explanation": "All the data types listed in the TYPE predicate must be included in a\n\tdata type hierarchy that includes the data type of the left operand\n\tof the TYPE predicate.\n\tThe data type left-type-name is not a structured data type\n\t(not part of any type hierarchy) or the data type list-type-name is not included in the data type hierarchy that\n\tincludes left-type-name . The statement cannot be processed.", "response": "Ensure that the data type of the expression and all listed\n\tdata types in the TYPE predicate are structured data types within\n\tthe same data type hierarchy.\n\tIf left-type-name is SYSIBM.REFERENCE, use DEREF to make the\n\tresult data type of the expression a structured data type. sqlcode :  -20034 sqlstate :  428DU", "version": "12.1"}
{"id": "SQL20035N", "message": "Invalid left operand of a dereference operator. Path expression starts with expression-string .", "explanation": "The left operand of the dereference operator in a path expression\n\tis not valid.\n\tPossible causes are: The left operand includes a column function that uses a column\n\tfunction as an argument. The left operand expression includes a column function and a\n\treference to a column that is not in the GROUP BY clause.", "response": "Correct the left operand of the dereference operator for the\n\tpath expression that starts with expression-string . sqlcode :  -20035 sqlstate :  428DV", "version": "12.1"}
{"id": "SQL20036N", "message": "The object identifier column column-name cannot be referenced using the dereference operator.", "explanation": "The dereference operator is used with column-name as the\n\tright operand.  This column is the object identifier column of the\n\ttarget table of the dereference and is not valid for this operator. The statement cannot be processed.", "response": "Correct the name of the column in the dereference operation. sqlcode :  -20036 sqlstate :  428DW", "version": "12.1"}
{"id": "SQL20037N", "message": "Object identifier column is required to create the root table or root view object-name of a typed table or view hierarchy.", "explanation": "When creating the root table of a typed table hierarchy, an object identifier\n\t(OID) column must be defined (using the REF IS clause) on the CREATE TABLE\n\tstatement. When creating the root view of a typed view hierarchy, an object identifier\n\t(OID) column must be defined (using the REF IS clause) on the CREATE VIEW\n\tstatement. The statement cannot be processed.", "response": "Add the required OID column (REF IS clause) to the CREATE TABLE\n\tor CREATE VIEW statement. sqlcode :  -20037 sqlstate :  428DX", "version": "12.1"}
{"id": "SQL20038N", "message": "The statement could not be processed because the statement contains the following incompatible clauses or elements: keywords1 and keywords2 .", "explanation": "The keywords2 clause in the statement cannot be specified with the keywords1 clause. If CODEUNITS32 is one of the incompatible elements, note that the string unit might be set implicitly with the string_units configuration parameter.", "response": "Remove either the keywords1 or the keywords2 clause from the statement. If CODEUNITS32 is one of the incompatible elements, explicitly specify OCTETS as the string unit for the data type. sqlcode :  -20038 sqlstate :  42613", "version": "12.1"}
{"id": "SQL20039N", "message": "The definition of index index-name does not match the definition of index extension index-ext-name .", "explanation": "The index definition and the index extension definition do not\n\tmatch. The following lists the possibilities for where the definitions\n\tdo not match. The number of arguments following the index extension name in the\n\tEXTEND USING clause is not the same as the number of instance parameters\n\tof the index extension. The data types of the arguments following the index extension name\n\tin the EXTEND USING clause do not match exactly (including length or\n\tprecision and scale) the data types of the corresponding instance\n\tparameters of the index extension. The number of columns specified for the index is not same as the\n\tnumber of source key parameters of the index extension. The data types of the index columns do not match exactly\n\t(including length or precision and scale) the data types of the\n\tcorresponding source key parameters of the index extension.\n\tThere is an exception to exact matching of data types for the case of\n\tsubtypes.\n\tThe column of the index may be a subtype of the data type specified as\n\tthe corresponding source key parameter. The statement cannot be processed.", "response": "Change the index definition so that the index extension matches. sqlcode :  -20039 sqlstate :  428E0", "version": "12.1"}
{"id": "SQL20040N", "message": "Number or type of the result of the range-producing table function range-function-name , is inconsistent with that of key transformation table function transform-function-name for index extension index-ext-name .", "explanation": "The range-producing function must: return up to twice as many columns as returned by the key\n\ttransformation function have an even number of columns (the first half of the return\n\tcolumns are the start key values and the second half of the return\n\tcolumns are the stop key values) have the each start key column with the same type as the\n\tcorresponding stop key column have the type of each start key column be the same as the\n\tcorresponding transformation function column. More precisely, let\n\ta 1 :t 1 ,... a n :t n be the function result columns and data types of the key\n\ttransformation function. The function result columns of the\n\trange-producing function must be\n\tb 1 :t 1 ,...,b m :t m ,c 1 :t 1 ,...,c m :t m ,\n\twhere m <= n and the \"b\" columns are the start key columns and the \"c\"\n\tcolumns are the stop key columns. The statement cannot be processed.", "response": "Specify a range-producing table function that is consistent\n\twith the key transformation table function. sqlcode :  -20040 sqlstate :  428E1", "version": "12.1"}
{"id": "SQL20041N", "message": "Number or the type of target key parameters does not match with the number or type of key transform function function-name for index extension index-ext-name .", "explanation": "The number of target key parameters\n\thas to match with the number of results returned\n\tby the key transform function.\n\tIn addition, the type of the target key parameters must\n\texactly match the corresponding function result types. The statement cannot be processed.", "response": "Specify the correct number and type of parameters as the target\n\tkey parameters. sqlcode :  -20041 sqlstate :  428E2", "version": "12.1"}
{"id": "SQL20042N", "message": "The maximum allowable parm-type parameters is exceeded in index extension index-ext-name . The maximum is max-value .", "explanation": "Too many parameters were specified.\n\tIf parm-type is INDEX EXTENSION, then up to max-value instance parameters may be specified.\n\tIf parm-type is INDEX KEYS, then up to max-value key source parameters may be specified. The statement cannot be processed.", "response": "Specify no more than the maximum number of parameters. sqlcode :  -20042 sqlstate :  54046", "version": "12.1"}
{"id": "SQL20043N", "message": "Argument for routine routine-name is not valid. Reason code = reason-code .", "explanation": "The routine routine-name could be the\n\ttransformation function, the range-producing function, or a\n\troutine (function or method) referenced in the FILTER\n\tUSING clause.\n\tThe reason code indicates why an argument is not valid: 1 For a key transformation function, the argument is not an observer\n\tmethod or an index extension instance parameter. 2 The expression used as the argument uses a routine that specifies\n\tLANGUAGE SQL. 3 The expression used as the argument is a subquery. 4 The data type of an expression used as the argument cannot be a structured type. 5 The argument of a key transformation function cannot have a data type\n\tof structured data type, LOB, DATALINK, XML, LONG VARCHAR, or LONG VARGRAPHIC. 6 The expression used as an argument contains an XMLQUERY or XMLEXISTS expression. The statement cannot be processed.", "response": "Specify a valid argument for the function. sqlcode :  -20043 sqlstate :  428E3", "version": "12.1"}
{"id": "SQL20044N", "message": "The routine routine-name or the CASE expression is not valid in a CREATE INDEX EXTENSION or CREATE FUNCTION statement. Reason code = reason-code .", "explanation": "A routine (function or method) routine-name used in the CREATE INDEX EXTENSION or CREATE FUNCTION statement is not\n\tvalid where it is used.   If routine-name is empty,\n\tthen the CASE expression used for filtering is not valid.\n\tThe reason code indicates the reason. 1 The key transformation function is not a table function. 2 The key transformation function is not an external function. 3 The key transformation function is  a variant function. 4 The key transformation function is  an external action function. 5 The range-producing function is not a table function. 6 The range-producing function is not an external function. 7 The range-producing function is  a variant function. 8 The range-producing function is  an external action function. 9 The index-filter function is not an external function. 10 The index-filter function is  a variant function. 11 The index-filter function is  an external action function. 12 The result type of a filter function or CASE expression\n\tis not an integer data type. 13 A subquery is used in a CASE expression or as an argument\n\tof a filter function. 14 The key transformation function does not have the same encoding scheme as the database. 15 The range-producing function does not have the same encoding scheme as the database. 16 The index-filter function does not have the same encoding scheme as the database. 17 The filter function is not an external function. 20 An XMLQUERY or XMLEXISTS is used in a CASE expression or\n\tas an argument of a filter function. The statement cannot be processed.", "response": "If routine-name is not empty, specify a routine\n\tthat conforms to the rules for a function or method\n\tspecified in the specific clause of the CREATE INDEX EXTENSION\n\tor CREATE FUNCTION statement.\n\tOtherwise, specify a CASE expression that conforms to the rules\n\tfor a CASE expression in the FILTER USING clause. sqlcode :  -20044 sqlstate :  428E4", "version": "12.1"}
{"id": "SQL20045N", "message": "The data type of instance parameter parameter-name is invalid in index extension index-ext-name .", "explanation": "An instance parameter must be one of the following data types:\n\tVARCHAR, VARGRAPHIC, INTEGER, DECIMAL, or DOUBLE. The statement cannot be processed.", "response": "Specify a valid data type for the instance parameter parameter-name . sqlcode :  -20045 sqlstate :  429B5", "version": "12.1"}
{"id": "SQL20046N", "message": "SELECTIVITY clause following predicate-string can only be specified for a valid user-defined predicate.", "explanation": "The SELECTIVITY clause is specified with a predicate that does not\n\tinclude a valid user-defined function. A valid user-defined function includes\n\ta PREDICATES clause with a WHEN clause that matches the predicate. The\n\tSELECTIVITY clause cannot be specified except with a user-defined predicate. The statement cannot be processed.", "response": "Remove the SELECTIVITY clause following the predicate. sqlcode :  -20046 sqlstate :  428E5", "version": "12.1"}
{"id": "SQL20047N", "message": "The search method method-name is not found in the index extension index-ext-name .", "explanation": "The method method-name referenced in an exploitation\n\trule of the user-defined predicate has to match one of the search\n\tmethods specified in the index extension index-ext-name . The statement cannot be processed.", "response": "Specify a method defined in the index extension. sqlcode :  -20047 sqlstate :  42743", "version": "12.1"}
{"id": "SQL20048N", "message": "The search argument of method method-name does not match the one in the corresponding search method in the index extension index-ext-name .", "explanation": "The search argument provided for method method-name does not match the argument\n\tof the corresponding search method in the index extension index-ext-name .\n\tEither the number of arguments or the type of the arguments do not\n\tmatch the defined number or type of the parameters. The statement cannot be processed.", "response": "Specify a search argument that matches the parameters defined in\n\tthe index extension. sqlcode :  -20048 sqlstate :  428E6", "version": "12.1"}
{"id": "SQL20049N", "message": "Type of an operand following the comparison operator in the AS PREDICATE WHEN clause does not exactly match the RETURNS type.", "explanation": "The definition of the user-defined predicate is not valid.\n\tIn the AS PREDICATE WHEN clause, the type of the operand following the\n\tthe comparison operator is not an exact match with the RETURNS type of\n\tthe function. The statement cannot be processed.", "response": "Specify an the operand with the correct data type. sqlcode :  -20049 sqlstate :  428E7", "version": "12.1"}
{"id": "SQL20050N", "message": "The search target or search argument parameter-name does not match a name in the function being created.", "explanation": "Each search target in an index\n\texploitation rule has to match some parameter name of the function\n\tthat is being created.\n\tEach search argument in an index exploitation rule must match either\n\tan expression name in the EXPRESSION AS clause or a parameter name\n\tof the function being created.\n\tParameter names must be specified in the parameter list for the function. The statement cannot be processed.", "response": "Specify only valid names of the function in the search target\n\tor search argument. sqlcode :  -20050 sqlstate :  428E8", "version": "12.1"}
{"id": "SQL20051N", "message": "The argument parameter-name cannot appear as both a search target and a search argument in the same exploitation rule.", "explanation": "In the exploitation clause, a function parameter cannot be\n\tspecified as an argument following KEY and as an argument of the\n\tmethod specified following the USE keyword. The statement cannot be processed.", "response": "Specify a parameter name of the function in no more than on of\n\tthe search target or the search argument. sqlcode :  -20051 sqlstate :  428E9", "version": "12.1"}
{"id": "SQL20052N", "message": "Column column-name is an object identifier column which cannot be updated.", "explanation": "The UPDATE statement includes setting a column that is an object\n\tidentifier (OID) column.  An OID column cannot be updated. The statement cannot be processed.", "response": "Remove the SET of column-name from the UPDATE statement. sqlcode :  -20052 sqlstate :  428DZ", "version": "12.1"}
{"id": "SQL20053N", "message": "Fullselect in typed view view-name is not valid. Reason code = reason-code .", "explanation": "The fullselect specified in the definition of typed view view-name does not conform to the rules for the fullselect\n\tof a typed view.  Possible reason codes follow. 1 A subview definition contains a common\n\ttable expression, OR\n\ta branch in a subview definition does not range over\n\ta single table, view, nickname or an alias. 2 The row-set of a branch over a table-hierarchy\n\tcannot be proven by the database manager to be distinct\n\tfrom the row-set of all branches over the same\n\ttable-hierarchy in the rest of the typed view hierarchy. 3 The first expression of a branch over a  hierarchy in the\n\troot view is: not the object identifier column of the typed table or\n\ttyped view referenced in the FROM clause and the\n\tUNCHECKED option in the REF IS clause is not used OR if the table in the FROM clause is not typed, the\n\tcolumn is nullable or does not have a\n\tunique index defined on only that column and the\n\tUNCHECKED option in the REF IS clause is not used OR not identical to the expression in the branch over the\n\tsame hierarchy in the subview. 4 A table or view over which a branch of a subview\n\tranges is not a subtable or subview of the table or view\n\treferenced in any branch of the superview and either the\n\tsubview uses EXTEND AS or the root view does not have the\n\tUNCHECKED option in the REF IS clause turned on. 5 The fullselect includes references to the NODENUMBER or\n\tPARTITION functions, non-deterministic functions, or\n\tfunctions defined to have external action. 6 A branch in a subview cannot range over an OUTER\n\ttable or view if any branch in its superview ranges over\n\ta table or view in the same hierarchy without using OUTER. 7 A subview ranges over a view in its own view hierarchy. 8 A subview uses a set operation other than UNION ALL in\n\tits definition OR\n\tUNION ALL is used in the definition without specifying the\n\tUNCHECKED option in the REF IS clause of the root view. 9 A subview contains two branches of a UNION ALL that range\n\tover the same table hierarchy or view hierarchy. 10 The subview definition contains a GROUP BY or\n\tHAVING clause.", "response": "Change the fullselect of the view definition based on the reason-code . 1 Use only one table or view in the FROM clause.\n\tEncapsulate complex selects into views that the typed\n\tview can range over using the UNCHECKED option of the\n\troot view's REF IS clause. 2 Specify a different table or view in the FROM clause of\n\teach branch that is not the same as one already used in\n\tthe view hierarchy or use a predicates that clearly define\n\tthe row-set for each branch as distinct compared to the\n\trow-sets for other branches in the typed view hierarchy. 3 Ensure that the first column of the root view conforms\n\tto the rules to be a valid object identifier column for\n\tthe typed view. Consider using the UNCHECKED option in the\n\tref is clause. 4 Specify a subtable or subview of the table or view\n\tspecified in the FROM clause of a branch of the superview.\n\tOr use the UNCHECKED option in the root view definition\n\tin conjunction with the AS (without EXTEND) clause in the\n\tsubview definition. 5 Remove the reference to the function from the\n\tfullselect. 6 If this is the first subview to use OUTER in a branch\n\tover this hierarchy, change the FROM clause so that OUTER\n\tis not used.  If the superview uses OUTER, include OUTER\n\tin the FROM clause of the subview. 7 Do not source a subview on other views in the same hierarchy. 8 If UNION ALL was used, use the UNCHECKED option in the REF IS\n\tclause of the rootview to allow multiple branches in the subview\n\tdefinition.\n\tFor other set operations encapsulate the set operation into a\n\tview and use the UNCHECKED option in the subview to allow\n\tsourcing on common views. 9 Unify the branches to a select over their common supertable\n\tor superview and use predicates (e.g. the type predicate) to\n\tfilter for the desired rows. 10 Encapsulate the GROUP BY and HAVING clause into a view\n\tand use the UNCHECKED option in the root view to allow\n\tsourcing on common views. sqlcode :  -20053 sqlstate :  428EA", "version": "12.1"}
{"id": "SQL20054N", "message": "The operation was not performed because the table is in an invalid state for the operation. Table name: table-name . Reason code: reason-code .", "explanation": "The table is in a state that does not allow the operation.  The reason code indicates the state of the table that prevents the operation. 21 The table is in Datalink Reconcile Pending (DRP) state or Datalink Reconcile Not Possible (DRNP) state. 22 The generated column expression cannot be added or altered because the table is not in check pending mode. 23 The maximum number of REORG-recommended ALTER operations have been run. Up to 31 REORG-recommended operations are allowed on a table before a classic reorg must be done to update the table rows to match the current schema. 24 Executing an ALTER TABLE statement with the ADD COLUMN clause on a LOB or LONG column is not allowed in the same unit of work as an ALTER TABLE statement with the DROP COLUMN clause on the last LOB or LONG column in the table. In addition, on database servers Version 9.7 and later, executing an ALTER TABLE statement with the ADD COLUMN clause on an XML column is not allowed in the same unit of work as an ALTER TABLE statement with the DROP COLUMN clause on the last XML column in the table. 25 The table is in set integrity pending state. 26 Executing the ALTER TABLE ... ATTACH PARTITION or the ALTER TABLE ... DETACH PARTITION statement on a table whose database partition group is currently being redistributed is not allowed. 27 The alter table or copy schema operation called an internal procedure to manage database objects. The SYSTOOLS.DB2LOOK_INFO table used by the procedure is not in a valid state for the alter or copy operation. The SYSTOOLS.DB2LOOK_INFO table could be an older version, or totally different from what the procedure expects. 29 The operation that empties or truncates a table is not allowed because the table has a partition in one of the following three states: Attached that has not yet been checked for integrity (SYSCAT.DATAPARTITIONS.STATUS = 'A'). Detached partitions and there are dependent tables that need to be incrementally maintained with respect to these detached partitions (SYSCAT.DATAPARTITIONS.STATUS = 'D'). Detached partitions pending index cleanup (SYSCAT.DATAPARTITIONS.STATUS = 'I'). 30 A LOAD operation cannot be restarted when the following three things are true: The LOAD operation failed in the BUILD, DELETE or INDEX COPY PHASE The target table contains an XML column Either one of the following is also true: The table contains a unique index defined on an XML column ALLOW READ ACCESS was specified with the original LOAD command COPY YES was specified 43 The partitioned table has detached dependent tables and cannot support the creation of partitioned indexes. 44 The table is a source table for an attach partition operation of an ALTER TABLE statement and the table has a deferred index cleanup operation in progress as the result of an MDC rollout. Since MDC rollout using the deferred index cleanup mechanism is not supported for partitioned indexes, the attach operation will not be allowed if there are any RID indexes on the source table that will be kept during the attach operation, not rebuilt, and are pending asynchronous index cleanup of the rolled-out blocks. 49 The ALTER TABLE statement specifies SET DATA TYPE for a column that has already been changed and a REORG is pending on the table. 50 The operation could not be performed on the table because a dictionary for the table is currently being created in a background process. 60 The operation did not complete successfully because the indexes on the table are not rebuilt.  The asynchronous rebuild application, db2recindex, might be running slowly. 61 The operation did not complete successfully because the asynchronous rebuild of the indexes on the table failed.", "response": "Respond to this error according to the reason code: 21 Refer to the Administration Guide for information on Datalink Reconcile Pending (DRP) and Datalink Reconcile Not Possible (DRNP) states to take appropriate action. 22 Use SET INTEGRITY FOR table-name OFF before altering the table. Then alter the table and use SET INTEGRITY FOR table-name IMMEDIATE CHECKED FORCE GENERATED to generate the values for the new or altered column. 23 Reorg the table using the reorg table command. 24 Complete the unit of work that dropped the last LOB, LONG, or XML column, and re-issue the command. 25 Move the table out of set integrity pending state by using the SET INTEGRITY statement with IMMEDIATE CHECKED option, and then perform the operation again. 26 Wait for the REDISTRIBUTE DATABASE PARTITION GROUP command to complete and then reissue the ALTER TABLE statement. 27 Either rename or drop the SYSTOOLS.DB2LOOK_INFO table. The internal procedure will create the correct version of the SYSTOOLS.DB2LOOK_INFO table. Resubmit the alter table or copy schema operation. 29 Depending on the state of the table partition which is blocking the operation, take the appropriate action and then issue the command again: SYSCAT.DATAPARTITIONS.STATUS = 'A': Execute the SET INTEGRITY statement with the IMMEDIATE CHECKED or IMMEDIATE UNCHECKED option on the table with attached partitions SYSCAT.DATAPARTITIONS.STATUS = 'D': Execute the SET INTEGRITY statement with the IMMEDIATE CHECKED option on the dependent immediate materialized query and staging tables of the tables that still need to be incrementally maintained with respect to the detached partitions. Query the SYSCAT.TABDETACHEDDEP catalog view to locate these detached dependent tables. SYSCAT.DATAPARTITIONS.STATUS = 'I': Wait until index cleanup for the detached partition is completed. Query the SYSIBM.SYSTASKS to determine progress. 30 Respond to reason code 30 by following these steps: Change the state of the table from \"Load in Progress\" to \"Normal\" using the LOAD TERMINATE command. Rerun the original LOAD command. 43 Use the SET INTEGRITY statement with the IMMEDIATE CHECKED option to maintain the dependent tables, then create the partitioned index. 44 Wait for the deferred index cleanup operation to complete on the source table, then reissue the ALTER TABLE statement to attach the partition. To monitor the progress of the rollout cleanup, use the LIST UTILITIES command. 49 If the attempted data type change is in the same unit of work as the pending data type change, roll back the pending change and then reissue the ALTER TABLE statement. Otherwise, reorganize the table using the REORG TABLE command and then try the data type change again. 50 Wait for the background process that is creating the dictionary for the table to complete, and then reissue the command. 60 Reissue the command.  If the problem persists, contact your system administrator.  The system might be overloaded.  See reason code 61 for more information. 61 Reissue the command.  If the problem persists, contact your system administrator.  Administration log message ADM5543E reports the reason the rebuild failed.   The index rebuild is attempted automatically on the next successful access.  Message ADM5540W is written when the rebuild of the index object starts.  ADM6651W is written when starting the rebuild of each index.  ADM5542W is written when the index object has been successfully rebuilt.  Run a query of sysproc.admin_get_index_info to determine which indexes still have REQUIRES_REBUILD set to Y.  Run LIST APPLICATIONS to list any db2recindex applications that are rebuilding indexes asynchronously. sqlcode :  -20054 sqlstate :  55019", "version": "12.1"}
{"id": "SQL20055N", "message": "A result column data type in the select list is not compatible with the defined data type for column column-name .", "explanation": "The data type of the select list expression corresponding to column-name is not assignable to the data type for the attribute of the structured type.", "response": "Examine the current definition for the table and the associated structured type. Ensure the select list expression data type for the specified column is data type that is assignable to the attribute of the structure type. sqlcode :  -20055 sqlstate :  42854", "version": "12.1"}
{"id": "SQL20056N", "message": "Processing on DB2 Data Links Manager name encountered an error. Reason code = reason-code .", "explanation": "The processing on the DB2 Data Links Manager for the statement\n\tencountered an error as indicated by the following reason codes. 01 An inconsistency was detected between the data on the DB2 Data Links\n\tManager and a DATALINK value in a table. 02 The DB2 Data Links Manager reached a resource limit during the processing. 03 The DB2 Data Links Manager does not support file pathnames\n\tlonger than 128 characters. 99 The DB2 Data Links Manager encountered an internal processing error. The statement cannot be processed.", "response": "The action is based on the reason code as follows. 01 Run the reconcile utility on the table. 02 The DB2 Data Links Manager administrator should identify the resource from\n\tthe diagnostic logs and take corrective action. 03 You should ensure that the file pathname (excluding the file system\n\tprefix) to be stored in the DATALINK column does not exceed 128\n\tcharacters. For example, in the URL \"http://server.com/dlfiles/dir1/.../file1\"\n\t-- assuming the DLFS file system prefix is \"/dlfiles\" -- the file pathname\n\t\"/dir1/.../file1\" must not exceed 128 characters. 99 Save the diagnostic logs from the DB2 Data Links Manager and the database\n\tmanager and contact IBM service. sqlcode :   -20056 sqlstate :  58004", "version": "12.1"}
{"id": "SQL20057N", "message": "Column column-name in subview view-name cannot be defined as read only when the corresponding column is updatable in the superview.", "explanation": "The column identified by column-name in the subview view-name is defined (implicitly) as read only.\n\tThe superview of view-name includes the corresponding column that is\n\tupdatable.\n\tA column cannot be changed from updatable to read only in a typed view\n\thierarchy. The statement cannot be processed.", "response": "Change the CREATE VIEW statement so that the column of the subview view-name is updatable or drop the superview(s) and recreate them using\n\tthe READ ONLY clause to force the column to be read only. sqlcode :  -20057 sqlstate :  428EB", "version": "12.1"}
{"id": "SQL20058N", "message": "The statement failed because the fullselect specified for the materialized query table table-name violates a restriction. Reason code = reason-code .", "explanation": "Restrictions apply to the contents of a fullselect used in the definition of a materialized query table. Some restrictions are based on the materialized query table options, such as REFRESH DEFERRED or REFRESH IMMEDIATE. Other restrictions are based on whether or not the table is replicated. The fullselect in the statement that returned this condition violates at least one of these restrictions. If this message is returned during the creation of a staging table, the error applies to the query used in the definition of the materialized query table with which the staging table is associated. The reason code indicate which restriction was violated: 1 One or more of the select list elements have no name. 2 The fullselect referenced an unsupported object type. 3 The fullselect contained column references or expressions of an unsupported data type. 4 The fullselect contained column references or expressions or functions that violate one or more restrictions. 5 The REPLICATED option violated a restriction. 6 A fullselect violated a restriction when REFRESH IMMEDIATE was specified 7 The REFRESH IMMEDIATE option violated a restriction. 8 The REFRESH IMMEDIATE option was specified when a fullselect contained a GROUP BY clause and a restriction was violated. 9 The REFRESH IMMEDIATE option was specified and a fullselect was not a subselect. 10 The FROM clause referenced more than one table, and either the REFRESH IMMEDIATE option or the MAINTAINED BY REPLICATION option was specified. 11 The REFRESH IMMEDIATE option was specified and the input table expressions of a UNION ALL or a JOIN contained one or more aggregate functions. 12 The incremental maintenance of the materialized query table required space which exceeded the largest system temporary table space currently available in the database. 13 The fullselect included a CONNECT BY clause. 14 MAINTAINED BY FEDERATED_TOOL was specified in the CREATE TABLE statement and the select clause contained a reference to a base table. 15 An attempt was made to create an MQT in one of the following ways: A column-organized MQT is not defined as MAINTAINED BY REPLICATION but references a row-organized table A column-organized MQT does not specify the ORGANIZE BY COLUMN clause A row-organized MQT references a column-organized table 16 An attempt was made to create a column-organized materialized query table (MQT) in one of the following ways: Without specifying the MAINTAINED BY USER clause Without specifying the MAINTAINED BY REPLICATION clause By specifying the MAINTAINED BY SYSTEM clause without specifying the REFRESH DEFERRED and DISTRIBUTE BY REPLICATION clauses By specifying the REFRESH IMMEDIATE clause 17 The MAINTAINED BY REPLICATION clause was specified to create a shadow table, but the fullselect references a table that either violates a restriction or is missing a requirement of shadow tables. 18 The MAINTAINED BY REPLICATION clause was specified to create a shadow table, but the fullselect references columns that violate a restriction or that are missing a requirement for shadow tables. 19 The MAINTAINED BY REPLICATION clause was specified to create a shadow table, but the fullselect includes an expression or clause that is not supported with creating shadow tables. 20 The MAINTAINED BY REPLICATION clause was specified to create a shadow table, but the names of the columns of the shadow table do not exactly match the names of the selected columns of the base table.", "response": "Respond according to the reason code: 1 Ensure all elements have a name. You can use the AS clause to name expressions, or explicitly name all the columns in the column list of the materialized query table definition. 2 Do not reference unsupported objects. 3 Do not reference unsupported column or expression types. 4 Do not reference unsupported columns, expressions or functions. 5 Create the materialized query table as not replicated. Or correct the statement so the query refers to a single table and does not contain subqueries, aggregation, or the PARTITIONING clause. 6 Create the materialized query table as REFRESH DEFERRED, or: remove nickname references. remove DISTINCT. remove special registers and built-in functions that depend on the value of a special register. remove the not deterministic function or replace it with a deterministic function. remove all OLAP, sampling, and text functions. remove the aggregate function from the expression or change the expression to be a simple reference to the aggregate function. remove the aggregate functions or add a GROUP BY clause. correct the CREATE TABLE statement to ensure that no recursive common table expression is referenced. remove the subquery. 7 Create the materialized query table as REFRESH DEFERRED, or: correct the CREATE TABLE statement to ensure all GROUP BY items are in the select list. correct the GROUP BY clause to ensure there are no duplicate grouping sets. remove the nullable column, C, or add GROUPING(C) in the select list. correct the CREATE TABLE statement to ensure at least one unique key from each table referenced in the query appears in the select list. 8 Create the materialized query table as REFRESH DEFERRED, or: add COUNT(*) or COUNT_BIG(*) to the select list or remove the GROUP BY clause. add COUNT(*) to the select list or remove SUM(C), or alter the column C to be not nullable. remove unsupported aggregate functions or replace them with supported functions. remove the HAVING clause. correct the CREATE TABLE statement to ensure that the GROUP BY clause contains all of the partitioning key columns. 9 Create the materialized query table as REFRESH DEFERRED, or change the table definition to a subselect or to a UNION ALL in the input table expression of a GROUP BY. 10 Respond to reason code 10 in one of the following ways: If REFRESH IMMEDIATE is specified and the FROM clause used the explicit INNER JOIN syntax, change the FROM clause to reference a single table or replace the explicit INNER JOIN syntax with the implicit inner join syntax. If REFRESH IMMEDIATE was specified, replace it with REFRESH DEFERRED. If MAINTAINED BY REPLICATION was specified, change the FROM clause to reference a single table. 11 Create the materialized query table as REFRESH DEFERRED, or remove the aggregate functions from the input table of the UNION ALL or JOIN. 12 Create the materialized query table as REFRESH DEFERRED, or reduce the total row width, or number of columns of the MQT. Create a system temporary table space with suitable page size. 13 Ensure that the fullselect does not include a CONNECT BY clause. A hierarchical query cannot be used to create a materialized query table. 14 Rewrite the CREATE TABLE statement so that the select clause does not contain a reference to a base table. 15 Ensure that the column-organized MQT is referencing only column-organized tables or specifies MAINTAINED BY REPLICATION, or specifies ORGANIZE BY COLUMN. Also ensure that a row-organized MQT is referencing only row-organized tables. Then re-issue the statement. 16 Ensure that the statement contains one of the following clauses, then re-issue the statement. MAINTAINED BY USER MAINTAINED BY REPLICATION MAINTAINED BY SYSTEM, with the REFRESH DEFERRED and DISTRIBUTE BY REPLICATION clauses REFRESH DEFERRED, instead of REFRESH IMMEDIATE 17 To create a shadow table on the specified base table, alter the specified base table so that the table is supported as a base table for shadow tables. 18 To create a shadow table on the specified base table, include different columns in the fullselect or ensure that the specified columns satisfy all requirements. 19 Modify the fullselect to satisfy requirements for creating shadow tables. 20 Define the shadow table so that the names of the columns of the shadow table exactly match the names of the selected columns of the base table. sqlcode :  -20058 sqlstate :  428EC", "version": "12.1"}
{"id": "SQL20059W", "message": "The materialized query table table-name may not be used to optimize the processing of queries.", "explanation": "The materialized query table is defined with REFRESH DEFERRED and a fullselect that is currently not supported by the database manager when optimizing the processing of queries. The rules are based on the materialized query table options (REFRESH DEFERRED or REFRESH IMMEDIATE). The fullselect in the CREATE TABLE statement that returned this condition violates at least one of the rules as described in the SQL Reference. The materialized query table is successfully created but will only be routed to for queries that reference the materialized query table directly.", "response": "No action is required. However, if the materialized query was intended to optimize the processing of queries that do not reference the materialized query table directly, then this can be achieved as follows. Create a view using the fullselect specified for table-name and then re-create the materialized query table table-name using a fullselect that simply does a \"SELECT *\" from the view. This way, the materialized query table can be routed to by queries that reference the view. sqlcode :  +20059 sqlstate :  01633", "version": "12.1"}
{"id": "SQL20060N", "message": "The key transform table function used by the index extension of index index-id of table table-id in tbspace-id generated duplicate rows.", "explanation": "The key transform table function specified by the GENERATE USING clause of\n\tthe index extension used by index index-id generated\n\tduplicate rows. For a given invocation of the key transform table function,\n\tno duplicate rows should be produced. This error is occurred when inserting\n\tor updating the key value for the index index-id of table table-id in table space tbspace-id . The statement cannot be processed.", "response": "The code for the key transform table function used by the index extension\n\tof index index-id must be modified to avoid the creation\n\tof duplicate rows. To determine the index name, use the following query: SELECT IID, INDSCHEMA, INDNAME\n\t  FROM SYSCAT.INDEXES AS I,\n\t\t   SYSCAT.TABLES AS T\n\t  WHERE IID = <index-id>\n\t\t  AND TABLEID = <table-id>\n\t\t  AND TBSPACEID = <tbspace-id>\n\t\t  AND T.TBASCHEMA = I.TABSCHEMA\n\t\t  AND T.TABNAME = I.TABNAME Copy to clipboard sqlcode :  -20060 sqlstate :  22526", "version": "12.1"}
{"id": "SQL20062N", "message": "Transform function transform-type in transform group group-name for type type-name cannot be used for a function or method.", "explanation": "The transform function defined in the transform group group-name for type type-name cannot be used for a function or method because the transform function\n\tis not written in SQL (defined with LANGUAGE SQL). The transform group\n\tcannot be used for this function or method. The statement cannot be processed.", "response": "Specify a transform group for type type-name that\n\thas the transform functions defined with LANGUAGE SQL. sqlcode :  -20062 sqlstate :  428EL", "version": "12.1"}
{"id": "SQL20063N", "message": "TRANSFORM GROUP clause must be specified for type type-name .", "explanation": "The function or method includes a parameter or returns data\n\ttype of type-name that does not have a transform\n\tgroup specified. The statement cannot be processed.", "response": "Specify a TRANSFORM GROUP clause with a transform group name\n\tthat is defined for type-name . sqlcode :  -20063 sqlstate :  428EM", "version": "12.1"}
{"id": "SQL20064N", "message": "Transform group group-name does not support any data type specified as a parameter or returned data type.", "explanation": "The transform group group-name specified in\n\tthe TRANSFORM GROUP clause is not defined for any data type\n\tthat is included in the parameter list or the RETURNS clause of\n\ta function or method. The statement cannot be processed.", "response": "Remove the transform group from the function or method definition. sqlcode :  -20064 sqlstate :  428EN", "version": "12.1"}
{"id": "SQL20065N", "message": "Transform group group-name for data type type-name cannot be used to transform a structured type for use with a client application.", "explanation": "The transform group group-name for data type type-name defines a transform function that cannot\n\tbe used when performing transforms for client applications. The possible\n\treasons for this are based on the definition of the transform function\n\tthat is not supported for client applications. The unsupported transform\n\tfunction may be: a FROM SQL function that is a ROW function a TO SQL function has more than one parameter The statement cannot be processed.", "response": "For static embedded SQL, specify a different transform group\n\tusing the TRANSFORM GROUP bind option. For dynamic SQL, specify a\n\tdifferent transform group using the SET DEFAULT TRANSFORM GROUP\n\tstatement. sqlcode :  -20065", "version": "12.1"}
{"id": "SQL20066N", "message": "The transform-type transform function is not defined in the transform group group-name for data type type-name .", "explanation": "The transform-type transform function of transform\n\tgroup group-name for data type type-name is required for a transform group used\n\tin a function or method definition. The statement cannot be processed.", "response": "If creating a function or method, specify a different transform\n\tgroup in the function or method definition. If referencing a\n\tstructured type in a dynamic SQL statement, specify a different\n\ttransform group for the CURRENT DEFAULT TRANSFORM GROUP special\n\tregister. Alternatively, add a transform-type transform function to the transform group group-name for data type type-name . sqlcode :  -20066 sqlstate :  42744", "version": "12.1"}
{"id": "SQL20067N", "message": "The transform-type transform function is defined more than once in the transform group group-name for data type type-name .", "explanation": "A TO SQL or FROM SQL transform function can only be specified once\n\tin a transform group. The transform group group-name for data type type-name has at least two FROM SQL\n\tor TO SQL (or both) transform functions defined. The statement cannot be processed.", "response": "Delete the TO SQL or FROM SQL definitions from group-name in the transform definition\n\tso that there is only one of each. sqlcode :  -20067 sqlstate :  42628", "version": "12.1"}
{"id": "SQL20068N", "message": "The structured type type-name may not be defined so that one of its attribute types directly or indirectly uses itself. The attribute attribute-name causes the direct or indirect use.", "explanation": "Direct use: Type A is said to directly use type B\n\tif one of the following is true: Type A has an attribute of type B Type B is a subtype of A, or a supertype of A. Indirect use: Type A is said to indirectly use\n\ttype B if the following is true: Type A uses type C, and type C uses type B. You cannot define a type so that one of its attribute types\n\tdirectly or indirectly uses itself. The type for attribute attribute-name is the cause of the direct or indirect use.", "response": "Evaluate the type and remove the attribute type that\n\tcauses the direct or indirect use. sqlcode :   -20068 sqlstate :  428EP", "version": "12.1"}
{"id": "SQL20069N", "message": "The RETURNS type of the routine-type routine-name is not the same as the subject type.", "explanation": "The method method-name specifies SELF AS RESULT.\n\tThe RETURNS data type of the method must be the same as the\n\tsubject data type of the method.", "response": "Change the RETURNS type of the method method-name to\n\tmatch the subject type. sqlcode :   -20069 sqlstate :  428EQ", "version": "12.1"}
{"id": "SQL20075N", "message": "The index or index extension index-name cannot be created or altered because the length of column-name is more than 255 bytes.", "explanation": "The index could not be created or altered because the key column\n\tlength is greater than 255. index-name is the index name. column-name is the name of the key column. If this error was\n\treturned from an ALTER TABLE or ALTER NICKNAME operation, then the value of column-name is the column number. The index extension could not be created because a column returned by the\n\tGENERATE KEY function is greater than 255 bytes. index-name is the index extension name. column-name is the name of a column returned\n\tby the GENERATE KEY function. The statement could not be processed.  The specified index or index\n\textension was not created, or the table or nickname could not be altered.", "response": "If creating an index, eliminate the column from the index\n\tdefinition.  If altering a table, reduce the new column length\n\tto the permitted maximum. If creating an index extension, specify a different\n\tGENERATE KEY function, or redefine the function to eliminate the column. sqlcode :   -20075 sqlstate :  54008", "version": "12.1"}
{"id": "SQL20076N", "message": "The instance for the database is not enabled for the specified action or operation.  Reason code = reason-code .", "explanation": "An error has been detected at the instance level. The requested operation\n\tcannot be completed because a specified functional area was not installed\n\tor because a specified functional area was not enabled to the instance. The following is the list of reason codes and associated functional areas\n\tyou can enable at the instance level: The ability to execute distributed request operations against multiple\n\tdata sources in a single statement.", "response": "Enable the instance for the requested action or operation.\n\tFirst, install the specified functional area if it is missing.\n\tThen, enable the specified functional area. Enablement steps vary\n\tby reason-code : For a federated server, set the DBM variable <FEDERATED> to YES and then restart the\n\tdatabase manager. sqlcode :   -20076 sqlstate :  0A502", "version": "12.1"}
{"id": "SQL20077N", "message": "Cannot construct structured type objects that have Datalink type attributes.", "explanation": "An attempt was made to invoke the constructor of a structured type which\n\thas a Datalink and/or a Reference type attribute. This functionality\n\tis currently not supported. In Version 6.1 or earlier, this error may\n\talso be issued for a structured type object with a Reference type\n\tattribute. The statement cannot be processed.", "response": "The error can be corrected by doing one of the following: Removing the invocation of the constructor of the type from the program. Removing any Datalink (or Reference) type attributes from the definition of\n\tthe structured type (this may not be possible if there are any tables that\n\tdepend on this type). sqlcode :   -20077 sqlstate :  428ED", "version": "12.1"}
{"id": "SQL20078N", "message": "Hierarchy object object-name of type object-type can not be processed using operation operation-type .", "explanation": "The operation operation-type was attempted using a hierarchy object named object-name of type object-type .\n\tThis operation does not support processing of a hierarchy object. The statement could not be processed.", "response": "Verify that the correct object name was used.\n\tFor objects types TABLE or VIEW, the object\n\tmust be the name of a subtable in the table\n\tor view hierarchy.\n\tIn some cases, the object must specifically\n\tname the root table.\n\tFor objects of type index, the name must be a\n\tname of an index created on a subtable. sqlcode :   -20078 sqlstate :  42858", "version": "12.1"}
{"id": "SQL20080N", "message": "Method specification for method-name cannot be dropped because a method body exists.", "explanation": "The method specification method-name still has an\n\texisting method body that must be dropped before the method specification\n\tcan be dropped. The statement cannot be processed.", "response": "Use the DROP METHOD statement with the same method specification\n\tto drop the method body and then issue the ALTER TYPE statement again\n\tto drop the method specification. sqlcode :   -20080 sqlstate :  428ER", "version": "12.1"}
{"id": "SQL20081N", "message": "The method body cannot be defined for a LANGUAGE language-type method specification method-name .", "explanation": "The method specification method-name is defined with\n\tLANGUAGE language-type . If the LANGUAGE is SQL, the\n\tmethod body must be an SQL control statement. For other languages, the\n\tEXTERNAL clause must be specified. The statement cannot be processed.", "response": "Change the method body to match the LANGUAGE specified in\n\tthe method specification. sqlcode :   -20081 sqlstate :  428ES", "version": "12.1"}
{"id": "SQL20082N", "message": "The dynamic type expression-type-id of the expression is not a subtype of the target data type target-type-id in a TREAT specification.", "explanation": "The dynamic data type of the result of the expression specified\n\tin the TREAT specification is expression-type-id .\n\tThe specified target data type target-type-id is\n\ta proper subtype of expression-type-id which is not allowed. The statement cannot be processed.", "response": "Change the target-type-id of the TREAT\n\tspecification to a supertype of expression-type-id or change the expression so that the dynamic data type of the result\n\tis a subtype of target-type-id . To determine the data type names for expression-type-id and target-type-id , use the following query: SELECT TYPEID, TYPESCHEMA, TYPENAME\n\tFROM SYSCAT.DATATYPES\n\tWHERE TYPEID IN INTEGER(\n\t  expression-type-id),\n\t  INTEGER(\n\t\ttarget-type-id\n\t  )\n\t) Copy to clipboard sqlcode :   -20082 sqlstate :  0D000", "version": "12.1"}
{"id": "SQL20083N", "message": "The data type of the value returned by routine-type routine-id does not match the data type specified as RESULT.", "explanation": "The method routine-id specifies SELF AS RESULT and\n\ttherefore requires that the data type of the value returned must be the\n\tsame as the subject data type used to invoke the method. The RETURN\n\tstatement in either the SQL method body or in the TO SQL transform\n\tfunction for the type of an external method resulted in the incorrect data\n\ttype. The statement cannot be processed.", "response": "Change the RETURN statement of the method or transform function\n\tto ensure that the data type of the returned value is always the\n\tsubject type used to invoke the method. To determine the routine name associated with the routine-id , use the following query: SELECT FUNCSCHEMA, FUNCNAME,\n\t\t   SPECIFICNAME\n\tFROM   SYSCAT.FUNCTIONS\n\tWHERE  FUNCID = INTEGER(\n\t\t\t routine-id\n\t\t   ) Copy to clipboard sqlcode :   -20083 sqlstate :  2200G", "version": "12.1"}
{"id": "SQL20084N", "message": "The routine-type routine-name would define an overriding relationship with an existing method.", "explanation": "A method MT, with subject type T, is defined to override\n\tanother method MS, with subject type S, if all of the following\n\tconditions are true: MT and MS have the same unqualified name and the same number\n\tof parameters. T is a proper subtype of S. The non-subject parameter-types of MT are the same as the\n\tcorresponding non-subject parameter-types of MS. (Here,\n\tsame applies to the basic type, such as VARCHAR,\n\tdisregarding length and precision). A function and a method may not be in an\n\toverriding relationship. This means that if the function\n\twere a method with its first parameter as subject S, it must\n\tnot override another method of any supertype of S and it must\n\tnot be overridden by another method of any subtype of S. Furthermore, overriding relationships are not supported for: table and row methods external methods with PARAMETER STYLE JAVA system generated mutator and observer methods The statement cannot be processed.", "response": "Change the routine that is being defined to use a different\n\troutine name than routine-name or change\n\tthe parameters of the routine. sqlcode :   -20084 sqlstate :  42745", "version": "12.1"}
{"id": "SQL20085N", "message": "A routine defined with PARAMETER STYLE JAVA cannot have structured type type-name as a parameter type or as the returns type.", "explanation": "A routine is defined with PARAMETER STYLE JAVA and one of\n\tthe parameter types or a returns type is defined using the\n\tstructured type type-name . This is not\n\tsupported by this version of DB2. The statement cannot be processed.", "response": "Change to a different parameter style for the routine or\n\tremove the structured type from the routine definition. sqlcode :   -20085 sqlstate :  429B8", "version": "12.1"}
{"id": "SQL20086N", "message": "Length of the structured type value for a column exceeds the system limit.", "explanation": "The value for a structured type column exceeds 1 gigabyte in overall size,\n\tincluding descriptor data for the instance.\n\tThe column could be one that is being inserted or\n\tupdated directly or it may be a column that is generated. The statement cannot be processed.", "response": "Reduce the size of the structured type value that is being assigned to the column. sqlcode :   -20086 sqlstate :  54049", "version": "12.1"}
{"id": "SQL20087N", "message": "DEFAULT or NULL cannot be used in an attribute assignment.", "explanation": "The UPDATE statement is using an attribute assignment to set\n\tthe value of an attribute in a structured type column. This\n\tform of assignment statement does not allow the use of the\n\tkeyword DEFAULT or the keyword NULL as the right hand side\n\tof the assignment. The statement cannot be processed.", "response": "Specify an expression for the right hand side of the attribute\n\tassignment or change the assignment so it is not using the\n\tattribute assignment syntax. sqlcode :   -20087 sqlstate :  428B9", "version": "12.1"}
{"id": "SQL20089N", "message": "A method name cannot be the same as a structured type name within the same type hierarchy.", "explanation": "A specified method name is the same as the structured type\n\twhich is defined for one of the supertypes or subtypes\n\tof the structured type. The statement cannot be processed.", "response": "Specify a different name for the method. sqlcode :   -20089 sqlstate :  42746", "version": "12.1"}
{"id": "SQL20090W", "message": "The use of the structured type having attribute attribute-name of type DATALINK is effectively limited to the type of a typed table or type view.", "explanation": "The attribute attribute-name is defined with\n\ta type of DATALINK or a distinct type based on a DATALINK. A\n\tstructured type that includes such an attribute can only be used\n\tas the type of a table or view.\n\tIf used as the type of a column of a table or view it can only be\n\tassigned the null value. The statement continued processing.", "response": "Consider the intended use of the structured type. If the type\n\twill be used as a column data type, then remove\n\tthe attribute attribute-name from the structured type\n\tor use a data type other than DATALINK for the attribute. sqlcode :   +20090 sqlstate :  01641", "version": "12.1"}
{"id": "SQL20092N", "message": "The statement failed because a table or view was specified in the LIKE clause and the object cannot be used in this context.", "explanation": "The LIKE clause for a CREATE GLOBAL TEMPORARY TABLE statement or DECLARE GLOBAL TEMPORARY TABLE statement  specified the name of a table that has a column defined as IMPLICITLY HIDDEN. Since the implicitly  hidden attribute is not supported for created temporary tables and declared temporary tables, the table  cannot be specified in the LIKE clause.", "response": "Specify the name of a table that is not defined with an implicitly hidden column. In order to specify a created temporary table or declared temporary table that includes columns that  are defined as IMPLICITLY HIDDEN, use the AS (fullselect) option to explicitly specify those columns in the  table. As a result, the IMPLICITLY HIDDEN attribute is not copied to the column being defined. sqlcode :  -20092 sqlstate :  560AE", "version": "12.1"}
{"id": "SQL20093N", "message": "The table table-name cannot be converted to or from a materialized query table. Reason code = reason-code .", "explanation": "The ALTER TABLE statement is being used to change a table from a materialized query table to DEFINITION ONLY or to convert a regular table to a materialized query table. The ALTER TABLE statement failed as indicated by the following reason codes. 1 The table is a typed table or hierarchy table. 2 The table is not a materialized query table and DEFINITION ONLY was specified. 3 The table is a replicated materialized query table and DEFINITION ONLY was specified. 4 The table has at least one trigger defined. 5 The table has at least one check constraint defined. 6 The table has at least one unique constraint or unique index defined. 7 The table has at least one referential constraint defined. 8 The table is referenced in the definition of an existing materialized query table. 9 The table is referenced directly or indirectly (through a view, for example) in the fullselect. 10 The table is already a materialized query table. 11 The number of columns of the existing table does not match the number of columns defined in the select list of the fullselect. 12 The data types of the columns of the existing table do not exactly match the corresponding columns in the select list of the fullselect. 13 The column names of the columns of the existing table do not exactly match the corresponding column names in the select list of the fullselect. 14 The nullability characteristics of the columns of the existing table do not exactly match the nullability characteristics of the corresponding columns in the select list of the fullselect. 15 The conversion cannot be performed if there are any other table alterations in the same ALTER TABLE statement. 16 The table is referenced in the definition of an existing view enabled for query optimization. 17 The table is a protected table. 18 The fullselect refers to a nickname on which caching is not allowed. 19 The table is a system-period temporal table or a history table. 20 The table has a permission or mask defined by a security administrator. 21 An attempt was made to convert the table into a shadow table by specifying the MAINTAINED BY REPLICATION clause, but the table cannot be converted to a shadow table because the table is organized by row. 22 An attempt was made to convert the table into a shadow table by specifying the MAINTAINED BY REPLICATION clause, but the table cannot be converted to a shadow table because the table has a unique constraint or index other than a primary key, or the primary key was defined as NOT ENFORCED.", "response": "Respond according to the reason code: 1 The table cannot be converted to a materialized query table. Create a new materialized query table instead. 2 There is no need to convert this table. No action required. 3 A replicated table can only be a materialized query table. Create a new table instead. 4 Drop any triggers and try the ALTER TABLE statement again. 5 Drop any check constraints and try the ALTER TABLE statement again. 6 Drop any unique constraints and unique indexes. Try the ALTER TABLE statement again. 7 Drop any referential constraints and try the ALTER TABLE statement again. 8 Drop the materialized query table that references the table and try the ALTER TABLE statement again. 9 A materialized query table cannot reference itself. Modify the fullselect to remove the direct or indirect reference to the table being altered. 10 The operation is not allowed since the table is already a materialized query table. 11 Modify the fullselect to include the correct number of columns in the select list. 12 Modify the fullselect so that the result column data types exactly match the data types of the corresponding existing columns. 13 Modify the fullselect so that the result column names exactly match the column names of the corresponding existing columns. 14 The table cannot be converted to a materialized query table unless the nullability characteristics can be matched. Create a new materialized table instead. 15 Perform the other table alterations in an ALTER TABLE statement that does not include the SET MATERIALIZED QUERY AS clause. 16 Disable the view enabled for query optimization that references the table and try the ALTER TABLE statement again. 17 Either remove the protection from the table or do not convert it to a materialized query table. 18 Correct the fullselect specified in the ALTER TABLE statement so that it does not reference a nickname on which caching is not allowed. 19 Either correct the table name to specify a table that is not a system-period temporal table or history table, or alter the system-period temporal table with an ALTER TABLE statement that specifies a DROP VERSIONING clause. 20 Either remove the permissions and masks or do not convert it to a materialized query table. 21 To convert the table into a shadow table, first convert the table to be organized by column. 22 To convert the table into a shadow table, remove all unique constraints and indexes other than a primary key from the table, or define the primary key as ENFORCED. sqlcode :  -20093 sqlstate :  428EW", "version": "12.1"}
{"id": "SQL20094N", "message": "The statement failed because the column column-name is a generated column or is defined with the data type DB2SECURITYLABEL and cannot be used in the BEFORE trigger trigger-name .", "explanation": "The indicated column cannot be named in the column name list of a BEFORE UPDATE trigger or set in a BEFORE trigger because it is one of the following: A row-begin column A row-end column A transaction-start-ID column A generated expression column A column defined with the data type DB2SECURITYLABEL The statement cannot be processed.", "response": "Remove the column from either the column name list or the SET assignment statement that sets the  new transition variable of a generated column and resubmit the statement. sqlcode :  -20094 sqlstate :  42989", "version": "12.1"}
{"id": "SQL20102N", "message": "The CREATE or ALTER statement for the routine routine-name specified the option-name option which is not allowed for the routine.", "explanation": "The option option-name was specified when creating or\n\taltering the routine routine-name . The option does not apply\n\tto the routine because of other characteristics of the routine.\n\tFor sourced procedures, only ALTER PARAMETER can be specified,\n\tand ALTER PARAMETER can only be specified for sourced procedures.", "response": "For an ALTER statement, ensure that the correct routine is being specified.\n\tOtherwise, remove the failing option and reissue the statement. sqlcode :  -20102 sqlstate :  42849", "version": "12.1"}
{"id": "SQL20108N", "message": "A result set contains an unsupported data type in position position-number for the cursor cursor-name opened by the stored procedure procedure-name .", "explanation": "The stored procedure named by procedure-name cannot return at least one of\n\tits query result sets named by cursor-name  because at least one of the columns,\n\tcolumn position-number contains a data type which is not supported by either\n\tthe DRDA Application Requestor (client) or the DRDA Application Server (server).\n\tAs such the call to the stored procedure fails.", "response": "Modify the OPEN statement (and subsequent FETCH statements) for\n\tcursor cursor-name in the stored procedure procedure-name on the server to\n\tnot select the unsupported data type in column position-number.  The client\n\tapplication which invoked the stored procedure may need to be modified to\n\treflect the change in the stored procedure. sqlcode :   -20108 sqlstate :  56084", "version": "12.1"}
{"id": "SQL20109W", "message": "Error in DB2 debugger support. Reason code: reason-code .", "explanation": "The debugger support had an error situation which will disable debugging, but not affect normal execution. The following is a list of reason codes: The debugger support is not installed. There has been a syntax error in IP address of debugger client in the debugger table. A timeout in the communication between the debugger backend and the debugger client occurred. A problem occurred accessing the debugger table DB2DBG.ROUTINE_DEBUG.", "response": "Verify that you installed the debugger option on the database server machine. Make sure that the IP address in the debugger table has the correct syntax. Check that the debugger daemon on the client is started and that the ports on the client and server match. Verify that you have created the debugger tables with the correct layout. sqlcode :  +20109 sqlstate :  01637", "version": "12.1"}
{"id": "SQL20111N", "message": "A SAVEPOINT, RELEASE SAVEPOINT, or ROLLBACK TO SAVEPOINT statement cannot be issued in this context. Reason code = reason-code .", "explanation": "The statement cannot be processed because it violates a restriction\n\tas indicated by the following reason code: Savepoint cannot be issued inside a trigger. Savepoint cannot be issued inside a global transaction. The statement cannot be processed.", "response": "Remove the SAVEPOINT, RELEASE SAVEPOINT, or ROLLBACK TO\n\tSAVEPOINT statement in the trigger or global transaction. sqlcode :  -20111 sqlstate :  3B503", "version": "12.1"}
{"id": "SQL20112N", "message": "A savepoint cannot be set because a savepoint already exists and nested savepoints are not supported.", "explanation": "A savepoint is a named entity that represents the state of data and schemas at a particular point in time within a unit of work.  You can use savepoints in several ways.  For example, you can roll a database back to a savepoint.  You can set a savepoint within a transaction using the SAVEPOINT statement.  In some environments, you can also set multiple, or nested, savepoints within the same transaction. This message can be returned when an error occurred in a SAVEPOINT statement or atomic compound SQL statement for the following reasons: An attempt has been made to set a nested savepoint, but a savepoint already exists and nested savepoints are not supported in this environment. An attempt has been made to set a nested savepoint for a federated data source that does not support nested savepoints.", "response": "Respond to this error in one of the following ways: Release existing savepoints before attempting to set new savepoints. To re-establish an existing savepoint perform the following steps: Free the existing savepoints using the RELEASE SAVEPOINT statement. Recreate the savepoint using the SAVEPOINT statement. For atomic compound SQL: set the savepoint after the end of the compound statement. sqlcode :  -20112 sqlstate :  3B002", "version": "12.1"}
{"id": "SQL20113N", "message": "Null cannot be returned from method method-id defined with SELF AS RESULT.", "explanation": "The method with method identifier method-id is defined with SELF AS RESULT. The invocation of the method\n\tused a non-null instance of a structured type so the method\n\tcannot return a null instance.", "response": "Change the method implementation to ensure that a null value\n\tis not returned as the return value for the method. One possibility\n\tis to set all the attributes of the returned structured type\n\tto null value. To determine the name of the method that failed,\n\tuse the following query: SELECT FUNCSCHEMA, FUNCNAME,\n\t\t   SPECIFICNAME\n\t  FROM SYSCAT.FUNCTIONS\n\t  WHERE FUNCID = method-id Copy to clipboard sqlcode :   -20113 sqlstate :  22004", "version": "12.1"}
{"id": "SQL20114W", "message": "Column column-name in table table-name is not long enough for the defined length of the USER default value.", "explanation": "The column column-name is defined with a length that is less\n\tthan 128 bytes. The clause DEFAULT USER has been specified for this column.\n\tSince the USER special register is defined as VARCHAR(128), any attempt to\n\tassign the default value for table-name by a user with a\n\tuser ID longer than the column length results in an error. A user with a user ID\n\tlonger than the column length would never be able to insert or update this\n\tcolumn to the default value.", "response": "If your system standards would not allow a user ID to exceed the\n\tlength of the column, then this warning may be ignored. To prevent\n\tthis warning from occurring, the length of the column must be at least\n\t128 bytes. You can change the column length by dropping and creating\n\tthe table again, or, if the data type is VARCHAR, by using ALTER TABLE\n\tto increase the length of the column. sqlcode :  +20114 sqlstate :  01642", "version": "12.1"}
{"id": "SQL20115N", "message": "The routine-type routine-name cannot be used as a transform-type transform function in transform group group-name .", "explanation": "If routine-type is FUNCTION, then the function defined\n\tby routine-name cannot be used as a transform function\n\tbecause it is a built-in function.\n\tIf routine-type is METHOD, then the method defined by routine-name cannot be used as a transform function\n\tbecause it is a method. The statement cannot be processed.", "response": "Specify a different function for the transform-type transform function of transform group group-name . sqlcode :   -20115 sqlstate :  428EX", "version": "12.1"}
{"id": "SQL20116N", "message": "The data type of the search target parameter-name does not match that of the source key specified in the index extension index-extension-name .", "explanation": "If the search target is of a built-in or distinct data type, its type\n\tmust exactly match that of the source key specified in the index extension.\n\tIf the data type of the search target is a structured type, it must be in\n\tthe same structured type hierarchy as the data type of the source key\n\tin the index extension. The statement cannot be processed.", "response": "Specify a search target with a data type that matches that of the\n\tsource key in the index extension. sqlcode :   -20116 sqlstate :  428EY", "version": "12.1"}
{"id": "SQL20117N", "message": "A window specification for an OLAP function is not valid. Reason code = reason-code .", "explanation": "The window specification (OVER clause) of an OLAP function invocation\n\tis not correctly specified.\n\tThe incorrect specification is indicated by the reason-code . 1 RANGE or ROWS is specified without an ORDER BY in the window specification. 2 RANGE is specified and the window ORDER BY clause includes more than\n\tone sort-key-expression. 3 RANGE is specified and the data type of the range value cannot be used\n\tin a subtraction expression with the data type of the sort-key-expression in\n\tthe window ORDER BY clause. 4 UNBOUNDED PRECEDING is specified after CURRENT ROW or UNBOUNDED FOLLOWING\n\tis specified before CURRENT ROW. The statement cannot be processed.", "response": "Change the window specification to correct the invalid specification indicated\n\tby the reason-code . 1 Add a window ORDER BY clause to each window specification that specifies RANGE or ROWS. 2 Ensure that each window specification that includes RANGE has exactly\n\tone sort-key-expression in the window ORDER BY clause. 3 For each window specification that includes RANGE, ensure that the range\n\tvalue can be subtracted from the sort-key-expression in the window\n\tORDER BY clause, which must be a numeric type or a datetime type.\n\tFor datetime sort-key-expressions, the range value must be the specific\n\tdatetime duration DECIMAL type with the correct precision and scale. 4 Ensure that any window specification using BETWEEN and\n\tCURRENT ROW has the UNBOUNDED PRECEDING before\n\tAND CURRENT ROW or UNBOUNDED FOLLOWING after\n\tCURRENT ROW AND. sqlcode :   -20117 sqlstate :  428EZ", "version": "12.1"}
{"id": "SQL20118N", "message": "Structured type type-name has more than the maximum number of allowable attributes. The maximum is max-value .", "explanation": "The maximum number of attributes, including\n\tinherited attributes, allowed for each structured type has\n\tbeen exceeded with the definition of structured type type-name . The maximum number of attributes,\n\tincluding inherited attributes, is max-value . The statement cannot be processed.", "response": "Ensure that the number of attributes for the structured\n\ttype does not exceed the limit. sqlcode :   -20118 sqlstate :  54050", "version": "12.1"}
{"id": "SQL20119N", "message": "A ROW function must define at least two columns.", "explanation": "A function that specifies ROW in the RETURNS clause must\n\tinclude a column list with at least two columns.", "response": "Either remove the ROW keyword from the RETURNS clause to\n\tmake it a scalar function or specify multiple columns in\n\tthe column list of the RETURNS clause. sqlcode :   -20119 sqlstate :  428F0", "version": "12.1"}
{"id": "SQL20120N", "message": "An SQL TABLE function must return a table result.", "explanation": "An SQL function that specifies TABLE in the RETURNS clause must\n\treturn a result that is a table. With the exception of a scalar\n\tfullselect, a scalar expression cannot be returned as\n\tthe result of an SQL TABLE function.", "response": "Either remove the TABLE keyword from the RETURNS clause to make\n\tit a scalar function or specify a fullselect in the RETURN statement\n\tof the TABLE function body. sqlcode :   -20120 sqlstate :  428F1", "version": "12.1"}
{"id": "SQL20121N", "message": "Only one of WITH RETURN or SCROLL can be specified for cursor cursor-name .", "explanation": "Both WITH RETURN and SCROLL were specified for cursor cursor-name ,\n\tbut this is not allowed. The statement cannot be processed.", "response": "Change the DECLARE CURSOR statement to either specify NO SCROLL (or remove the\n\tSCROLL keyword), or remove the WITH RETURN clause. sqlcode :   -20121 sqlstate :  428F3", "version": "12.1"}
{"id": "SQL20123N", "message": "Call to stored procedure procedure failed because the result set returned for a scrollable cursor is not positioned before the first row.", "explanation": "A scrollable result set has been returned by a CALL to stored procedure procedure ,\n\tand one or more of these cursors is not positioned before the first row. The CALL to the stored procedure was not successful. All result set cursors defined\n\tin the stored procedure were closed before returning to the caller. The scrollable\n\tcursor cannot be used to FETCH from the result set. Actions done by the stored procedure\n\tare not rolled back, and any external actions initiated by the stored procedure have\n\tcompleted because the error was detected at the end of the execution of the stored\n\tprocedure.", "response": "Modify the content of the stored procedure to make sure that the result set cursors\n\tare positioned before the first row before returning to the caller. sqlcode :  -20123 sqlstate :  560B1", "version": "12.1"}
{"id": "SQL20128N", "message": "Cursor cursor-name is scrollable, but the result table cannot include output from a table function.", "explanation": "The cursor cursor-name is defined to be scrollable, but the result table includes\n\toutput from a table function. This combination is not supported. The statement cannot be processed.", "response": "Either modify the definition of the cursor so it is not scrollable, or ensure that the\n\tresult table does not include output from a table function. sqlcode :  -20128 sqlstate :  428F6", "version": "12.1"}
{"id": "SQL20131N", "message": "Object number object-number of type object-type was specified more than once in a list of objects.", "explanation": "In a list of object names of type object-type , the object numbered object-number was specified more than once. The operation of the\n\tstatement cannot be performed on the object more than once.", "response": "Correct the duplicated object in the list removing duplicate occurrences.\n\t(In the MDC case, the object type will be dimension.) sqlcode :  -20131 sqlstate :  42713", "version": "12.1"}
{"id": "SQL20133N", "message": "Operation operation-name cannot be performed on external routine routine-name . The operation can only be performed on SQL routines.", "explanation": "You attempted to perform operation operation-name on external routine routine-name . However, you can\n\tonly perform that operation on SQL routines. The operation did not\n\tcomplete successfully.", "response": "Ensure the name you provide identifies an SQL routine. sqlcode :   -20133 sqlstate :  428F7", "version": "12.1"}
{"id": "SQL20134N", "message": "The SQL Archive (SAR) file for routine routine-name could not be created on the server.", "explanation": "The creation of the SQL archive (SAR) for routine routine-name failed because the database manager could not find either the library or the bind file for the\n\tspecified routine. Bind files are only available for SQL routines created with\n\tDB2 Version 7.1, FixPak 2 or later.", "response": "Recreate the procedure on a server with DB2 Version 7.1, FixPak 2 or later, and try the operation again. sqlcode :   -20134 sqlstate :  55045", "version": "12.1"}
{"id": "SQL20135N", "message": "The specified SQL archive does not match the target environment. Reason code = reason-code .", "explanation": "The specified SQL archive does not match the target environment for one\n\tof the following reasons: 1 The operating system of the target environment is not the same as the\n\toperating system on which the SQL archive was created. 2 The database type and level of the target environment is not the same\n\tas the database type and level on which the SQL archive was created.", "response": "Ensure that the environment on which the SQL archive was created matches\n\tthe target environment and reissue the command. If the environments do\n\tnot match, you must manually create the SQL routine using the target environment. sqlcode :   -20135 sqlstate :  55046", "version": "12.1"}
{"id": "SQL20136N", "message": "Routine routine-name (specific name specific-name ) attempted to access a federated object.", "explanation": "An SQL statement in an external function or method attempted to access one or more federated objects. This statement is executed from routine routine-name (specific name specific-name). It is currently not supported to access a federated object from an external function or method.", "response": "Remove the references to federated objects from the routine. sqlcode :  -20136 sqlstate :  55047", "version": "12.1"}
{"id": "SQL20138N", "message": "The statement may not be explained because the routine routine-name (specific name specific-name ) is not defined as MODIFIES SQL DATA.", "explanation": "The routine routine-name (specific name specific-name ) is defined\n\tas either CONTAINS SQL or READS SQL DATA and attempted to explain an SQL statement.\n\tExplaining an SQL statement requires writing to the explain tables, which is only\n\tpermitted in a MODIFIES SQL DATA routine.", "response": "Do not attempt to explain SQL statements from a routine defined as either CONTAINS\n\tSQL or READS SQL DATA. sqlcode :  -20138 sqlstate :  42985", "version": "12.1"}
{"id": "SQL20139N", "message": "SQL statements may not be issued in routine routine-name (specific name specific-name ) because of a previous statement failed or was interrupted.", "explanation": "During the execution of routine routine-name (specific name specific-name ), or a nested routine, either a statement failed\n\tand requires a roll back or an interrupt occurred.  It is necessary for\n\tall routines invoked from the outer-most statement to finish executing and\n\tfor control to be passed back to the outer-most statement so that the database\n\tmanager may perform the necessary recovery.  Until this recovery has been completed,\n\tSQL statements may not be issued.", "response": "The routine continues to execute.  The routine should not execute any further\n\tSQL statements and should return control to the invoking statement as quickly as possible. The recovery for the initial failure of interrupt will be automatically performed\n\tby the database manager once all routines have completed. sqlcode :  -20139 sqlstate :  51038", "version": "12.1"}
{"id": "SQL20140W", "message": "COMPRESS column attribute ignored because VALUE COMPRESSION is deactivated for the table.", "explanation": "One of the following situations occurred. The COMPRESS SYSTEM DEFAULT specified for the column was ignored because VALUE COMPRESS\n\tis deactivated for the table. DEACTIVATED VALUE COMPRESSION was specified and columns are defined with COMPRESS SYSTEM DEFAULT.", "response": "To allow COMPRESS to be specified for the column, ALTER the table and activate\n\tVALUE COMPRESSION for the table. sqlcode : +20140 sqlstate : 01648", "version": "12.1"}
{"id": "SQL20142N", "message": "Sequence sequence-name cannot be used as specified.", "explanation": "sequence-name was referenced in a context in which it cannot be used. sequence-name is a sequence generated by the system.  It was generated for one of the following purposes: An identity column. The distribution key for a random distribution table using the random by generation method. The system hidden SYSROWID column of a table enabled for row modification tracking. These sequences cannot be referenced in a DROP SEQUENCE, GRANT or REVOKE statement, or in a NEXT VALUE or PREVIOUS VALUE expression.", "response": "Specify the name of a user-defined sequence object in this context. sqlcode :  -20142 sqlstate :  428FB", "version": "12.1"}
{"id": "SQL20143N", "message": "The encryption or decryption function failed, because the ENCRYPTION PASSWORD value is not set.", "explanation": "The ENCRYPTION PASSWORD value is not set.", "response": "Issue the SET ENCRYPTION PASSWORD statement to set the ENCRYPTION PASSWORD value.\n\tThe length of the password must be a minimum of 6 bytes and a maximum of 127 bytes. sqlcode :   -20143 sqlstate :  51039", "version": "12.1"}
{"id": "SQL20144N", "message": "The encryption password is invalid because the length of the specified password was less than 6 bytes or greater than 127 bytes.", "explanation": "The data must be encrypted with a password length between 6 and 127.", "response": "Ensure that the password length is between 6 and 127. sqlcode :   -20144 sqlstate :  428FC", "version": "12.1"}
{"id": "SQL20145N", "message": "The decryption function failed. The password used for decryption does not match the password used to encrypt the data.", "explanation": "The data must be decrypted using the same password that was used to\n\tencrypt the data.", "response": "Ensure that the same password is used to encrypt and decrypt the data. sqlcode :   -20145 sqlstate :  428FD", "version": "12.1"}
{"id": "SQL20146N", "message": "The decryption function failed. The data is not encrypted.", "explanation": "The data must be a result of the ENCRYPT function.", "response": "Ensure that the data type is a result of the ENCRYPT function. sqlcode :   -20146 sqlstate :  428FE", "version": "12.1"}
{"id": "SQL20147N", "message": "The ENCRYPT function failed. Multiple pass encryption is not supported.", "explanation": "Data that has already been encrypted cannot be encrypted again.", "response": "Ensure that the data has not already been encrypted. sqlcode :   -20147 sqlstate :  55048", "version": "12.1"}
{"id": "SQL20148N", "message": "Routine routine-name with specific name specific-name must have the RETURN statement as the last SQL statement of the compound body.", "explanation": "The RETURN statement must be the last SQL statement of the compound body in\n\tan SQL ROW or TABLE function. No other RETURN statement is allowed within the\n\troutine body.", "response": "Ensure there is only one RETURN statement and it is the\n\tlast SQL statement of the compound body. sqlcode :   -20148 sqlstate :  429BD", "version": "12.1"}
{"id": "SQL20149W", "message": "The buffer pool operation has been completed but will not take effect until the next database restart.", "explanation": "The buffer pool has been successfully created or altered, but the changes will not take effect immediately. The changes will take effect when the database is restarted. The changes have been deferred for one of the following reasons: The DEFERRED option was specified. If an alter was specified and the operation changed either NUMBLOCKPAGES or BLOCKSIZE, then the request was deferred because all such alters are always deferred. If an alter was specified, a previous alter of the block based area has not taken effect yet (no database restart has been done), and the new proposed size of the buffer pool is smaller than the current size of the block area of the buffer pool, then the alter must be deferred so that it takes effect when the changes to the block area also come into effect.", "response": "To have the changes take effect at next database restart time, no further action is required. sqlcode : +20149 sqlstate : 01649", "version": "12.1"}
{"id": "SQL20150N", "message": "The statement failed because the number of block pages for a buffer pool is too large for the size of the buffer pool.", "explanation": "You can optimize performance for sequential prefetching by using block-based buffer pools.  When creating or altering a buffer pool, you can specify the number of pages that should exist in the block-based area by using the NUMBLOCKPAGES clause of the CREATE BUFFERPOOL statement or the ALTER BUFFERPOOL statement. The number of pages that are specified to exist in the block-based area must not exceed 98 percent of the total number of pages in the buffer pool.  This message is returned when an attempt is made to configure more than 98 percent of the pages in a block-based buffer pool to exist in the block-based area.", "response": "Respond to this message in one of the following ways: Disable block-based I/O for this buffer pool by setting NUMBLOCKPAGES to zero. Reduce the number of pages specified to exist in the block-based area: Determine the total number of pages for this buffer pool by examining the NPAGES column of the SYSCAT.BUFFERPOOLS catalog view. Specify a value for NUMBLOCKPAGES that is not greater than 98 percent of the total number of pages. sqlcode :  -20150 sqlstate :  54052", "version": "12.1"}
{"id": "SQL20151N", "message": "The value specified for BLOCKSIZE is not in the valid range.", "explanation": "The valid range for the value of BLOCKSIZE is 2 to 256.", "response": "Change the value for BLOCKSIZE to be greater than or equal to 2 and less than or equal to 256.  An optimal value would be the extent size. sqlcode :  -20151 sqlstate :  54053", "version": "12.1"}
{"id": "SQL20152N", "message": "The specified buffer pool is not currently block-based.", "explanation": "The BLOCKSIZE option was used without specifying the number of pages to use in the block area of the buffer pool.", "response": "Specify a value for NUMBLOCKPAGES along with the BLOCKSIZE option. sqlcode :  -20152 sqlstate :  428FF", "version": "12.1"}
{"id": "SQL20153N", "message": "The split image of the database is in the suspended state.", "explanation": "The database split image cannot be used while it is in the suspended state.", "response": "To resume I/O for this database split image, issue one of the following db2inidb commands: db2inidb <db-name> as mirror db2inidb <db-name> as snapshot db2inidb <db-name> as standby In a DB2 pureScale environment, you can issue this command from any member and need to issue the command only once. In a partitioned database environment, you must execute the db2inidb command on each database partition. You can run the command concurrently on each database partition. sqlcode :  -20153 sqlstate :  55040", "version": "12.1"}
{"id": "SQL20154N", "message": "The requested insert or update operation into view view-name is not allowed because no target table can be determined for a row. Reason code = reason-code .", "explanation": "The specified view contains a UNION ALL query. The reason-code indicates that a given row either: does not satisfy the check constraint of any underlying base table, or satisfies all the check constraints for more than one underlying base table. Federated system users: Some other data source specific limitation may be preventing the row from being inserted.", "response": "Ensure that the check constraints used by the underlying base tables to partition their rowsets cover the set of rows to be inserted. Also, ensure that for a view defined with UNION ALL for its fullselect that WITH ROW MOVEMENT is also specified if updates are to move rows from one underlying table to another.  For example, given the check constraints (T1.c1 in (1,2)) on T1, and (T2.c1 in (2,3)) on T2, and view V1 as a union of T1 and T2, the row c1 = 4 does not satisfy the check constraints of either underlying base table and the row c1 = 2 satisfies the check constraints of both underlying base tables. Federated system users: If the reason is unknown, isolate the problem to the data source failing the request and examine the object definition and the update restrictions for that data source. sqlcode :  -20154 sqlstate :  23513", "version": "12.1"}
{"id": "SQL20155N", "message": "Creating or activating the event monitor failed because the specified event monitor target tables are invalid. Reason code: reason-code .", "explanation": "The reason code indicates more specifically what the problem is: 1 At least one column name does not match an event monitor data element identifier. 2 At least one column has a data type that is incompatible with the data type for an event monitor data element identifier. 3 At least one column name matches an event monitor data element identifier, but that element is not allowed in the target table. 4 The row size for the table is too large for the page size of the table space. 5 A mandatory column is missing. 6 The table must not be declared with CCSID UNICODE if the database is not a Unicode database. 7 The table is partitioned. 8 The name of the table specified for storing event monitor output is already in use by another event monitor. 9 An event monitor target table exists for a logical data group that is not supported in the current release. 10 The table is a column-organized table. 11 The table includes an expression-based index.", "response": "Check the administration notification log for detailed information and correct the  table definition. sqlcode :  -20155 sqlstate :  55049", "version": "12.1"}
{"id": "SQL20156W", "message": "The event monitor was activated successfully, however some monitoring information may be lost.", "explanation": "An event monitor activated successfully, however it was determined that the event monitor may lose some information because of one of the following: The data type for a column is smaller than the data type required to hold an event monitor element identifier. This data will be truncated. A target table was found in the SYSCAT.EVENTTABLES, but that table does not exist in the database. All monitor information for the corresponding table will not be recorded. A target table was found in the SYSCAT.EVENTTABLES, but that  table does not reside on all database partitions. Monitor information  on some partitions will not be recorded The buffer size of a statistics event monitor that writes to a file is too small to accommodate the largest record.", "response": "Check the administration notification log for detailed information.If this is a statistics event monitor, check the buffer size; if it is too small, recreate the event monitor with a buffer size of at least 4. For other types of event monitors,  recreate the event monitor to create all target tables if necessary. sqlcode :  +20156 sqlstate :  01651", "version": "12.1"}
{"id": "SQL20157N", "message": "User with authorization ID authorization-ID failed to attach to a quiesced instance, or connect to a quiesced database or a database in a quiesced instance which is in the following quiesce mode: quiesce-mode", "explanation": "The specified authorization ID does not have the authority to attach to a quiesced instance or connect to a database in a quiesced instance when the instance is in QUIESCE RESTRICTED ACCESS mode. To be able to attach to the instance or connect to the database, the authorization ID must satisfy one of the following listed criteria: Hold SYSADM, SYSCTRL, or SYSMAINT authority Be the user that was specified using the USER option of the QUIESCE INSTANCE or START DATABASE MANAGER commands (or db2InstanceQuiesce or db2InstanceStart APIs) Be a member of the group that was specified using the GROUP option of the QUIESCE INSTANCE or START DATABASE MANAGER commands (or db2InstanceQuiesce or db2InstanceStart APIs) In the event the quiesced database is in QUIESCE DATABASE mode, then the authorization ID must satisfy one of the previously listed criteria or hold either the DBADM authority or QUIESCE_CONNECT privilege before the user can successfully connect to a quiesced database. In the event the database in a quiesced instance is in QUIESCE INSTANCE mode, then the authorization ID must satisfy one of the above listed criteria or hold the DBADM authority before the user can successfully connect to a database in a quiesced instance. In the event the instance is in QUIESCE INSTANCE mode, then the authorization ID must satisfy one of the above listed criteria before the user can successfully attach to the quiesced instance.", "response": "You can take one of the following actions to successfully connect to a quiesced database or a database of a quiesced instance, or attach to a quiesced instance: To connect to the database, wait for the database to be unquiesced. To attach to the instance or connect to a database in the instance, wait for the instance to be unquiesced. Retry connecting to the database or attaching to the instance using an authorization ID that has sufficient authority. sqlcode :  -20157 sqlstate :  08004", "version": "12.1"}
{"id": "SQL20158N", "message": "DB2 Data Links Manager is not supported in this DB2 copy version.", "explanation": "The DB2 Data Links Manager is not supported in this DB2 copy version and an attempt was made to perform one of the following actions: Restore a database backup image for a database enabled for Data Links. Upgrade a database which uses the DATALINK data type. Create a database object which uses the DATALINK data type. Database objects that use a DATALINK data type include tables, views, functions, methods, distinct types and structured data types.", "response": "Perform one of the following actions: RESTORE the database backup image in a DB2 copy of a previous release that supports Data Links, disable the use of Data Links, back up the database, and then re-issue the RESTORE DATABASE command using the DB2 copy version to which you want to upgrade the database. Using a DB2 copy of a previous release that supports Data Links, disable the use of Data Links and then re-issue the UPGRADE DATABASE command. Remove all references to the DATALINK data type and then re-issue the statement to create the database object. sqlcode :  -20158 sqlstate :  42997", "version": "12.1"}
{"id": "SQL20159W", "message": "The isolation clause or concurrent-access-resolution clause  is ignored because of the statement context.", "explanation": "The isolation clause or concurrent-access-resolution clause is specified\n\ton a statement that is included in a compound statement that is\n\tprocessed as inline SQL. The clause is ignored. The default isolation\n\tlevel is used for all statements in the compound statement.", "response": "No response required. Remove the isolation clause or\n\tconcurrent-access-resolution to prevent this warning. sqlcode : +20159 sqlstate : 01652", "version": "12.1"}
{"id": "SQL20160W", "message": "The authorizations were granted to USER userid . Groups were not considered because the authorization name is more than 8 bytes.", "explanation": "The authorization name has a length of more than 8 bytes.\n\tThe privilege is granted to the user with authorization\n\tname userid without considering groups\n\tdefined in the system that might have a matching name.\n\tProcessing continues.", "response": "If the grant was intended for a user, no action is required.\n\tIf the grant was intended for a group, consider choosing an\n\talternate group because group names greater than 8 bytes are\n\tnot supported. To avoid this warning message, specify the\n\tUSER keyword before the authorization name. sqlcode : +20160 sqlstate :  01653", "version": "12.1"}
{"id": "SQL20161W", "message": "The column name column-name is not a valid column for an event monitor table.", "explanation": "The column name specified in the INCLUDES or EXCLUDES clause does not match any\n\tvalid column for the event monitor table(s) being created.", "response": "Examine and correct the specified column name. sqlcode :  -20161 sqlstate :  428AA", "version": "12.1"}
{"id": "SQL20165N", "message": "An SQL data change statement within a FROM  clause is not allowed in the context in which it was specified.", "explanation": "An SQL data change  statement can be specified in the FROM clause in specific contexts. The SQL data change statement must be the only table-reference in the FROM clause that is used in: the outer fullselect of a SELECT statement a SELECT INTO statement the outer fullselect of a common table expression the only fullselect in an assignment statement. If any input variables are used in other parts of the query, a multiple row INSERT\n\tin the FROM clause must not include the USING DESCRIPTOR clause.\n\tA multiple row INSERT statement in the FROM clause cannot specify NOT ATOMIC.\n\tA SQL fullselect within an XQuery statement cannot include an\n\tSQL data change statement in the FROM clause.  An SQL fullselect in the default clause of a global variable definition cannot include an SQL data change statement in the FROM clause. The statement cannot be processed.", "response": "Change the statement so that the SQL data change statement within a FROM clause is used  in a supported context and is the only table-reference in the FROM clause. sqlcode :  -20165 sqlstate :  428FL", "version": "12.1"}
{"id": "SQL20166N", "message": "An SQL data change statement within a SELECT specified a view view-name which is not a symmetric view or could not have been defined as a symmetric view.", "explanation": "The target view of the SQL data change statement within a SELECT statement must be defined WITH CASCADED CHECK OPTION or the fullselect in the view definition (or the fullselect of a view definition of a referenced view) must be able to be defined using WITH CASCADED CHECK OPTION. A symmetric view is a view defined implicitly or explicitly with the WITH CASCADED CHECK OPTION. The statement cannot be processed.", "response": "Do not use the SQL data change statement within a SELECT with the specified view. sqlcode :  -20166 sqlstate :  428FM", "version": "12.1"}
{"id": "SQL20167N", "message": "The shared memory set is not large enough to process the request.", "explanation": "There is insufficient memory in a shared memory set for one of the following\n\tresource requests: FCM connection entries FCM message anchors FCM request blocks", "response": "Try the request again. If the error persists, stop and restart the instance to\n\tallow the larger shared memory set size (automatically updated by DB2) to take\n\teffect and try the request again. sqlcode :  -20167 sqlstate :  57011", "version": "12.1"}
{"id": "SQL20168N", "message": "The ALTER BUFFERPOOL statement is currently in progress.", "explanation": "A buffer pool cannot be dropped or altered if an ALTER operation is already in\n\tprogress.", "response": "Wait until the ALTER operation has completed. Use the snapshot monitor to check\n\tthe progress of the ongoing ALTER operation. sqlcode :  -20168 sqlstate :  55051", "version": "12.1"}
{"id": "SQL20169W", "message": "The buffer pool is not started.", "explanation": "The statement was successful, but it will only take effect when the buffer pool\n\tis started.", "response": "The statement has completed successfully, and will take effect when the database\n\tis activated. This happens after all applications disconnect. For the statement\n\tto take effect immediately, re-submit it when the buffer pool is started. To\n\tstart the buffer pool, it is possible in some cases to drop and re-create the\n\tbuffer pool using the IMMEDIATE option. sqlcode :  +20169 sqlstate :  01654", "version": "12.1"}
{"id": "SQL20170N", "message": "There is not enough space in the table space tablespace-name for the specified action. Reason code = reason-code .", "explanation": "Space is being removed from a tablespace using one or more of the DROP, REDUCE, and RESIZE container actions resulting in one of the following scenarios: 1 The amount of space being removed is greater than the amount of space above the high-water mark. 2 The amount of space being removed would result in the tablespace having less\n\tthen the required 5 extents.", "response": "1 Use the snapshot monitor to find the number of useable pages in the tablespace\n\tand the tablespace high-water mark. The difference between these values is the\n\tmaximum number of pages that can be removed. 2 Use the snapshot monitor to find the number of useable pages in the tablespace\n\tand the tablespace extentsize. The number of useable extents in the tablespace is equal to the useable pages divided by the extentsize. There must be at least 5 extents worth of useable pages in the tablespace. sqlcode :  -20170 sqlstate :  57059", "version": "12.1"}
{"id": "SQL20173W", "message": "The event monitor was created successfully but at least one event monitor target table already exists.", "explanation": "While an event monitor was being created, the database manager tried to\n\tcreate one or more target tables but determined that tables with those names\n\talready exist. The event monitor was successfully created and target tables\n\twere not created to replace tables of the same name that already exist. When\n\tthe event monitor is activated, it will attempt to use these tables. Event\n\tmonitor activation may fail if activation processing determines these tables\n\tare not suitable.", "response": "Check the administration notification log for detailed information. If\n\tnecessary, drop all target tables and recreate the event monitor to create\n\tall target tables. sqlcode : +20173 sqlstate : 01655", "version": "12.1"}
{"id": "SQL20178N", "message": "View view-name already has an INSTEAD OF trigger trigger defined.", "explanation": "The view view-name already has an INSTEAD OF trigger defined for\n\tthe indicated operation (UPDATE, DELETE, INSERT). Only one INSTEAD OF\n\ttrigger can be defined for each operation on the view. The statement cannot be processed. The INSTEAD OF trigger was not created.", "response": "If a new INSTEAD OF trigger is required, drop the existing trigger and then\n\tcreate the new trigger. sqlcode : -20178 sqlstate : 428FP", "version": "12.1"}
{"id": "SQL20179N", "message": "An INSTEAD OF trigger cannot be created because of how the view view-name is defined.", "explanation": "An INSTEAD OF trigger cannot be defined on: a view defined using WITH CHECK OPTION a view on which such a view has been defined either directly or indirectly a view on which such a view has been defined either directly or indirectly a view that references an unfenced nickname and the Database Partitioning Feature is enabled An INSTEAD OF UPDATE trigger cannot be defined on: A view nested in a view defined with the WITH ROW MOVEMENT clause The view may be the target view of the INSTEAD OF trigger or it may be a view that depends directly or indirectly on the target view of the trigger. The statement cannot be processed. The INSTEAD OF trigger was not created.", "response": "If the view is defined using WITH CHECK OPTION, remove the WITH CHECK OPTION clause. If the view is nested in a view defined with the WITH ROW MOVEMENT clause, remove the WITH ROW MOVEMENT clause. If the view references an unfenced nickname, specify a different view. sqlcode :  -20179 sqlstate :  428FQ", "version": "12.1"}
{"id": "SQL20180N", "message": "column column-name in table table-name cannot be altered as specified", "explanation": "Column column-name cannot be altered for one of the following reasons: ADD COLUMN cannot be specified on ALTER TABLE if the table is defined as a history table. ALTER COLUMN cannot be specified on ALTER TABLE if the table is defined as a history table. ALTER COLUMN with SET GENERATED cannot be specified on ALTER TABLE for a column of a history table. ALTER COLUMN with SET GENERATED AS cannot be specified on ALTER TABLE for a column that already  is a generated column or has a defined default. DROP COLUMN cannot be specified on ALTER TABLE if the table is defined as a history table. DROP COLUMN with DROP NOT NULL cannot be specified on ALTER TABLE for a column defined as part of a BUSINESS_TIME period. DROP COLUMN with DROP GENERATED cannot be specified on ALTER TABLE for a column defined as row-begin or  row-end on a system-period temporal table. ALTER COLUMN with DROP GENERATED, SET NOT HIDDEN or SET IMPLICITLY HIDDEN cannot be specified on ALTER TABLE for a random distribution key column of a random distribution table using random by generation method The statement cannot be processed.", "response": "Change the name of the column to a column that can be altered or dropped, and recreate the table with the  necessary attributes. sqlcode :  -20180 sqlstate :  428FR", "version": "12.1"}
{"id": "SQL20183N", "message": "The table table-name is not compatible with the specified table partitioning operation.", "explanation": "The partitioning clause for table table-name is not valid because: ADD PARTITION BY was specified on an ALTER TABLE statement CREATE INDEX statement or CREATE TABLE statement, but the table is already a partitioned table. ADD PARTITION, ALTER PARTITION, DROP PARTITION, or DROP DISTRIBUTION was specified on an ALTER TABLE statement, but the table is not a partitioned table, the table is a materialized query table, or a materialized query table is defined on this table. ADD PARTITION for HASH partitions was specified on an ALTER TABLE statement, but the table is not partitioned using hashing. DROP PARTITION of a data partition was specified on the ALTER TABLE statement, but the PRESERVE ROWS clause was used. The PRESERVE ROWS clause is only valid for partitioned tables  that have hash partitioning.", "response": "Change the statement to one that is valid or specify a different table  and reissue the statement. sqlcode :  -20183 sqlstate :  428FT", "version": "12.1"}
{"id": "SQL20188N", "message": "The primary key or a unique key identified by name is a subset of the columns in the ORGANIZE BY clause.", "explanation": "All the columns in a primary or unique key are included in\n\tthe table's ORGANIZE BY clause.  This is not allowed, since each block of\n\tpages in the table would contain just one row, wasting all the rest of\n\tthe space in the block. name is the constraint name, if specified, of the primary key or\n\tunique constraint. If a constraint name was not specified, name is\n\tthe first column name specified in the primary key or unique constraint\n\tclause followed by three periods. If a unique index is being created, name is the name of the unique index. The statement cannot be processed.", "response": "Modify the primary or unique key definition, the unique\n\tindex definition or the ORGANIZE BY clause, if possible, so that the key\n\tis not a subset of the dimensions. sqlcode :  -20188 sqlstate :  429BE", "version": "12.1"}
{"id": "SQL20189W", "message": "The buffer pool operation (CREATE/ALTER) will not take effect until the next database startup due to insufficient memory.", "explanation": "The CREATE or ALTER BUFFERPOOL statement was issued and completed successfully,\n\thowever due to insufficient memory the create/alter was done DEFERRED. The\n\tchanges will take effect on the next database startup.", "response": "If you do not want to wait until the next startup to activate or resize the buffer pool,\n\tyou can free memory resources and try again (with the same or different size).\n\tMemory resources that can be reduced include other buffer pools, the database heap,\n\tthe catalog cache, the package cache, and the utility heap. These can be reduced\n\tusing the ALTER/DROP BUFFERPOOL or UPDATE DATABASE CONFIGURATION command depending\n\ton the resource. In the future, to reserve extra memory for the dynamic allocation\n\tof buffer pool memory, you can increase the DATABASE_MEMORY database configuration\n\tparameter. If you do not try again: If it is an ALTER BUFFERPOOL that failed, you will continue to run with the current\n\truntime size of the buffer pool. You can use the database monitor to see the current\n\truntime size of the buffer pool. If it is a CREATE BUFFERPOOL that failed, any table spaces that are created in the\n\tbuffer pool will temporarily (until next startup) be put in a hidden buffer pool with\n\tthe matching pagesize. Since the hidden buffer pools are small, this can result in\n\tlower than desired performance. To try again: For ALTER BUFFERPOOL, resubmit the command. For CREATE BUFFERPOOL drop the buffer pool and then resubmit the command. sqlcode :  +20189 sqlstate :  01657", "version": "12.1"}
{"id": "SQL20190N", "message": "Federated insert, update, or delete operation cannot be compiled because of potential data inconsistency.", "explanation": "When the data source does not provide application savepoint support\n\tand the server option 'iud_app_svpt_enforce' is set to 'Y', the federated insert,\n\tupdate, or delete operation is blocked during precompile. This will prevent\n\tpotential data inconsistency, which may occur at runtime execution if an error is\n\tencountered in the middle of federated insert, update, or delete processing.", "response": "Possible solutions include: Change server option 'iud_app_svpt_enforce' to 'N'. Apply the insert, update, or delete directly on the data source. sqlcode :  -20190 sqlstate :  0A503", "version": "12.1"}
{"id": "SQL20191N", "message": "For an INOUT parameter in a dynamically prepared CALL statement, the same host variable must be used in both the USING and INTO clauses.", "explanation": "In a CALL statement, an INOUT parameter must correspond to a single host variable. When executing\n\ta dynamically prepared CALL statement, it is necessary to specify the same host variable\n\tin both the USING and INTO clauses of the EXECUTE statement.", "response": "When specifying a host variable that corresponds to a parameter marker for an INOUT parameter,\n\tuse the same host variable in both the USING and INTO clauses of the EXECUTE statement.\n\tWhen using SQLDAs to specify a host variable that corresponds to a parameter marker for\n\tan INOUT parameter, then the SQLDATA pointers of the corresponding SQLVARs must point\n\tto the same host variable. sqlcode :  -20191 sqlstate :  560BB", "version": "12.1"}
{"id": "SQL20192N", "message": "The specified modes are only supported in a partitioned database environment.", "explanation": "Either RECOMMEND PARTITIONINGS or EVALUATE PARTITIONINGS was not invoked in a\n\tpartitioned database environment. These two modes are only supported in a\n\tpartitioned database environment.", "response": "Invoke RECOMMEND PARTITIONINGS or EVALUATE PARTITIONINGS in a partitioned\n\tdatabase environment. sqlcode :  -20192 sqlstate :  56038", "version": "12.1"}
{"id": "SQL20193N", "message": "An error has occurred when accessing the file file-name . Reason code: reason-code .", "explanation": "An attempt was made to access the file file-name on the server but\n\tan error occurred.  For reason codes 4 to 10, file-name may be in the\n\tdirectory specified by the DB2_UTIL_MSGPATH registry variable, or possibly in\n\tthe directory which is the tmp directory of the instance.  The specified error\n\tencountered is indicated by the reason code as follows: 1 File format error. 2 Communication error. 3 Memory allocation error. 4 The directory path indicated by the DB2_UTIL_MSGPATH registry variable does not exist. 5 The file does not exist. 6 The fenced user ID cannot create the file (no execute access to the directory). 7 The fenced user ID cannot read the file (no read access). 8 The fenced user ID cannot write to the file (no write access). 9 Out of disk space (disk full). 10 The file cannot be removed.", "response": "Use the reason code information to determine how to make the file accessible and resubmit the statement. sqlcode :  -20193 sqlstate :  560BC", "version": "12.1"}
{"id": "SQL20194N", "message": "Buffer pool bufferpool-name does not exist on database partition dbpartitionnum .", "explanation": "The ALTER BUFFERPOOL statement is specifying a\n\tbuffer pool, bufferpool-name , that does not exist on the\n\tdatabase partition dbpartitionnum .", "response": "Using the ALTER DATABASE PARTITION GROUP\n\tstatement, add the database partition dbpartitionnum to a\n\tdatabase partition group that has the buffer pool bufferpool-name already defined for it. If the buffer pool\n\tis not associated with any specific database partition group,\n\tthen add the database partition to any database partition group\n\tor create a new database partition group for this database\n\tpartition. Issue the ALTER BUFFERPOOL statement again. sqlcode :  -20194 sqlstate :  53040", "version": "12.1"}
{"id": "SQL20195N", "message": "An error was encountered while processing line number line-number in the path rename configuration file config-file . Reason code = reason-code .", "explanation": "The path rename configuration file config-file is being used to  rename containers during the current crash or rollforward recovery  process. However, while processing the statements in this file, an  error was encountered at line line-number that is preventing the  recovery process from proceeding. An explanation of the error is  indicated by the following reason code: Invalid syntax. The length of the container path exceeds the maximum allowed length for a container path. The container path specified has already been listed on a previous line. The length of the database path exceeds the maximum allowed length for a database path. The database path specified has already been listed on a  previous line. The database path must be an absolute path. The database path is specified incorrectly. The wildcard character (\"*\") is being used incorrectly.", "response": "Make the corresponding change to the configuration file as described in the following instructions, and reissue the command: Correct the syntax error. Specify a shorter container path. Remove the duplicate container path from the file. Specify a shorter database path. Remove the duplicate database path from the file. Use an absolute database path instead of a relative one. Specify the database path in the form of a drive letter followed by a colon (for example C:). If using the wildcard character, it must be the last character in both the old and new paths. sqlcode :  -20195 sqlstate :  08504", "version": "12.1"}
{"id": "SQL20196N", "message": "The one or more built-in types which are returned from the FROM SQL function or method does not match the corresponding built-in types which are parameters of the TO SQL function or method.", "explanation": "The built-in types which are returned by a FROM SQL transform function or method\n\thave to match the types in the parameter list of the corresponding TO SQL transform\n\tfunction or method.", "response": "Choose a different FROM SQL transform function or method or TO SQL transform function\n\tor method or alter either the FROM SQL transform function or method or TO SQL transform\n\tfunction or method to make sure that each built-in type returned from the FROM SQL\n\tfunction or method matches the corresponding built-in type that is a parameter of\n\tthe TO SQL transform function or method. sqlcode :  -20196 sqlstate :  428FU", "version": "12.1"}
{"id": "SQL20197N", "message": "Cannot define method-name as an overriding method. Reason code reason-code .", "explanation": "An attempt was made to define method-name as an overriding method. An overriding relationship\n\tbetween this method and an original method cannot be created because of one of the following\n\treasons, as specified by reason-code : 1 Cannot find an original method with the same name. 2 The original method and the overriding method do not have the same number of parameters. 3 The data type of the parameter of the overriding method does not match\n\tthe data type of the corresponding parameter of the original method. 4 The parameter name of the parameter of the overriding method does not match\n\tthe parameter name of the corresponding parameter of the original method. 5 The locator indication of the parameter of the overriding method does not match\n\tthe locator indication of the corresponding parameter of the original method. 6 The FOR BIT DATA indication of the parameter of the overriding method does not\n\tmatch the FOR BIT DATA indication of the corresponding parameter of the original method. 7 The RETURNS clause of the overriding method contains as AS LOCATOR clause, a CAST FROM clause or a FOR BIT DATA clause. 8 One of the following inherited method attributes is specified: SELF AS RESULT, SQL\n\troutine characteristics, or external routine characteristics. 9 Return type of the overriding method does not match the return type of the original method. 10 The return type of the overriding method is a structured type that is not a subtype of either: the return type of the original method or every return type for all methods that already override the original method.", "response": "Modify the method definition based on the reason specified by the reason-code as follows: 1 Use a method name that identifies an existing method for the supertype of the structured type. 2 Define the same number of parameters for the overriding method as exists for the original method. 3 Change the data type to match the data type of the corresponding parameter of the original method. 4 Change the parameter name to match the name of the corresponding parameter of the original method. 5 Change the locator indication to match the locator indication of the corresponding parameter of the original method. 6 Change the FOR BIT DATA indication to match the FOR BIT DATA indication of the corresponding\n\tparameter of the original method. 7 Remove the AS LOCATOR clause, CAST FROM clause and FOR BIT DATA clause for the overriding method. 8 Remove the SELF AS RESULT method attribute and any SQL routine characteristic or external routine characteristic. 9 Change the return type to match the return type of the original method. 10 Change the return type so that it is a subtype of the original method\n\tand all methods that already override the original method. sqlcode :  -20197 sqlstate :  428FV", "version": "12.1"}
{"id": "SQL20198N", "message": "Method method-name calls itself recursively.", "explanation": "A method attempted to call itself recursively. The recursion might be direct or indirect in nature.", "response": "Modify the method definition. sqlcode :  -20198 sqlstate :  55054", "version": "12.1"}
{"id": "SQL20199N", "message": "The key transform table function used by the index extension of index index-id of table table-id in tbspace-id generated duplicate rows.", "explanation": "The key transform table function specified by the GENERATE USING clause of\n\tthe index extension used by index index-id generated\n\tduplicate rows. For a given invocation of the key transform table function,\n\tno duplicate rows should be produced. This error is occurred when inserting\n\tor updating the key value for the index index-id of table table-id in table space tbspace-id . The statement cannot be processed.", "response": "The code for the key transform table function used by the index extension\n\tof index index-id must be modified to avoid the creation\n\tof duplicate rows. To determine the index name, use the following query: SELECT IID, INDSCHEMA, INDNAME\n\t  FROM SYSCAT.INDEXES AS I,\n\t\t   SYSCAT.TABLES AS T\n\t  WHERE IID = <index-id>\n\t\t  AND TABLEID = <table-id>\n\t\t  AND TBSPACEID = <tbspace-id>\n\t\t  AND T.TBASCHEMA = I.TABSCHEMA\n\t\t  AND T.TABNAME = I.TABNAME Copy to clipboard sqlcode :   -20199 sqlstate :  22526", "version": "12.1"}
{"id": "SQL20200N", "message": "The install or replace of jar-id failed as url could not be located.", "explanation": "The URL specified on the install or replace jar procedure did not identify a valid jar file.", "response": "Reissue the install or replace jar procedure with a URL that identifies a valid jar file. sqlcode :   -20200 sqlstate :  46001", "version": "12.1"}
{"id": "SQL20201N", "message": "The install, replace or remove of jar-id failed as the jar name is invalid.", "explanation": "The jar name specified on the install, replace or remove jar procedure was invalid.  For example, the jar id may be of the improper format, may not exist to be replaced or removed, or can not be installed as it already exists.", "response": "Ensure the jar id is of the correct format.  If the jar id exists, it may need to be removed before it can be installed.  For the remove or replace procedures, ensure the jar id exists. sqlcode :   -20201 sqlstate :  46002", "version": "12.1"}
{"id": "SQL20202N", "message": "The replace or remove of jar-id failed as class is in use by routine routine-name (specific name specific-name ).", "explanation": "The specified class in the jar file is currently in use by a defined procedure, or the replacement jar file does not contain the specified class for which a procedure is defined.", "response": "Ensure all procedures referencing the classes being removed are dropped and resubmit the replace or remove procedure. sqlcode :   -20202 sqlstate :  46003", "version": "12.1"}
{"id": "SQL20203N", "message": "User defined function or procedure function-name has a Java method with an invalid signature.", "explanation": "The signature of the java method used to implement the function or procedure was invalid.  For example, the method may have parameters that are not mappable to the parameters on the corresponding create statement or the method for a procedure may specify a return value.", "response": "Reissue the corresponding CREATE statement specifying parameters that match the Java method, or correct the parameters or return type of the Java method and rebuild the class. sqlcode :   -20203 sqlstate :  46007", "version": "12.1"}
{"id": "SQL20204N", "message": "The user defined function or procedure function-name was unable to map to a single Java method.", "explanation": "The identified function or procedure either failed to find a matching Java method, or found more than 1 matching Java method.", "response": "Correct either the Java method or corresponding create statement so that the function or procedure call resolves to a single Java method. sqlcode :   -20204 sqlstate :  46008", "version": "12.1"}
{"id": "SQL20205N", "message": "The user defined function or procedure function-name has an input argument with a null value that could not be passed to the method.", "explanation": "A function created with \"CALLED ON NULL INPUT\" or procedure has an input parameter with a null value but the Java datatype of this argument does not support null values.  Examples of Java datatypes that do not support null values are BOOLEAN, BYTE, SHORT, INT, LONG or DOUBLE.", "response": "If the method is to be called with null values, ensure the input Java types are capable of accepting a null value.  For functions, the function could also be created with \"RETURNS NULL ON NULL INPUT\". sqlcode :   -20205 sqlstate :  39004", "version": "12.1"}
{"id": "SQL20206W", "message": "The procedure function-name returned too many result sets.", "explanation": "The specified procedure returned more results sets than were specified on the CREATE PROCEDURE statement.", "response": "Modify the procedure to return fewer result sets, or drop and recreate the procedure specifying the correct number of result sets. sqlcode :   +20206 sqlstate :  0100E", "version": "12.1"}
{"id": "SQL20207N", "message": "The install or remove jar procedure for jar-id specified the use of a deployment descriptor.", "explanation": "The DEPLOY or UNDEPLOY parameter of the install or replace jar procedure\n\twas non-zero; this parameter is not supported and must be zero.", "response": "Reissue the procedure with the DEPLOY or UNDEPLOY parameter set to zero. sqlcode :   -20207 sqlstate :  46501", "version": "12.1"}
{"id": "SQL20208N", "message": "The table table-name was not created. Reason code: reason-code .", "explanation": "The table cannot be created because it violates a restriction as indicated by the following reason code: 1 The table that is used to define a staging table is not a materialized query table that was defined with the REFRESH DEFERRED option. 2 The materialized query table that is used to define a staging table already has a staging table associated with it. 3 A materialized query table that references nicknames cannot be created if the CREATE TABLE statement is issued from a non-catalog database partition. 4 A materialized query table that references a protected table, a view that depends  on a protected table, or a nickname on which caching is not allowed cannot be created. 5 A security policy cannot be added to a materialized query table or to a staging table. 6 A materialized query table cannot have more than one DB2SECURITYLABEL column, and that column should not be wrapped in any function. 7 A materialized query table that references protected tables with more than one DB2SECURITYLABEL column cannot be created. 8 If a referred base table has a DB2SECURITYLABEL column, the column must appear in the fullselect of the query. 9 When a table, tableA, is altered to become a materialized query table, if a column in the fullselect of the query is of type DB2SECURITYLABEL, the corresponding column of tableA must also be of type DB2SECURITYLABEL. 10 A staging table cannot be created for a shadow table.", "response": "Respond according to the reason code: 1 Specify a materialized query table that was created with the REFRESH DEFERRED option to define the staging table. 2 Specify a materialized query table that is not associated with a staging table. 3 Issue the CREATE TABLE statement from the catalog database partition. 4 Correct the fullselect that is specified in the CREATE TABLE statement so that it does not violate any of the restrictions that are outlined in the explanation under reason code 4. 5 Remove the SECURITY POLICY clause from the CREATE TABLE statement 6 Reference a protected table that has at most one DB2SECURITYLABEL column and that column should not be wrapped in a function. 7 The materialized query table should have at most one DB2SECURITYLABEL column. 8 Select the same DB2SECURITYLABEL column for the materialized query table as referred to in the base table. 9 To alter a table, tableA, to become a materialized query table, define the fullselect so that any DB2SECURITYLABEL column in the fullselect corresponds to a column in tableA that is of type DB2SECURITYLABEL. 10 No action is required.  A staging table cannot be created on a shadow table. sqlcode :  -20208 sqlstate :  428FG", "version": "12.1"}
{"id": "SQL20209N", "message": "The option-type option is not valid for table table-name with reason code reason-code .", "explanation": "The specified option is not valid as indicated by the following reason codes: 1 The READ ACCESS option cannot be specified on a table that is in the Set Integrity Pending No Access state. 2 The FULL ACCESS option is not valid if the table still has integrity types that are not checked. 3 The FULL ACCESS option is only valid on a table in the Normal No Data Movement state or on a detached table. 4 The FULL ACCESS option cannot be specified with the IMMEDIATE UNCHECKED option if  the table is in the Normal No Data Movement state. 5 The PRUNE option is not valid on a table that is not a staging table. 6 The PRUNE and INCREMENTAL options cannot be specified simultaneously. 7 The ALL option cannot be specified with the IMMEDIATE UNCHECKED option if the table needs integrity checking due to an operation that involved data partitioning. 8 The ALL or GENERATED COLUMN option cannot be specified with the IMMEDIATE UNCHECKED option if the table's database partitioning key, table-partitioning key, multidimensional clustering key, or range-clustering key references a generated column whose expression has been altered through an ALTER TABLE statement. 9 Neither the ALLOW READ ACCESS option nor the ALLOW WRITE ACCESS option can be specified on a table that is to have its identity column values generated for all rows nor on a materialized query table that is to be fully refreshed nor on a table that have been loaded and is to have its generated column or identity column values computed. 10 The ALLOW QUERY OPTIMIZATION USING REFRESH DEFERRED TABLES option can only be specified on a REFRESH DEFERRED materialized query table. 11 The option is not valid on a text-maintained summary table. 12 The option is not valid on a text-maintained staging table. 13 The ALL option cannot be specified with the IMMEDIATE UNCHECKED option when the SET INTEGRITY statement has more than one target table and any one of the target tables is a partitioned table that has both an attached data partition and a nonpartitioned user index. 14 The GENERATE IDENTITY option cannot be specified in a SET INTEGRITY statement if the specified table is a system-period temporal table. 15 The FORCE GENERATED option cannot be specified if the table is a system-period temporal table. 16 The FOR EXCEPTION clause cannot be specified if the table is a system-period temporal table.", "response": "1 Do not specify the READ ACCESS option. 2 Use the FULL ACCESS option with the IMMEDIATE CHECKED option, or specify ALL as the integrity option with the IMMEDIATE UNCHECKED option. 3 Use the FULL ACCESS option with the IMMEDIATE CHECKED option. 4 Use the FULL ACCESS option without the IMMEDIATE UNCHECKED option. 5 Remove the table that is not a staging table from the statement. 6 Specify only one of PRUNE or INCREMENTAL. 7 Instead of specifying the ALL option, specify explicitly those integrity-options that are desired to be unchecked with the IMMEDIATE UNCHECKED option.  Then issue another SET INTEGRITY statement with the IMMEDIATE CHECKED option to check the integrity of data partitioning for the table. 8 Omit the ALL or GENERATED COLUMN option from those integrity-options that are desired to be unchecked with the IMMEDIATE UNCHECKED option.  Then issue another SET INTEGRITY statement with the IMMEDIATE CHECKED and FORCE GENERATED options to recompute the generated column values based on the new expression.   The FORCE GENERATED option can be omitted if the data in the table are guaranteed to satisfy the new generated column expressions. 9 Specify the ALLOW NO ACCESS option on a table. 10 Remove the ALLOW QUERY OPTIMIZATION USING REFRESH DEFERRED TABLES option. 11 Remove the text-maintained summary table from the statement. 12 Remove the text-maintained staging table from the statement or specify the IMMEDIATE CHECKED option. 13 Reissue the SET INTEGRITY statement with a supported combination of options and target table. For example, issue the SET INTEGRITY statement with the ALL and IMMEDIATE UNCHECKED options while specifying only the affected partitioned table as a target; or issue the SET INTEGRITY statement with the IMMEDIATE CHECKED option and multiple target tables instead. 14 Omit the GENERATE IDENTITY option when the NOT INCREMENTAL option is specified for a system-period temporal table. 15 Remove the FORCE GENERATED option if the table is a system-period temporal table. 16 Remove the FOR EXCEPTION clause if the table is system-period temporal table. sqlcode :  -20209 sqlstate :  428FH", "version": "12.1"}
{"id": "SQL20211N", "message": "The specification ORDER BY, OFFSET, or FETCH clause is invalid.", "explanation": "An ORDER BY, OFFSET, or FETCH clause is not allowed in: the outer fullselect of a view the outer fullselect in the RETURN statement of an SQL Table function a materialized query table definition a subselect which is not enclosed in parentheses A FETCH FIRST n ROWS ONLY is not allowed in: the outer fullselect in the RETURN statement of an SQL Table function a materialized query table definition a subselect which is not enclosed in parenthesis", "response": "In case of: subselect Enclose the subselect including the ORDER BY, OFFSET, or FETCH clause in parentheses. OFFSET or FETCH clause Use the ROW_NUMBER() OVER() clause in conjunction with a predicate in the where clause. The following example is equivalent to SELECT NAME FROM emp OFFSET 3 ROWS FETCH NEXT 6 ROWS ONLY: SELECT name FROM\n\t  (SELECT\n\t\t ROW_NUMBER() OVER() AS m, name\n\t\t FROM emp\n\t  ) AS e\n\tWHERE m > 3 AND m < 10 Copy to clipboard Note that LIMIT is an alternative syntax for the FETCH clause. ORDER BY clause Use ORDER BY in the query using the view, the materialized query table, or the SQL table function instead. sqlcode :  -20211 sqlstate :  428FJ", "version": "12.1"}
{"id": "SQL20212N", "message": "User defined routine function-name encountered an exception attempting to load Java class class-name from JAR JAR-name . Original exception underlying-exception .", "explanation": "A ClassNotFoundException has occurred.  The ClassNotFoundException may reference\n\tan original Java exception which further describes why the class wasn't found.\n\tFor example, the underlying exception might be an I/O error that occurred trying\n\tto read a JAR file, or an SQL error occurred reading the JAR from the data dictionary.\n\tAs much of the following tokens that will fit within the SQLCA limits will be returned,\n\tas appropriate. The function-name identifies the specific name of the external Java function or\n\tprocedure whose execution encountered the ClassNotFoundException. The class-name identifies the Java class whose definition could not be found. The JAR-name optionally identifies the installed JAR expected to contain the\n\tidentified class.  '(none)' will  be present unless the external Java function or\n\tprocedure is defined to be in an installed JAR. The underlying-exception optionally contains the toString() of the underlying\n\texception that resulted in this ClassNotFoundException, if any.  '(none)' will be\n\tpresent if there is no underlying exception.", "response": "Execute an ALTER PROCEDURE to specify where the class is to be found, make sure\n\tthe class is in the specified JAR or the system classpath, or correction the\n\tcondition reported by the underlying-exception . sqlcode :  -20212 sqlstate :  46103", "version": "12.1"}
{"id": "SQL20223N", "message": "The encryption or decryption operation failed because the encryption facility is not installed or is not functioning correctly.", "explanation": "You can encrypt data in database tables by using built-in encryption functions.  You can encrypt data in transit between DB2 clients and database servers by using encryption authentication. This message is returned when an attempt is made to encrypt or decrypt data either in storage or in transit, but the encryption facility is not available to service the encryption or decryption request.", "response": "To use the encryption facility, perform the following troubleshooting steps: Verify that the the encryption facility is installed by issuing the db2ls command. If the encryption facility is not installed, install it before using encryption or decryption operations. If the encryption facility is installed but it is not working correctly, uninstall and then reinstall the encryption facility. sqlcode :  -20223 sqlstate :  560BF", "version": "12.1"}
{"id": "SQL20225W", "message": "The buffer pool operation (DROP) will not take effect until the next database startup because the buffer pool is in use.", "explanation": "The DROP BUFFERPOOL statement was issued and completed\n\tsuccessfully, however a table space is still using this buffer pool.\n\tEven though a table space may be reassigned to a different buffer pool,\n\tthe table space reassignment may only take effect on the next database restart.\n\tIf the table space in question is dropped by the time this operation commits,\n\tthen this buffer pool will be removed from memory at that time. Until the\n\tnext database restart, this buffer pool  may remain in memory and a CREATE or\n\tALTER of any other buffer pool that would reuse this buffer pool ID may be deferred.", "response": "Restart the database to delete the buffer pool from memory. sqlcode : 20225 sqlstate : 01657", "version": "12.1"}
{"id": "SQL20227N", "message": "Required clause is missing for argument number of expression .", "explanation": "expression expression requires that a clause be specified for argument number number .\n\tIf expression is XMLATTRIBUTES, then an AS clause is required for the XML attribute name.\n\tIf expression is XMLFOREST, then an AS clause is required for the XML element name.\n\tThe statement cannot be processed.", "response": "Correct the statement by providing the required clause for the argument. sqlcode : -20227 sqlstate : 42633", "version": "12.1"}
{"id": "SQL20230N", "message": "The procedure name may not be specified by a host variable in the CALL statement and the arguments may not be specified with a USING DESCRIPTOR clause.", "explanation": "The procedure name must be specified as an\n\tidentifier in the CALL statement and the arguments must be\n\texplicitly provided. A host variable may not be used for the\n\tprocedure name. The USING DESCRIPTOR clause may not be used\n\tto specify the arguments.", "response": "The CALL statement must be rewritten to provide\n\tan identifier for the procedure name and to explicitly list\n\tthe arguments. If either the procedure name or the arguments\n\tare not known until run time, use a dynamically prepared CALL\n\tstatement. For applications being migrated from a release previous to V8,\n\tthe CALL_RESOLUTION DEFERRED precompile option can be used until\n\tthe applications are rewritten to use the dynamically prepared CALL statement. sqlcode : -20230 sqlstate : 42601", "version": "12.1"}
{"id": "SQL20238N", "message": "The table table-name is defined as CCSID UNICODE and cannot be used in an SQL function or SQL method.", "explanation": "In a non-Unicode database, only tables with the ASCII encoding scheme\n\tmay be referenced inside an SQL function or SQL method. Since the table table-name is defined as CCSID UNICODE, it may not be used in an SQL function or an SQL method.", "response": "Do not use CCSID UNICODE tables in an SQL function or SQL method. sqlcode : -20238 sqlstate : 560C0", "version": "12.1"}
{"id": "SQL20239N", "message": "Tables created in the Unicode encoding scheme cannot be a typed table, or contain graphic types, the XML type, or user-defined types.", "explanation": "In a non-Unicode database, tables created in the Unicode encoding scheme cannot be a typed table and also cannot contain columns defined with any graphic type, the XML type, or user-defined type.", "response": "Remove the CCSID UNICODE clause from the table definition or remove the graphic type, the XML type, or user-defined type from the table definition. sqlcode : -20239 sqlstate : 560C1", "version": "12.1"}
{"id": "SQL20240N", "message": "Invalid specification of a column column-name of type DB2SECURITYLABEL. Reason code: reason-code .", "explanation": "For a column of type DB2SECURITYLABEL the specification of an attribute in a CREATE TABLE or ALTER TABLE statement may be invalid for the following reason. 4 A security label column cannot be defined for a created temporary table or a declared temporary table. 10 A column of type DB2SECURITYLABEL cannot be defined as a generated column.", "response": "Correct the specification of the column of type DB2SECURITYLABEL and resubmit the statement. sqlcode :  -20240 sqlstate :  42963", "version": "12.1"}
{"id": "SQL20241N", "message": "Writing a history file entry for dropped table table-name failed.", "explanation": "Dropped table recovery is enabled on the table space in which the dropped table table-name resides.  When a table space has dropped table recovery enabled, a history file entry is created as part of a table drop.  This history file is contains data which is useful during the recovery of a dropped table.  The writing of the new history file entry for the dropped table failed.  As a result, the table drop could not be completed. A possible cause for such a failure is a full file system where the history file is located.", "response": "Ensure that the history file can be written to by the database manager. If you are not concerned about dropped table recovery, disable this feature and reissue the drop table statement. sqlcode : -20241 sqlstate : 560C2", "version": "12.1"}
{"id": "SQL20242N", "message": "The sample size specified in the TABLESAMPLE clause is not valid.", "explanation": "The sample size specified in the TABLESAMPLE clause must be a positive\n\tnumeric value greater than zero and less than or equal to 100. The statement was not processed.", "response": "Change the sample size specified in the TABLESAMPLE clause to a valid\n\tnumeric value greater than zero and less than or equal to 100. sqlcode : -20242 sqlstate : 2202H", "version": "12.1"}
{"id": "SQL20243N", "message": "The view view-name is the target in the MERGE statement, but is missing the INSTEAD OF trigger for the operation operation.", "explanation": "The view view-name is a direct or indirect target in the MERGE\n\tstatement and has an INSTEAD OF trigger defined for it, but does not have\n\tINSTEAD OF triggers defined for all operations. The trigger for the operation operation is not present.", "response": "Create INSTEAD OF triggers for the UPDATE, DELETE and INSERT operations on\n\tview view-name , or drop all INSTEAD OF triggers for the view. sqlcode :  -20243 sqlstate :  428FZ", "version": "12.1"}
{"id": "SQL20247N", "message": "Table table-name cannot be partitioned and contain a column with data type DATALINK.", "explanation": "An attempt was made to create or alter table table-name in such a way that would create a partitioned table that contained a\n\tcolumn with data type DATALINK.  A table cannot be both partitioned\n\tand contain such a column.", "response": "Create or alter the table to be either partitioned or to include a column\n\tof data type DATALINK, but not both. sqlcode :  -20247 sqlstate : 429BH", "version": "12.1"}
{"id": "SQL20249N", "message": "The statement was not processed because the package named package-name needs to be explicitly rebound.", "explanation": "The package package-name contains a section that must be rebound.", "response": "Explicitly rebind the package using either the REBIND command or the BIND command. To preserve function and data type resolution, specify the RESOLVE CONSERVATIVE option on the REBIND command. sqlcode :  -20249 sqlstate :  560C5", "version": "12.1"}
{"id": "SQL20250N", "message": "The number of data partitions exceeds the number of table spaces for the table.", "explanation": "The partitioned table was defined with NO CYCLE and there are not\n\tenough table spaces defined for the number of specified table partitions. The statement cannot be processed.", "response": "In the CREATE TABLE statement, either specify additional table spaces\n\tfor the table or remove the NO CYCLE specification for the table. sqlcode :  -20250 sqlstate : 428G1", "version": "12.1"}
{"id": "SQL20251N", "message": "The last data partition cannot be detached from the table table-name .", "explanation": "The ALTER TABLE statement would have resulted in the the last\n\tremaining data partition being detached from the table. This operation\n\tis not allowed.  A partitioned table must have at least one data partition\n\twhose status is normal or attached.  A partitioned table cannot have\n\tonly data partitions whose status is detached. To determine the\n\tstatus of partitions, query the catalog view, SYSCAT.DATAPARTITIONS. The statement cannot be processed.", "response": "Ensure that the ALTER TABLE statement leaves at least one data partition\n\tin the table. sqlcode :  -20251 sqlstate : 428G2", "version": "12.1"}
{"id": "SQL20253N", "message": "The BEFORE trigger or generated column name cannot be created, altered, or executed because doing so would cause the table on which the BEFORE trigger or generated column is defined to be delete-connected to at least one ancestor table through multiple relationships with conflicting delete rules. The conflict is between the delete rules of constraints constraint-name1 and constraint-name2 . Reason code = reason-code .", "explanation": "The definition for the BEFORE trigger or generated column name in the CREATE TRIGGER, CREATE TABLE or ALTER TABLE statement is not valid for the reason specified by the reason-code as follows: The execution of the delete rule of constraint constraint-name1 will fire the BEFORE trigger name and the body of this BEFORE trigger modifies a column that is part of the foreign key of constraint constraint-name2 or modifies a column that is referenced by a generated column which is part of the foreign key of constraint constraint-name2 . The execution of the delete rule of constraint constraint-name1 will trigger the update of the generated column name and the generated column itself is part of the foreign key of constraint constraint-name2 . With the addition of the BEFORE trigger or generated column, name , the execution of both constraints constraint-name1 and constraint-name2 would cause an update of the same column. The statement cannot be processed.", "response": "The action corresponding to the reason code is: Change the BEFORE trigger definition so that the BEFORE trigger will not be fired when the delete rule of constraint constraint-name1 is executed, or change the body of the BEFORE trigger so that it does not modify a column that is part of the foreign key of constraint constraint-name2 nor modify a column that is referenced by a generated column which is part of the foreign key of constraint constraint-name2 . Change the generated column expression so that the generated column will not be updated when the delete rule of constraint constraint-name1 is executed or change foreign key of constraint constraint-name2 so that it does not include the generated column. Change the BEFORE trigger definition or generated column expression so that the execution of both constraints constraint-name1 and constraint-name2 would not cause an update of the same column. sqlcode :  -20253 sqlstate :  42915", "version": "12.1"}
{"id": "SQL20254N", "message": "FOREIGN KEY name is not valid since it would cause table table-name to be delete-connected to itself through a cycle that contains a delete rule of either RESTRICT or SET NULL. Reason code = reason-code .", "explanation": "A referential cycle must not contain a delete rule of RESTRICT or SET NULL. The delete rule specified for FOREIGN KEY name in the CREATE TABLE or ALTER TABLE statement is not valid for the reason specified by the reason-code as follows: The delete rule specified is RESTRICT or SET NULL and the referential relationship would cause table table-name to be delete-connected to itself. The delete rule specified is CASCADE but the referential relationship would cause table table-name to be delete-connected to itself by a cycle that contains a delete rule of either RESTRICT or SET NULL. name is the constraint name, if specified, in the FOREIGN KEY clause. If a constraint name was not specified, name is the first column name specified in the column list of the FOREIGN KEY clause followed by three periods. The statement cannot be processed.", "response": "The action corresponding to the reason code is: Change the delete rule to CASCADE or NO ACTION or eliminate the particular FOREIGN KEY clause from the CREATE TABLE or ALTER TABLE statement. Change the delete rule to NO ACTION, RESTRICT, or SET NULL or eliminate the particular FOREIGN KEY clause from the CREATE TABLE or ALTER TABLE statement. sqlcode :  -20254 sqlstate :  42915", "version": "12.1"}
{"id": "SQL20255N", "message": "FOREIGN KEY name is not valid because it would cause a descendent table descendent-table-name to be delete-connected to its ancestor table ancestor-table-name through multiple relationships with conflicting delete rules. The conflict is between the delete rules of constraints constraint-name1 and constraint-name2 on the descendent table. Reason code = reason-code .", "explanation": "The referential constraint definition specified for FOREIGN KEY name in the CREATE TABLE or ALTER TABLE statement is not valid. The reason code indicates more specifcally what the problem is: 1 The relationship is self-referencing and is specified with a delete rule of RESTRICT or SET NULL and the table is a dependent in a relationship with a delete rule of CASCADE. 2 The relationship is specified with a delete rule of CASCADE, and a self-referencing relationship with the delete rule of RESTRICT or SET NULL already exists on the table. 3 The foreign key overlaps with a foreign key of an existing relationship and their delete rules are either not the same or one of them is SET NULL. 4 The relationship is specified with a delete rule of CASCADE which would cause the descendent table to be delete-connected to its ancestor table through multiple relationships where at least two such relationships have overlapping foreign keys and their delete rules are either not the same or one of them is SET NULL. 5 At least one of the conflicting referential constraints is specified with a delete rule of SET NULL and its foreign key definition overlaps with either the partitioning key, or a dimension of an MDC table. 6 The relationship is specified with a delete rule of CASCADE which would cause the descendent table to be delete-connected to its ancestor table through multiple relationships where at least one of the relationships is specified with a delete rule of  SET NULL and its foreign key definition overlaps with either the partitioning key, or a dimension of an MDC table. 7 The new referential constraint definition conflicts with existing referential constraints when BEFORE triggers and generated columns are considered. 8 The new referential constraint will cause another pair of conflicting referential constraints to co-exist in the delete-connected graph when BEFORE trigger and generated columns are considered. name is the constraint name, if specified, in the FOREIGN KEY clause. If a constraint name was not specified, name is the first column name specified in the column list of the FOREIGN KEY clause followed by three periods. The same convention applies to constraint-name1 and constraint-name2 .", "response": "Respond according to the reason code: 1 Change the delete rule to CASCADE or NO ACTION or eliminate the particular FOREIGN KEY clause from the CREATE TABLE or ALTER TABLE statement. 2 Change the delete rule to NO ACTION, RESTRICT, or SET NULL or eliminate the particular FOREIGN KEY clause from the CREATE TABLE or ALTER TABLE statement. 3 Do not specify a column in the foreign key definition that is already contained in the existing foreign key definition or if the delete rule of the existing referential constraint is not SET NULL, change the delete rule of the new constraint to be the same. 4 Change the delete rule to NO ACTION, RESTRICT, or SET NULL or eliminate the particular FOREIGN KEY clause from the CREATE TABLE or ALTER TABLE statement. 5 Do not specify a column in the foreign key definition that is already contained in the existing partitioning key definition or eliminate the particular FOREIGN KEY clause from the CREATE TABLE or ALTER TABLE statement. 6 Change the delete rule to NO ACTION, RESTRICT, or SET NULL or eliminate the particular FOREIGN KEY clause from the CREATE TABLE or ALTER TABLE statement. 7 Change the delete rule to NO ACTION or remove the triggers fired by the referential constraint or do not create the new referential constraint. 8 Change the delete rule to NO ACTION, RESTRICT, or SET NULL or eliminate the particular FOREIGN KEY clause from ALTER TABLE statement. sqlcode :  -20255 sqlstate :  42915", "version": "12.1"}
{"id": "SQL20256N", "message": "FOREIGN KEY name is not valid because it would cause two  tables table-name1 and table-name2 to be delete-connected to each other while they are delete -connected to the same ancestor table ancestor-table-name through CASCADE relationships. Reason  code = reason-code .", "explanation": "When two tables are delete-connected to the same table through CASCADE relationships, the two tables must not be delete-connected to each other where the delete rule of the last relationship in each path is RESTRICT or SET NULL. The delete rule specified in a FOREIGN KEY clause of the CREATE TABLE or ALTER TABLE statement is not valid for the reason specified by the reason-code as follows: The relationship is specified with a delete rule of RESTRICT or SET NULL and would cause the two tables to be delete-connected to each other. The relationship is specified with a delete rule of CASCADE and would cause two tables to be delete-connected to each other where the delete rule of the last relationship in each path is RESTRICT or SET NULL.\n\tThe statement cannot be processed.", "response": "The action corresponding to the reason code is: Change the delete rule to CASCADE or NO ACTION or eliminate the particular FOREIGN KEY clause from the CREATE TABLE or ALTER TABLE statement. Change the delete rule to NO ACTION, RESTRICT, or SET NULL or eliminate the particular FOREIGN KEY clause from the CREATE TABLE or ALTER TABLE statement. sqlcode :  -20256 sqlstate :  42915", "version": "12.1"}
{"id": "SQL20257N", "message": "FINAL TABLE is not valid when the target view viewname of the SQL data change statement in a fullselect has an INSTEAD OF trigger defined.", "explanation": "The fullselect includes an INSERT or UPDATE statement that targets a view that has an INSTEAD OF trigger defined for the SQL data change operation. The FINAL TABLE results of an INSTEAD OF trigger cannot be returned. The statement cannot be processed.", "response": "Change FINAL TABLE to NEW TABLE or drop the INSTEAD OF trigger. sqlcode :   -20257 sqlstate :  428G3", "version": "12.1"}
{"id": "SQL20258N", "message": "Invalid use of INPUT SEQUENCE ordering.", "explanation": "The ORDER BY clause specifies INPUT SEQUENCE and the FROM clause of the fullselect does not specify an INSERT statement. The statement cannot be processed.", "response": "Use INPUT SEQUENCE when the FROM clause of the fullselect specifies an INSERT statement. sqlcode :   -20258 sqlstate :  428G4", "version": "12.1"}
{"id": "SQL20259N", "message": "Column column-name cannot be selected from the target of the data change statement in the FROM clause of the fullselect.", "explanation": "A column has been selected that cannot be specified in the select list of this query. This column is based on a column in a view or fullselect that is the target of an INSERT or UPDATE statement that is specified in a FROM clause using either NEW TABLE or FINAL TABLE. The column selected is based on: A subquery A function that reads or modifies SQL data A function that is deterministic or has external action An OLAP function A next value for a sequence. The statement cannot be processed.", "response": "Change the select list to remove the column. sqlcode :  -20259 sqlstate :  428G6", "version": "12.1"}
{"id": "SQL20260N", "message": "The assignment clause of the UPDATE statement must specify at least one column that is not an INCLUDE column.", "explanation": "The UPDATE statement has specified INCLUDE columns and the only assignments are made to INCLUDE columns.  At least one of the assignments in an UPDATE statement must be to a column of the target of the UPDATE statement. The statement cannot be processed.", "response": "Change the statement to specify an assignment to a column of the target of the UPDATE statement. sqlcode :  -20260 sqlstate :  428G5", "version": "12.1"}
{"id": "SQL20261N", "message": "Invalid row movement to table table-name within the UNION ALL view view-name .", "explanation": "A check-constraint on table table-name caused an updated row to be rejected. When attempting to insert the row into another underlying table of view-name , the table table-name accepted the row. The destination table of a moved row cannot be identical to the table from which it originated. The statement cannot be processed.", "response": "Verify the interaction between before update and before insert triggers on the target table. When performing row movement, DB2 executes before update triggers first, which may modify the row. The rejected row may then be processed by before insert triggers which may again modify the row in a way that it is now accepted by the check constraints of the target table. Change the triggers so that this does not happen. sqlcode :  -20261 sqlstate :  23524", "version": "12.1"}
{"id": "SQL20262N", "message": "Invalid usage of WITH ROW MOVEMENT in view view-name . Reason code = reason-code .", "explanation": "The view view-name has been defined with the WITH ROW MOVEMENT clause. This clause is not applicable for the view because of one of the following: The view's outermost fullselect is not a UNION ALL. The view contains nested UNION ALL operations other than in the outermost fullselect. Not all view columns are updatable. Two columns of the view are based on the same column of the base table. One of the underlying views has an INSTEAD OF UPDATE trigger defined on it. The view contains references to system-period temporal tables or application-period temporal tables. The view cannot be created.", "response": "Depending on the reason code, do the following: Omit the WITH ROW MOVEMENT clause. It is not applicable for views without UNION ALL. Rewrite the view body so that UNION ALL only occurs on the outermost fullselect. Omit columns that are not updatable from the view definition. Rewrite the view body so that each column of a base table is only referenced once in the view definition. Omit the WITH ROW MOVEMENT clause and use an INSTEAD OF UPDATE trigger on the newly defined view. Remove any reference to a system-period temporal table or an application temporal table. sqlcode :  -20262 sqlstate :  429BJ", "version": "12.1"}
{"id": "SQL20263N", "message": "Invalid attempt to update view view-name1 because view view-name2 is defined WITH ROW MOVEMENT.", "explanation": "The attempt to update view-name1 failed because it directly or indirectly contains a UNION ALL operation involving view view-name2 which is defined with the WITH ROW MOVEMENT clause. The statement cannot be executed.", "response": "Drop the view view-name2 and recreate it without the WITH ROW MOVEMENT clause. sqlcode :  -20263 sqlstate :  429BK", "version": "12.1"}
{"id": "SQL20264N", "message": "For table table-name , authorization ID auth-id does not have access-type access to the column column-name .", "explanation": "While accessing the table named table-name , the authorization ID auth-id is attempting access-type access on column column-name .  The authorization ID does not have the LBAC credentials necessary to access the column in that way. If a generated column is being created, LBAC credentials for reading the column are required to include the column in a generation-expression.", "response": "Contact a user who has SECADM authority and ask the user to grant the authorization ID authid LBAC credentials that allow access-type access to the column column-name . sqlcode :  -20264 sqlstate :  42512", "version": "12.1"}
{"id": "SQL20267N", "message": "The function function-name (specific specific-name ) modifies SQL data and is invoked  in an illegal context. Reason code = reason-code .", "explanation": "The function function-name with specific name specific-name is defined with the MODIFIES SQL DATA property. Functions with this property are only allowed as the last table reference in a select-statement, common-table-expression, RETURN statement that is a subselect, SELECT INTO statement, or row-fullselect in a SET statement.  As well, each argument to the table function must be correlated to a table reference in the same FROM clause as the table function, and every table reference must be correlated to by some argument in the table function. An argument is correlated to a table reference when it is a column of that table reference. Reason-code: There are table references following the table function. The table function is not referenced in the outer most subselect. The table function is preceded by a table reference which is not referenced by a function argument. The table function is  used in the body of a view definition. The table function is used in a fullselect within an XQuery context. The table function is referenced by an OUTER JOIN operator or is nested within other explicit joins (using parentheses in a joined-table clause). The function is referenced in the default clause for a global variable or parameter of a procedure definition. The statement cannot be processed.", "response": "Rewrite the query so that the table function is the last table reference in the FROM clause. Move the table function to be in the outermost subselect. Remove the table reference not correlated to in the table function or include an argument in the table function that correlates to the table reference. Remove the table function from the body of the view definition. Remove the table function from the fullselect in the XQuery context. Remove the OUTER JOIN operator or do not place table function in a nested explicit join. Remove the function from the default clause for the global variable or parameter of a procedure definition. For reason codes 1, 2, and 3, the query can be rewritten using a common table expression to isolate the table function invocation.  For example: SELECT c1 FROM\n\t   (SELECT c1 FROM t1, t2,\n\t\t TABLE(tf1(t1.c1) AS tf), t3)\n\t\t  AS x, t4 Copy to clipboard Can be rewritten as: WITH cte1 AS (SELECT c1 FROM t1,\n\t   TABLE(tf1(t1.c1)) AS tf),\n\t   x AS (SELECT c1 FROM t2, cte1, t3)\n\t\t SELECT c1 FROM x, t4; Copy to clipboard sqlcode :  -20267 sqlstate :  429BL", "version": "12.1"}
{"id": "SQL20268N", "message": "Collation cannot be applied. Reason code = reason-code .", "explanation": "The collation cannot be applied for reason code reason-code .\n\tThe reason codes and their meanings are: 1 The result of applying the collation is greater than 32,742 bytes. 2 The collation cannot be applied to the functions LOCATE, POSITION, and POSSTR. 3 The collation cannot be applied to a LIKE predicate or %WLDCRD function. 4 The collation cannot be applied to a FOR BIT DATA string.", "response": "For each reason code: 1 The generated collation key is longer than the source string and\n\tis dependent on the collation selected. Either reduce the length\n\tof the source string, or choose a different collation. 2 Either omit the function or specify a non-UCA collation. 3 Either omit the function or specify a non-UCA collation. 4 Do not use a FOR BIT DATA string. sqlcode :   -20268 sqlstate :  429BM", "version": "12.1"}
{"id": "SQL20269N", "message": "The nickname nickname cannot be referenced in an enforced referential constraint.", "explanation": "A referential constraint in the CREATE TABLE statement or the ALTER TABLE statement is invalid. The constraint definition specifies ENFORCED but refers to a nickname. The statement cannot be processed.", "response": "Change the referential constraint to specify NOT ENFORCED or remove the reference to the nickname. sqlcode :  -20269 sqlstate :  428G7", "version": "12.1"}
{"id": "SQL20271W", "message": "The name at ordinal position number in the statement, with name name , was truncated.", "explanation": "At least one  name in the described statement was truncated. The first  name  that was truncated is identified by the name name and ordinal position number . If performing a describe output of a prepared query, the ordinal position is relative to the select list column of the query. If performing a describe output of a CALL statement, the ordinal position is relative to the OUT or INOUT parameters of the procedure to which the CALL resolved. If performing a describe input of a CALL statement, the ordinal position is relative to the IN or INOUT parameters of the procedure to which the CALL resolved. The column name, parameter name, user defined type name or user defined type schema name was either too long, or became too long after code page conversion. Note that the length of the column name, parameter name, user defined type name, and user defined type schema name are limited when using the SQLDA structure.", "response": "If the exact name or schema is significant, do one of the following: Use a client whose code page does not cause expansion beyond the supported maximum length. For a column name, change the table, view, or nickname so the column has a shorter name. For a parameter name, change the procedure so the parameter has a shorter name. For a user defined type name or user defined type schema name, drop and recreate the user defined type with a shorter name. For a schema name, change the table, view, procedure, or user defined type. sqlcode : +20271 sqlstate : 01665", "version": "12.1"}
{"id": "SQL20273N", "message": "The nickname statistics cannot be updated because the database is not enabled for federation.", "explanation": "An error has been detected at the instance level. The requested operation cannot be completed because federation was not enabled for the instance.", "response": "Set the DBM variable FEDERATED to YES and then restart the database manager. sqlcode :  -20273 sqlstate :  55056", "version": "12.1"}
{"id": "SQL20274W", "message": "Some of the nickname statistics cannot be updated.", "explanation": "Either the database manager cannot execute a query against a nickname to gather the statistics, or the database manager cannot write the results of the updates to the federated database system catalog.", "response": "The nickname statistics update errors are listed in the log file, if a log file path was specified. sqlcode :  +20274 sqlstate :  550C8", "version": "12.1"}
{"id": "SQL20275N", "message": "The XML name xml-name is not valid. Reason code = reason-code .", "explanation": "The statement cannot be processed because it violates a constraint as indicated\n\tby the following reason code: xmlns is used as an attribute name, or prefix for an element or attribute name. The namespace prefix in a qualified name is not declared within its scope. The name for an element or  attribute is not an XML QName. The name of the XML processing instruction is not an XML NCName. The name of the XML processing instruction cannot contain \"xml\" (in any combination of upper or lower case). The name for an argument of XMLTABLE, XMLQUERY or XMLEXISTS expression is not an XML NCName.", "response": "Correct the XML name and resubmit the statement. sqlcode :   -20275 sqlstate :  42634", "version": "12.1"}
{"id": "SQL20276N", "message": "The XML namespace prefix xml-namespace-prefix is not valid. Reason code = reason-code .", "explanation": "The statement cannot be processed because it violates a constraint as indicated\n\tby the following reason code: The namespace prefix is not an XML NCName. xml or xmlns cannot be re-declared as a namespace\n\tprefix. Duplicate namespace prefixes were declared.", "response": "Correct the XML namespace prefix and resubmit the statement. sqlcode :   -20276 sqlstate :  42635", "version": "12.1"}
{"id": "SQL20277W", "message": "Characters were truncated while performing conversion from code page source-code-page to code page target-code-page . The maximum size of the target area was max-len . The source string length was source-len and its hexadecimal representation was string .", "explanation": "During the execution of the SQL statement, a code page conversion operation has resulted in a string that is longer than the maximum size of the target object. Characters were truncated so the result would fit in the target area.", "response": "If the truncation has caused an unexpected consequence, then expand the length of the target column and issue the statement again. sqlcode : +20277 sqlstate : 01004", "version": "12.1"}
{"id": "SQL20278W", "message": "The view viewname may not be used to optimize the processing  of queries.", "explanation": "The fullselect of the view includes elements that prohibit the use of the statistics on the view for optimization when the view is not referenced directly in a query. These elements of the fullselect may include: aggregations functions distinct operations set operations (union, except or intersect). The view is successfully altered to enable query optimization.", "response": "No action is required. If the intent of the view is to optimize queries that do not directly reference the view, then the view could be dropped or have query optimization disabled. You could also consider defining the fullselect of the view to remove the elements that prevent optimization. sqlcode : +20278 sqlstate : 01667", "version": "12.1"}
{"id": "SQL20279N", "message": "The view view-name cannot be enabled for query optimization. Reason code = reason-code .", "explanation": "The view cannot allow the ENABLE QUERY OPTIMIZATION option because the fullselect does not conform to the set of queries that can take advantage of this capability. The statement failed for one of the following reasons: The view directly or indirectly references an existing materialized query. The view is a typed view. The view references a function with external action. The statement cannot be processed.", "response": "The action is based on the reason code as follows: Remove the reference to the materialized query table. There is no way to specify statistics on a typed view. It may be possible to define a similar view that is not a typed view to enable optimization using the statistics. Remove the reference to any function with external action from the view query. sqlcode : -20279 sqlstate : 428G8", "version": "12.1"}
{"id": "SQL20280W", "message": "Insufficient permission to create or write to the log-file-path file.", "explanation": "The statement completed successfully, but the user does not have permission to create or write to the specified log file, log-file-path .", "response": "To write the details to the log file, make sure that you have write access to the log file path specified. Alternatively, omit the optional log file path. sqlcode : -20280 sqlcode : 42501", "version": "12.1"}
{"id": "SQL20282N", "message": ".NET procedure or user-defined function name , specific name specific-name could not load .NET class class . Reason code reason-code .", "explanation": "The .NET class given by the EXTERNAL NAME clause of a CREATE PROCEDURE or CREATE FUNCTION statement could not be loaded. The reason codes are: The assembly of the .NET routine was not found. Class was not found in the assembly specified. A method with types matching those specified in the database catalogs could not be found in the class specified.", "response": "Ensure that correct assembly file is given, including any file extensions. If the full path is not specified, ensure that only one instance of the assembly exists in the system PATH, as the first instance of the assembly found in the PATH will be loaded. Ensure that the assembly was specified correctly as described in response 1. Ensure that the case sensitive class name was specified correctly and that it exists in the specified assembly. Ensure that the class was specified correctly as described in response 2. Ensure that the case sensitive method name was specified correctly, and that it exists in the specified class as a \"public static void\" method. sqlcode : -20282 sqlstate : 42724", "version": "12.1"}
{"id": "SQL20284N", "message": "No plan was possible to create for federated data source server-name . Reason = reason-code .", "explanation": "While building a federated query access plan, the query fragment for one or more data sources cannot be processed because of a missing predicate or a problem with the query syntax as indicated by the following reason code: A required predicate is missing. A predicate that can be processed by the data source is combined with another predicate either using the OR operator or a BETWEEN predicate.", "response": "See the federation documentation for this data source. Correct the query syntax as needed and resubmit the statement. The action corresponding to the reason code is: Supply the missing predicate. Change the statement syntax so that predicates for one data source are separated from predicates for another data source using the AND operator and not the OR operator. sqlcode : -20284 sqlcode : 429BO", "version": "12.1"}
{"id": "SQL20285N", "message": "The statement or command was not processed either because the table named table-name has detached dependent tables or because an asynchronous partition detach operation on the table is not complete. Reason code = reason-code .", "explanation": "You can manage ranges of data by using data partitioning.  The process of detaching a data partition occurs in two phases: The ALTER TABLE...DETACH PARTITION operation logically detaches the data partition from the partitioned table. An asynchronous partition detach task converts the logically detached partition into a stand-alone table. Tables that need to be incrementally maintained with respect to the detached data partition are referred to as detached dependent tables. The specific reason this message was returned is indicated by the value of the runtime token reason-code : 1 The table is the target table of a detach operation and has detached dependents which are required to be incrementally maintained with respect to the current content of this table in order to preserve the integrity of the detached dependents. The statement or command is not allowed because execution of the statement or command would prevent the detached dependents from being incrementally maintained. 2 The table is the target table of a detach operation and is not available because the asynchronous partition detach task has not completed. 3 The table is the source table of a detach operation and has logically detached partitions. The statement or command is not allowed because the asynchronous partition detach task has not completed. 4 The table has detached partitions and there are dependent tables that need to be incrementally maintained with respect to these detached partitions. The statement is not allowed because execution of the statement or command would invalidate the incremental maintenance of the dependent tables.", "response": "Respond to this message according to the reason code: 1 Respond to reason code 1 in one of the following two ways: Maintain the detached dependent tables and then re-issue the statement or command by performing the following steps: Identify the detached dependents of the table by querying the SYSCAT.TABDETACHEDDEP catalog view. Perform integrity processing on the detached dependent tables by issuing the SET INTEGRITY statement with the IMMEDIATE CHECKED option. Re-issue the statement or command. Issue the statement or command without maintaining the detached dependent tables by performing the following steps: Reset the detached property of the table by issuing the SET INTEGRITY statement with the FULL ACCESS option on the table. Re-issue the statement or command. Perform full integrity processing on subsequent SET INTEGRITY statements on the remaining detached dependent tables. 2 Monitor the progress of the asynchronous partition detach task by using the LIST UTILITIES command and wait for the asynchronous partition detach task to complete.  Then re-issue the statement or command. 3 Perform the following steps: Monitor the progress of the asynchronous partition detach task by using the LIST UTILITIES command and wait for the asynchronous partition detach task to complete. Verify that the table does not have any logically detached partitions by querying the SYSCAT.DATAPARTITIONS catalog view Re-issue the statement or command. 4 Perform the following steps: Identify the dependent tables that require incremental maintenance. Perform integrity processing on the dependent tables by issuing the SET INTEGRITY statement with the IMMEDIATE CHECKED option on these dependent tables. Re-issue the statement or command. sqlcode :  -20285 sqlstate :  55057", "version": "12.1"}
{"id": "SQL20287W", "message": "The environment of the specified cached statement is different than the current environment. The current environment will be used to reoptimize the specified SQL statement.", "explanation": "The Explain facility has been invoked to explain a statement that has been\n\tpreviously reoptimized with REOPT ONCE, but the current environment is different than\n\tthe environment in which the cached statement was originally compiled. The\n\tcurrent environment will be used to reoptimize the specified statement. The statement will be processed.", "response": "In order to ensure that the plan matches the plan in the cache, reissue the\n\tEXPLAIN in an environment that matches the one in which the original statement was\n\treoptimized and cached. sqlcode : -20287 sqlstate : 01671", "version": "12.1"}
{"id": "SQL20288N", "message": "Statistics could not be updated for the object. Object name: object-name . Object type: object-type . Reason code: reason-code .", "explanation": "You can collect and update statistics on tables, indexes, and statistical views to provide the optimizer with accurate information for access plan selection by using the RUNSTATS utility. This message is returned when statistics could not be collected.  The reason code indicates the cause of the failure: 1 Collecting statistics is not supported for the target object. 2 An attempt was made to collect statistics for a view, but RUNSTATS options were specified that are not supported with a view. For example, the FOR INDEXES option cannot be specified for views. 3 Updating some statistics of the target object type is not  supported. For example, data page statistics is not applicable for XML paths indexes.", "response": "Respond to this error according to the reason code: 1 Verify that collecting and updating statistics is supported for the specified object.  For example, to enable the collecting and updating of statistics for a view, execute the ALTER VIEW statement specifying the ENABLE QUERY OPTIMIZATION clause. 3 Remove RUNSTATS options that are not supported with a view. 3 Verify that the statistics of the target object type can be updated. sqlcode :  -20288 sqlstate :  428DY", "version": "12.1"}
{"id": "SQL20289N", "message": "Invalid string unit unit in effect for function function-name .", "explanation": "The statement invoked a built-in function using a string unit that is not valid with the type of data that is provided to the function. This can occur for the following reasons: non-string data that is specified with an explicit string length unit unit for the LENGTH function. A string unit cannot be specified for non-string data. bit data or binary data was specified with a string unit other than OCTETS. CODEUNITS16 or CODEUNITS32 are not valid with bit data or binary string data. OCTETS was used with graphic data and the start parameter is not odd or the length parameter is not even. OCTETS was used with graphic data and the start parameter is not odd. OCTETS was used with graphic data and the code-units parameter is not even. OCTETS or CODEUNITS16 was used with a source string argument that is defined as CODEUNITS32. The statement cannot be executed.", "response": "Change the invocation of the function to remove the invalid string length unit or change it to a unit valid for the data type and values being processed. sqlcode :  -20289 sqlstate :  428GC", "version": "12.1"}
{"id": "SQL20290N", "message": "The SQL statement references routine routine-name (specific name specific-name ) which cannot be run on partition partition-number .", "explanation": "The routine routine-name (specific name specific-name ) was called with an invalid partition number partition-number .", "response": "Specify -1 for the partition number parameter to run the routine on the current partition. sqlcode :  -20290 sqlstate :  560CA", "version": "12.1"}
{"id": "SQL20296N", "message": "The ALTER TABLE statement is not allowed as it modifies some physical attribute of the table table-name that has detached partitions and there are dependant tables that need to be incrementally maintained with respect to these detached partitions.", "explanation": "The table has detached partitions and there are dependent tables that need to be incrementally maintained with respect to these detached partitions.  Modifying any physical attribute of the table is not allowed as doing so would invalidate the incremental maintenance of the dependent tables.  The restricted physical attribute modification may include: adding a column, altering a column; or altering one of the following values: data capture, value compression, append, compact, logged, activate not logged initially.", "response": "Identify the dependent tables that require incremental maintenance and issue the SET INTEGRITY statement with the IMMEDIATE CHECKED option on these dependent tables before re-issuing the failing ALTER TABLE statement. The following query can be used to identify the dependent tables that require incremental maintenance, where <schema name> is the qualifier of table-name and <table name> is the table name portion of table-name . WITH\n\tDEP_CNT(TOTAL_DEP) AS (SELECT COUNT(*) FROM\n\t  SYSCAT.TABDEP),\n\tDEP_TAB(SCHEMA, NAME, TYPE, PROPERTY, REFRESH,\n\t  STATUS, CONST_CHECKED, LEVEL) AS\n\t  (SELECT TABLES.TABSCHEMA, TABLES.TABNAME,\n\t\t   TABLES.TYPE, TABLES.PROPERTY,\n\t\t   TABLES.REFRESH, TABLES.STATUS,\n\t\t   TABLES.CONST_CHECKED, 0\n\t   FROM SYSCAT.TABLES TABLES\n\t   WHERE TABLES.TABSCHEMA='<schema name>'\n\t   AND TABLES.TABNAME='<table name>'\n\t\t UNION ALL\n\t   SELECT TABDEP.TABSCHEMA, TABDEP.TABNAME,\n\t\t   TABDEP.DTYPE, TABLES.PROPERTY,\n\t\t   TABLES.REFRESH, TABLES.STATUS,\n\t\t   TABLES.CONST_CHECKED,\n\t\t   DEP_TAB.LEVEL + 1\n\t   FROM SYSCAT.TABDEP TABDEP, DEP_TAB,\n\t\t SYSCAT.TABLES TABLES\n\t   WHERE TABDEP.DTYPE IN ('S', 'V', 'W', 'T')\n\t\t   AND TABDEP.BSCHEMA = DEP_TAB.SCHEMA\n\t\t   AND TABDEP.BNAME = DEP_TAB.NAME\n\t\t   AND TABLES.TABSCHEMA = TABDEP.TABSCHEMA\n\t\t   AND TABLES.TABNAME = TABDEP.TABNAME\n\t\t   AND DEP_TAB.LEVEL < (SELECT\n\t\t\t DEP_CNT.TOTAL_DEP FROM DEP_CNT))\n\tSELECT DISTINCT * FROM\n\t(SELECT DEP_TAB.SCHEMA, DEP_TAB.NAME\n\t FROM DEP_TAB\n\t WHERE STATUS='C'\n\t\t   AND (DEP_TAB.TYPE = 'S'\n\t\t   AND DEP_TAB.REFRESH = 'I'\n\t\t   AND SUBSTR(DEP_TAB.CONST_CHECKED,5,1)<>'F'\n\t\t   OR DEP_TAB.TYPE = 'T'\n\t\t   AND SUBSTR(DEP_TAB.PROPERTY,2,1) = 'Y'\n\t\t   AND SUBSTR(DEP_TAB.CONST_CHECKED,7,1)<>'F')\n\t ) X; Copy to clipboard sqlcode :  -20296 sqlstate :  55057", "version": "12.1"}
{"id": "SQL20302W", "message": "More table spaces than required were specified in the IN or LONG IN clause. The extra table spaces are ignored.", "explanation": "If the table being created is a non-partitioned table, then more than one\n\ttable space is specified in the IN or LONG IN clause.\n\tThe first table space specified is used to store\n\tthe table data or long data. Only one table space should be specified\n\tin the IN or LONG IN clause for a non-partitioned table. If the table being created is a partitioned table, then the number of\n\ttable spaces specified in the IN or LONG IN clause was more\n\tthan the number of partitions defined for the table.\n\tWhen adding partitions to a partitioned table that was created with\n\tthe long data in the same table space as regular data,\n\tthe LONG IN clause provided in the ADD PARTITION clause is ignored. The statement was processed successfully, but the extra table spaces\n\twere ignored.", "response": "None. sqlcode :  +20302 sqlstate : 01675", "version": "12.1"}
{"id": "SQL20303N", "message": "The partitioned unique index was not created because either the index definition did not include all of the partitioning columns, or the index was being created over XML data.", "explanation": "You can create a partitioned index for a partitioned table by specifying the PARTITIONED clause in the CREATE INDEX statement.  When you create a partitioned index for a partitioned table, each data partition is indexed in its own index partition. When you are defining a partitioned unique index, you must include all columns from the table-partitioning key in the index key.  Note that any column that is included in an expression-based index key must also be specified plainly, without being included as part of an expression. This message can be returned for different reasons: An attempt was made to create a partitioned unique index that fails to plainly include one or more of the columns from the table-partitioning key. An attempt was made to create a unique partitioned index over XML data on a partitioned table.", "response": "Submit the CREATE INDEX statement again, specifying all the partitioning columns in the index key. sqlcode :  -20303 sqlstate :  42990", "version": "12.1"}
{"id": "SQL20304N", "message": "The index was not created because of a problem with an XMLPATTERN clause or a column of data type XML. Reason code: reason-code .", "explanation": "This message can be returned when a column defined with a data type of XML is included (or missing) in the columns for the index. The reason code indicates what is invalid about the index definition: 1 There is one column specified that is defined with a data type of XML, but the definition is missing the XMLPATTERN clause to specify the index keys to generate for each XML value. 2 An XMLPATTERN clause is present but there are multiple index columns specified. 3 The index is defined as UNIQUE and the XMLPATTERN includes descendant, descendant-or-self axes, '//', xml-wildcards, node(), or processing-instruction(). 4 An XMLPATTERN clause is present but the single index column specified is not defined with data type XML. 5 The path expression specified in the XMLPATTERN clause does not start with '/' or '//'. 6 The pattern expression does not include a name test or kind test following '/'. 7 The pattern expression uses an unsupported axis in an axis step. Only the following forward axes are supported: child, attribute, descendant, self, and descendant-or-self. 8 The pattern expression specifies an invalid kind test, or some syntax that is not a valid name test or kind test as supported in a pattern expression. 9 The pattern expression specifies a predicate (an expression enclosed in square brackets), but predicates are not supported for pattern expressions in an XMLPATTERN clause. 10 The pattern expression includes other XQuery syntax not supported in an XMLPATTERN clause to which the preceding reason codes do not apply. 11 On a z/OS database server, the number of steps in the pattern expression exceeds the limit of 50 steps when it does not contain a function, or 44 steps when it does contain a function. 12 The argument of a function in the pattern expression does not follow the requirements as specified in the syntax, or the index data type is not correct. 13 The index is defined with at least one part of the index key based on an XMLPATTERN expression.", "response": "Respond to this error according to the reason code: 1 Specify the XMLPATTERN clause. 2 If the index is intended as a key for XML data, ensure that only one column defined with a data type of XML is specified. Otherwise, remove the XMLPATTERN clause. 3 Either remove the UNIQUE specification or change the XMLPATTERN definition to remove descendant, descendant-or-self axes, '//', xml-wildcards, node(), or processing-instruction(). 4 Either remove the XMLPATTERN clause or change the specified column to a single column defined with a data type of XML. 5 Ensure that the pattern expression begins with '/' or '//'. The XQuery syntax for which '/' or '//' is an abbreviation is not supported for the XMLPATTERN clause of the CREATE INDEX statement. 6 Add a name test or a kind test to the pattern expression following '/'. 7 Remove any reverse axes from the pattern expression. For example, the parent axis must not be used in a pattern expression. 8 Check the pattern expression for kind tests or name tests that do not match the syntax specification for the XMLPATTERN clause of the CREATE INDEX statement. Correct or remove unsupported syntax. 9 Remove any predicates from the pattern expression in the XMLPATTERN clause. 10 Change the pattern expression to remove any syntax that is not supported for the XMLPATTERN clause of the CREATE INDEX statement. If the pattern expression includes an asterisk ('*'), ensure that the name tests in the pattern expression correctly use the wildcard. If used with a QName, there must be a colon before or after the wildcard character, otherwise it becomes a multiplication operator. The asterisk cannot be used as a multiplication operator in the pattern expression. You should also ensure that the XMLPATTERN clause does not include any other XQuery operators, XQuery functions or XQuery FLWR expressions (for, let, where, return). 11 Reduce the number of steps in the pattern expression. If the value to be indexed in the XML documents requires more than 50 steps, the index cannot be created. 12 Check the argument of the function in the pattern expression to determine whether it matches the syntax specification of the XMLPATTERN clause of the CREATE INDEX statement, and check the data type of the indexed values. Also, check that the function you specified is supported in the XMLPATTERN clause. Correct or remove unsupported syntax. 13 Modify the index definition in one of the following ways: Remove the XMLPATTERN clause Remove any expression-based keys sqlcode :  -20304 sqlstate :  429BS", "version": "12.1"}
{"id": "SQL20305N", "message": "An XML value cannot be inserted or updated because of an error detected when inserting or updating the index identified by index-id on table table-name .  Reason code = reason-code .  For reason codes related to an XML schema the XML schema identifier = xml-schema-id and XML schema data type = xml-schema-data-type .", "explanation": "The statement cannot proceed and the table and index remain unchanged because of one of the following reason codes. The schema data type and schema identifier are not applicable for all reason codes. See specific reason codes for details. 1 At least one XML node value in an XML value being inserted or updated exceeds a length constraint imposed by the identified index. The index on an  XML column is defined to use the SQL type VARCHAR with a specific length specified. The length of one or more XMLPATTERN result values exceeds the  user-specified length constraint for the VARCHAR data type. 2 On database servers Version 9.5 and earlier, at least one XML node value in an XML value being inserted or updated is a list data type node that cannot be indexed by the identified index. List  data type nodes are not supported in the index. 3 On database servers Version 9.5 and earlier, at least one XML node value is a valid XML value but cannot be cast to the schema data type because it is outside the supported range of values. 4 At least one XML node value is a valid XML value but cannot be cast to the index data type for the identified index because it is outside the supported  range of values. 5 At least one XML node value is an invalid XML value for the target index data type for the identified index and the index definition specifies that  invalid XML values must return an error (REJECT INVALID VALUES).", "response": "Determine the index name and the XML pattern clause. The index name (<index-name>,<index-schema>) can be obtained from SYSCAT.INDEXES by issuing the following query using index-id: SELECT INDNAME,INDSCHEMA\n\t  FROM SYSCAT.INDEXES\n\t  WHERE IID =<index-id> AND\n\t\tTABSCHEMA ='schema ' AND TABNAME ='<table-name>' Copy to clipboard After the index name (<index-name>,<index-schema>) is found, it can be used to obtain the index data type and XML pattern from SYSCAT.INDEXES by issuing the following query: SELECT DATATYPE, PATTERN\n\tFROM SYSCAT.INDEXXMLPATTERNS\n\tWHERE INDSCHEMA = 'index-schema' AND\n\t INDNAME = 'index-name' Copy to clipboard If the <xml-schema-id> is not \"*N\", obtain the name of the XML schema containing the identified schema data type by issuing the following query using <xml-schema-id>: SELECT OBJECTNAME\n\t  FROM SYSCAT.XSROBJECTS\n\t  WHERE OBJECTID = '<xml-schema-id>' Copy to clipboard 1 Use the XML pattern to identify the set of matching XML nodes to determine which string values exceed the length constraint specified by the index. If the XML pattern contains an fn:upper-case function, it is possible that for certain languages the string value after uppercase conversion exceeds the length constraint specified by the index. 2 On database servers Version 9.5 and earlier, use the XML schema name and XML pattern to identify the set of matching XML nodes to inspect and compare against the identified schema data type xml-schema-data-type found in the corresponding schema. Determine which node values are list data type nodes. 3 On database servers Version 9.5 and earlier, use the XML schema name and XML pattern to find the set of matching XML nodes to inspect and compare against the identified schema data type xml-schema-data-type found in the corresponding schema. Determine which node values exceed the supported range of values for the XML schema data type. 4 Use the XML pattern to identify the set of matching XML nodes to inspect and compare against the data type specified for the identified index. Determine which node values exceed the supported range of values for the index data type. 5 Use the XML pattern to identify the set of matching XML nodes to inspect and compare against the data type specified for the index being created. Determine which node values are invalid for the index data type. sqlcode :  -20305 sqlstate :  23525", "version": "12.1"}
{"id": "SQL20306N", "message": "An index on an XML column cannot be created because of an error detected when inserting the XML values into the index. Reason code = reason-code . For reason codes related to an XML schema the XML schema identifier = xml-schema-id and XML schema data type = xml-schema-data-type .", "explanation": "The statement cannot proceed and the table remains unchanged because of one of the following reason codes. The schema data type and schema identifier are not applicable for all reason codes. 1 At least one XML node value in an XML value being inserted exceeds a length constraint imposed by the index that is being created. The index on an XML column is defined to use the SQL type VARCHAR with a specific length specified. The length of one or more XML pattern result values exceeds the user-specified length constraint for the VARCHAR data type. 2 On database servers Version 9.5 and earlier, at least one XML node value in an XML value being inserted into the index during index creation is a list data type node that cannot be indexed by the specified index. List data type nodes are not supported in the index. 3 On database servers Version 9.5 and earlier, at least one XML node value is a valid XML value but cannot be cast to the schema data type because it is outside the supported range of values. 4 At least one XML node value is a valid XML value but cannot be cast to the index data type for the identified index because it is outside the supported range of values. 5 At least one XML node value is an invalid XML value for the target index data type for the identified index and the index definition specifies that invalid XML values must return an error (REJECT INVALID VALUES).", "response": "Determine the XML pattern clause from the index definition. If the <xml-schema-id> is not \"*N\", obtain the name of the XML schema containing the identified schema data type by issuing the following query using <xml-schema-id>: SELECT OBJECTNAME\n\t  FROM SYSCAT.XSROBJECTS\n\t  WHERE OBJECTID = '<xml-schema-id>' Copy to clipboard 1 Use the XML pattern to identify the set of matching XML nodes to determine which string values exceed the length constraint specified by the index. If the XML pattern contains an fn:upper-case function, it is possible that for certain languages the string value after uppercase conversion exceeds the length constraint specified by the index. 2 On database servers Version 9.5 and earlier, use the XML pattern to identify the set of matching XML nodes to inspect and compare against the identified schema data type xml-schema-data-type found in the corresponding schema. Determine which node values are list data type nodes. 3 On database servers Version 9.5 and earlier, use the XML pattern to find the set of matching XML nodes to inspect and compare against the identified schema data type xml-schema-data-type found in the corresponding schema. Determine which node values exceed the supported range of values for the XML schema data type. 4 Use the XML pattern to identify the set of matching XML nodes to inspect and compare against the data type specified for the index. Determine which node values exceed the supported range of values for the index data type. 5 Use the XML pattern to identify the set of matching XML nodes to inspect and compare against the data type specified for the index. Determine which node values are invalid for the index data type. If the index is partitioned and there are newly attached partitions (that is, partitions with the value of 'A' in the STATUS column in the SYSDATAPARTITIONS catalog table), you might not be able to find the invalid node values for the index data type. In this situation, run the SET INTEGRITY statement to bring the newly attached partitions online. The invalid node values might be removed by the SET INTEGRITY statement for violating other constraints, so issue the statement again. If the statement cannot be processed again, then check for invalid node values for the index data type. sqlcode :  -20306 sqlstate :  23526", "version": "12.1"}
{"id": "SQL20307N", "message": "Table source-tablename cannot be attached to table target-tablename . Reason code = reason-code .", "explanation": "The characteristics of the target table do not sufficiently match the characteristics of the source table in the ALTER TABLE...ATTACH  statement. The reason-code indicates the type of mismatch. 1 The number of columns (the COLCOUNT column in SYSCAT.TABLES) of the  source and target table does not match. 2 The compression clauses in the source and target tables do not match. There are two possible mismatches: VALUE COMPRESSION and COMPRESSION SYSTEM DEFAULT do not match; and COMPRESS YES STATIC and COMPRESS YES ADAPTIVE do not match. 3 The APPEND mode of the tables does not match. 4 The code pages of the source and target table do not match. 5 The source table is a partitioned table with more than one data  partition or with ATTACHED or DETACHED data partitions.  A source table that is partitioned can only be attached if it has only one data partition and no ATTACHED or DETACHED data partitions. 6 The source table is a system table, a view, an MQT, a typed table,  a table ORGANIZED BY KEY SEQUENCE, a created temporary table, a declared temporary table, a system-period temporal table, or a history table.  The source table must be a base table that does not correspond to any of the listed tables. 7 The target and source table are the same.  You cannot attach a table to itself. 8 The NOT LOGGED INITIALLY clause was specified  for either the source table or the target table, but not both. 9 The DATA CAPTURE CHANGES clause was specified for either the source  table or the target table, but not both. 10 The distribution clauses of the tables do not match. The distribution key must be the same for the source table and the target table. 11 The ORGANIZE BY DIMENSIONS clauses of the tables do not match. Only one of the tables has an ORGANIZE BY DIMENSIONS clause specified or the organizing dimensions are different. 15 The security protection on the tables is not identical. The tables are protected by different security policies. 16 Compress clause (COMPRESS NO or COMPRESS YES) does not match. 17 The source table does not have an index that is compatible with the index on the target partitioned table. The index on the target table is either unique or defined on an XML column with the REJECT INVALID VALUES clause. 18 The source table does not have an index that is compatible with the index on the partitioned table and the REQUIRE MATCHING INDEXES clause is specified on the ALTER TABLE statement. 19 The record format of the XML column of source table being attached is not compatible with the record format of the target partitioned table. 20 The source table has row access control activated but the target table does not have row access control activated. 21 The source table has column access control activated with at least one enabled column mask but the target table does not have column access control activated. 22 The target table is an application-period temporal table, but the source table is not an application-period temporal table that contains equivalent BUSINESS_TIME period columns. 30 Only one of the source or target table is a random distribution table using the random by generation method. 99 The target table exists in a table space that has been converted to a large table space, and its indexes have not yet been reorganized or rebuilt to support large RIDs.", "response": "Correct the mismatch between the tables by modifying the source table  to match the characteristics of the target table, or by modifying the  target table to match the characteristics of the source table. For reason codes 4, 5, 6 and 11 the characteristics of neither the  source or target table can be easily modified for compatibility. (For reason code 5, source-tablename is partitioned, so it must have exactly one visible (neither attached or detached) data partition.) In cases where it is difficult to modify the characteristics of either  the source or target table for compatibility, create a new  table that is compatible with the target table, and copy the data from source-tablename to this new table. 1 You can add columns to  the table which is missing one or more columns using the statement: ALTER TABLE ...\n\t  ADD COLUMN ...\n\t  DEFAULT ... Copy to clipboard Make sure that the default value of the added column is the same as the default value of the column in the table where the column already exists. Query SYSCAT.COLUMNS.IMPLICITVALUE for  the column in the table where the column already exists. If the value is not NULL, then use the default clause of the ALTER TABLE  ADD COLUMN statement to set the default value to match the value in SYSCAT.COLUMNS.IMPLICITVALUE. Note: You can only add columns after the last existing column of the table. If the missing column is not the last column, create a new source table. Alternatively, you can drop a column from the table that has the extra column: ALTER TABLE ... DROP COLUMN .... Copy to clipboard 2 To achieve agreement between value compression values use one of the  following statements: ALTER TABLE ... ACTIVATE VALUE COMPRESSION Copy to clipboard ALTER TABLE ... DEACTIVATE VALUE\n\t\tCOMPRESSION Copy to clipboard To achieve row compression agreement use one of the following  statements: ALTER TABLE ... COMPRESS YES Copy to clipboard ALTER TABLE ... COMPRESS NO Copy to clipboard To achieve adaptive compression agreement use one of the following statements: ALTER TABLE ... COMPRESS YES ADAPTIVE Copy to clipboard ALTER TABLE ... COMPRESS YES STATIC Copy to clipboard 3 To achieve append mode agreement use one of the following statements: ALTER TABLE ... APPEND ON Copy to clipboard ALTER TABLE ... APPEND OFF Copy to clipboard 4 Create a new source table. 5 Detach data partitions from the source table until there is a single visible data partition using the statement: ALTER TABLE ... DETACH PARTITION Copy to clipboard Include any necessary set integrity statements.  Otherwise, create a new source table. 6 Create a new source table that is not one of the disallowed types. 7 Determine the correct table to use as the source or target table. 8 Either make the table which is not logged initially be logged by issuing the COMMIT statement, or make the table which is logged be  not logged initially by entering the statement: ALTER TABLE .... ACTIVATE NOT LOGGED\n\t\tINITIALLY Copy to clipboard 9 To enable data capture changes on the table that does not have data capture changes turned on, run the statement: ALTER TABLE ... DATA CAPTURE CHANGES Copy to clipboard To disable data capture changes on the table that does have data capture changes turned on, run the statement: ALTER TABLE ... DATA CAPTURE NONE Copy to clipboard 10 It is recommended that you create a new source table in this case, because you cannot change the distribution key of a table spanning multiple database partitions.  To change a distribution key on tables in single-partition database, run the statements: ALTER TABLE ... DROP DISTRIBUTION Copy to clipboard ALTER TABLE ... ADD DISTRIBUTION\n\t\t(key-specification) Copy to clipboard 11 Create a new source table which matches the target table  with respect to the ORGANIZE BY DIMENSIONS clause. 15 The two tables must be protected using the same security policy, have the same column defined as type SYSPROC.DB2SECURITYLABEL, and have the same set of protected columns. 16 Use ALTER TABLE tablename COMPRESS [YES | NO], to ensure that the COMPRESS attributes of the source and target table match. 17 To find the list of indexes on the target partitioned table that do not have a compatible index on the source table, see the administration notification log. Create the unique or XML index on the source table that is compatible with the target partitioned table. 18 Do one of the following: To find the list of indexes on the target table that do not have a compatible index on the source table, see the administration notification log. Create the missing index on the source table and try the request again. Remove the REQUIRE MATCHING INDEXES clause from the ALTER TABLE statement and try the request again. 19 Update the XML record format of the source table to match the record format of the target table. There are several methods you can use to update the XML record format of a table. Either of the following two methods updates the XML record format of a table: Perform an online table move on table using the ADMIN_MOVE_TABLE procedure. Perform the following steps: Use the EXPORT command to create a copy of the table data. Use the TRUNCATE statement to delete all the rows from the table and release the storage allocated to the table. Use the LOAD command to add the data into the table. 20 Ensure the table to attach to has the required access controls or deactivate the access controls on the table being attached. 21 Ensure the table to attach to has the required access controls or deactivate the access controls on the table being attached. 22 Respond to reason code 22 in one of the following ways: If the source table does not have a BUSINESS_TIME period defined, alter the columns in the source that correspond to the BUSINESS_TIME period columns in the target table by using the ALTER TABLE statement with the ADD PERIOD BUSINESS_TIME action on the source table. If the source table has a BUSINESS_TIME period defined, perform the following steps: Remove from the source table the period that does not match the period in the target table by using the ALTER TABLE statement with the DROP PERIOD BUSINESS_TIME action on the source table. Add columns to the source table that correspond to the BUSINESS_TIME period columns ing the target table by using the ALTER TABLE statement with the ADD PERIOD BUSINESS_TIME action on the source table. 30 Ensure that both tables are random distribution tables using the random by generation method. 99 Convert the indexes on the target table to support large RIDs by issuing the command: REORG INDEXES ALL FOR TABLE target-tablename ALLOW NO ACCESS. sqlcode :  -20307 sqlstate :  428GE", "version": "12.1"}
{"id": "SQL20308N", "message": "Parsing with the STRIP WHITESPACE option is not allowed when the input includes a text node string value with only whitespace characters that is more than 1000 bytes long.", "explanation": "The option to STRIP WHITESPACE during XML parsing will fail if a\n\ttext node string value is encountered that consists only of whitespace\n\tcharacters and has a length of more than 1000 bytes. The statement cannot be processed.", "response": "Use the PRESERVE WHITESPACE option or modify the input to remove\n\twhitespace in excess of 1000 bytes from any text nodes with a string\n\tvalue consisting of only whitespace characters. sqlcode :  -20308 sqlstate : 54059", "version": "12.1"}
{"id": "SQL20309N", "message": "Invalid use of an error tolerant nested-table-expression.", "explanation": "An error tolerant nested-table-expression (a nested-table-expression that\n\tspecifies the RETURN DATA UNTIL clause) cannot be referenced in the following\n\tplaces: The fullselect of a materialized-query-definition. The same statement or compound statement that contains an insert, update,\n\tor delete operation. The SELECT statement for a cursor of a positioned DELETE or positioned\n\tUPDATE statement. The statement cannot be processed.", "response": "Remove the RETURN DATA UNTIL clause of the nested-table-expression and\n\tresubmit the statement. sqlcode : -20309 sqlstate :  428GG", "version": "12.1"}
{"id": "SQL20316N", "message": "Invalid compilation environment. Reason code = reason-code .", "explanation": "The compilation environment provided is invalid for the reason specified in the accompanying reason code. The format of the compilation environment provided is not correct. The version of the compilation environment provided is not supported. The size of the compilation environment provided is not valid. The codepage used by the compilation environment provided is not compatible with this database. The statement cannot be executed.", "response": "The action is based on the reason codes as follows: Acquire the compilation environment again and ensure that it is not altered in any fashion prior to use. Acquire the compilation environment again using a compatible level of software. Acquire the compilation environment again and ensure that it is not altered in any fashion prior to use. Acquire the compilation environment again using a database with the same codepage as this one. sqlcode :   -20316 sqlstate :  51040", "version": "12.1"}
{"id": "SQL20317N", "message": "The command or statement failed because the operation is only supported when there is at least one storage group defined for the database against which the command or statement was executed.", "explanation": "Automatic storage simplifies storage management for table spaces. When you create a storage group, you specify the storage paths where the database manager will place your data. After a storage group is created in a database, there is always a default storage group for the database. As you create and populate automatic storage table spaces, the database manager will manage the container and space allocation for those automatic storage table spaces to use the default or specified storage group. This message is returned when an attempt is made to perform an action that require a storage group against a database that has no storage groups defined, such as the following examples: Creating an automatic storage table space Altering a table space to use automatic storage Using automatic storage for a restore operation by running the SET TABLESPACE CONTAINERS command with the USING AUTOMATIC STORAGE clause Dropping storage paths from the database", "response": "To use automatic storage functionality with this database, create at least one storage group. sqlcode :  -20317 sqlstate :  55060", "version": "12.1"}
{"id": "SQL20318N", "message": "The ALTER TABLESPACE statement failed because the change is not allowed for the type of table space. Table space name: tablespace-name . Table space type: tablespace-type . Incompatible clause: clause .", "explanation": "The following are operations that are incompatible with a corresponding table space type, as indicated. A table space defined as MANAGED BY AUTOMATIC STORAGE has its containers managed by the database manager. This means that the database manager will automatically extend existing containers or create new containers based on the storage paths defined for the storage group with which the table space is associated. Containers for table space defined as MANAGED BY AUTOMATIC STORAGE cannot be altered by the ALTER TABLESPACE statement. The INHERIT option cannot be specified for the DATA TAG, OVERHEAD, or TRANSFERRATE clauses with DMS or SMS table spaces The clause 'USING STOGROUP' cannot be used with DMS or SMS table spaces STOGROUP cannot be changed for temporary automatic storage table spaces DATA TAG cannot be set for a temporary table space or a system catalog table space", "response": "Rewrite the ALTER TABLESPACE statement to ensure that the operations are compatible with the table space type. sqlcode :  -20318 sqlstate :  42858", "version": "12.1"}
{"id": "SQL20319N", "message": "The SET TABLESPACE CONTAINERS command is not allowed on an automatic storage table space.", "explanation": "Containers associated with automatic storage table spaces are\n\tunder the control of the database and cannot be redefined via\n\tthe SET TABLESPACE CONTAINERS command.", "response": "To specify a new set of paths for all automatic storage table\n\tspaces in the database, use the ON option of the RESTORE DATABASE\n\tcommand and specify one or more paths. sqlcode :  -20319 sqlstate :  55061", "version": "12.1"}
{"id": "SQL20320N", "message": "The maximum size specified for the table space is not valid.", "explanation": "The maximum size specified in the CREATE TABLESPACE or ALTER TABLESPACE statement is not valid.  If creating the table space, the maximum size must be greater than or equal to the initial size specified.  If altering an existing table space, the maximum size must be greater than or equal to the current size of the table space.", "response": "Specify a larger value for the maximum size as described in this message's Explanation. sqlcode :  -20320 sqlstate :  560B0", "version": "12.1"}
{"id": "SQL20321N", "message": "The command failed because storage paths cannot be provided when there are no storage groups in the database.", "explanation": "The database in the backup image does not define a storage group but storage paths are being provided in one of the following ways: Storage paths are being included in a call to the RESTORE DATABASE API. Storage paths are being specified with the ON option of the RESTORE DATABASE command. Storage paths are being specified with the SET STOGROUP PATHS command. For versions of DB2 database prior to Version 10: Prior to Version 10, a database in the backup image had to be defined to use automatic storage in order to specify storage paths. This message is returned by database servers prior to Version 10 when an attempt is made to perform an action that requires automatic storage in a database backup image that has not been enabled for automatic storage.", "response": "Resolve the problem using the appropriate action: Do not include any storage paths when calling the RESTORE DATABASE API. Do not specify the ON option of the RESTORE DATABASE command. Do not specify the SET STOGROUP PATHS command. sqlcode :  -20321 sqlstate :  55062", "version": "12.1"}
{"id": "SQL20322N", "message": "The database name provided does not match server-name , the name of the database that the application is connected to.", "explanation": "The database name does not match server-name , the name of the\n\tdatabase that the application is currently connected to. The database name\n\twas either explicitly specified or determined by the specified database\n\talias name.", "response": "If the intention is to alter the database that you are currently\n\tconnected to, either remove the database name from the statement\n\tor specify the correct name.  If the intention is to alter the\n\tdatabase with the given name, and not the database you are\n\tcurrently connected to, disconnect from the current database and\n\tconnect to the specified database before resubmitting the\n\tstatement.  If you are backing up or restoring a database, connect\n\tto that database and provide the correct database name or database\n\talias name. sqlcode :  -20322 sqlstate :  42961", "version": "12.1"}
{"id": "SQL20323N", "message": "The storage path storage-path already exists for the storage group or is specified more than once.", "explanation": "Either a storage path being added already exists for the storage group, or there are duplicates within the list being provided.", "response": "Remove the path from the command or statement and resubmit the command or statement. sqlcode :  -20323 sqlstate :  42748", "version": "12.1"}
{"id": "SQL20324N", "message": "The operation operation is already in progress.", "explanation": "The operation operation has already been issued in this transaction or it has\n\tbeen issued as part of a separate uncommitted transaction.", "response": "Commit the transaction with the outstanding operation and reissue the statement. sqlcode :  -20324 sqlstate :  25502", "version": "12.1"}
{"id": "SQL20325N", "message": "Adding, extending, or setting containers for table space tablespace-name would exceed the maximum size max-size .", "explanation": "Table space tablespace-name has AUTORESIZE set to YES with a defined maximum size.  However, the amount of space being added to the table space by the ALTER TABLESPACE statement or set by the SET TABLESPACE CONTAINERS command is resulting in the size of the table space being greater than this maximum size.", "response": "If executing an ALTER TABLESPACE statement then before resubmitting the statement, increase MAXSIZE for the table space such that it is greater than or equal to the current size of the table space plus the amount of space being added.  Alternately, set AUTORESIZE to NO for the table space.  Note that disabling auto-resize will result in the current values of MAXSIZE and INCREASESIZE being lost. If executing the SET TABLESPACE CONTAINERS command then specify a set of containers that has a total size less than or equal to the maximum size of the table space. sqlcode :  -20325 sqlstate :  54047", "version": "12.1"}
{"id": "SQL20326N", "message": "An XML element name, attribute name, namespace prefix or URI ending with string exceeds the limit of 1000 bytes.", "explanation": "The system is processing an element name, attribute name, namespace prefix\n\tor a URI to generate an internal identifier for the string. The length of\n\tthe string exceeds the limit of 1000 bytes for the string when represented\n\tin UTF8. The value of string gives the ending characters of the string\n\tthat exceeded the limit. The statement cannot be processed.", "response": "Try to use shorter element names, attribute names, namespace prefixes or\n\tURIs and then try the operation again. sqlcode :  -20326 sqlstate : 54057", "version": "12.1"}
{"id": "SQL20327N", "message": "The internal representation of an XML path exceeds the limit of 125 levels.", "explanation": "The system is generating an internal representation of an XML path. The\n\tpath may exist in an XML document that is being parsed or validated or in\n\tan XML value that is being constructed. The limit is reached because the document\n\tis nested too deep. The statement cannot be processed.", "response": "For a document or constructed XML value, reduce the number of levels of\n\telements and attributes that are used. sqlcode :  -20327 sqlstate : 54058", "version": "12.1"}
{"id": "SQL20328N", "message": "The document with target namespace namespace and schema location location already has been added for the XML schema identified by schema-name .", "explanation": "This error can occur while invoking the XSR_ADDSCHEMADOC stored procedure.\n\tWithin an XML schema, there cannot be two documents with the same\n\ttargetnamespace and schemalocation. The statement cannot be processed.", "response": "Change either the namespace or schemalocation of the document that\n\tis being added. sqlcode :  -20328 sqlstate : 42749", "version": "12.1"}
{"id": "SQL20329N", "message": "The completion check for the XML schema failed because one or more XML schema documents is missing. One missing XML schema document is identified by uri-type as uri .", "explanation": "The XML schema registration completion processing determined that more\n\tthan one XML schema document is required for a complete XML schema and at\n\tleast one XML schema document is missing from the XML schema repository.\n\tThe missing XML schema document is identified by the either targetnamespace\n\tor schemalocation uri-type and the value for the namespace or XML schema\n\tlocation uri . The reference to the missing XML schema document may be\n\tincluded in one of the XML schema documents that is defined for the XML schema. The statement cannot be processed.", "response": "Add any missing XML schema documents for the XML schema to the XML schema\n\trepository. The document identified by uri-type as uri must be added. sqlcode :  -20329 sqlstate : 428GI", "version": "12.1"}
{"id": "SQL20330N", "message": "The xsrobject-type identified by the XML uri-type1 uri1 and XML uri-type2 uri2 is not found in the XML schema repository.", "explanation": "Processing of the statement or command required the use of an XSROBJECT from the XML schema respository that could not be found. If the xsrobject-type is XMLSCHEMA, then an XML schema is required for validation of an XML value. The uri-type1 is NAMESPACE and the XML schema target namespace uri1 may have been identified explicitly in the statement using the ACCORDING TO XMLSCHEMA URI clause or may be identified in the XML value. If the optional LOCATION clause is also specified, then uri-type2 is LOCATION and uri2 indicates this value, otherwise it is an empty string. If the xsrobject-type is EXTERNAL ENTITY, then an XML external entity is required for parsing or validation of an XML value. The identification of the external entity is based on uri-type1 of SYSTEM ID with the system identifier as uri1 and uri-type2 of PUBLIC ID with the public identifier as uri2 . If uri2 is empty, then no public identifier was available. The statement or command cannot be processed.", "response": "Register the XML schema or XML external entity identified by uri1 and uri2 before processing the XML value. sqlcode :  -20330 sqlstate :  22532, 4274A", "version": "12.1"}
{"id": "SQL20331N", "message": "The XML comment value string is not valid.", "explanation": "The XML comment cannot contain two adjacent hyphens and cannot end in a\n\thyphen.", "response": "Ensure the value for the XML comment is valid. sqlcode :  -20331 sqlstate : 2200S", "version": "12.1"}
{"id": "SQL20332N", "message": "The XML processing instruction value string is not valid.", "explanation": "The XML processing instruction must not contain the substring '?>'.", "response": "Ensure the value for the XML processing instruction is valid. sqlcode :  -20332 sqlstate : 2200T", "version": "12.1"}
{"id": "SQL20333N", "message": "The operation could not be performed because it violated an integrity constraint at data source data-source . Associated text and tokens are tokens .", "explanation": "The insert, update, or delete operation violated an integrity constraint defined at a federated data source. The violation could be due to the interaction of a trigger at the data source. The statement could not be executed. The contents of the object table are unchanged. Some data sources do not provide specific information about the constraint that was violated. Other data sources provide more information in the db2diag log file.", "response": "Examine the constraints on the object referenced by the operation to determine the cause of the violation. Look in the db2diag log file for more information about the constraint that was violated. sqlcode :  -20333 sqlstate :  23527", "version": "12.1"}
{"id": "SQL20334N", "message": "A SOAP Fault was received from the web services data source tokens .  Associated text and tokens are text-and-tokens .", "explanation": "The web services data source data-source-name that is using the\n\tSimple Object Access Protocol (SOAP) sent a SOAP Fault to the federated server.\n\tFurther information about this error situation is in tokens .", "response": "Use the information provided in tokens to identify and correct\n\tthe root cause of the SOAP Fault at the data source, data-source-name . sqlcode : -20334 sqlstate : 560CB", "version": "12.1"}
{"id": "SQL20335N", "message": "More than one xsrobject-type exists identified by XML uri-type1 uri1 and uri-type2 uri2 exists in the XML schema repository.", "explanation": "There is more than one registered XSROBJECT that matches the URI used to identify an XML schema or external entity. If xsrobject-type is XMLSCHEMA, then identification for the XML schema is based on uri-type1 of NAMESPACE with the XML schema target namespace as uri1 and uri-type2 of LOCATION with XML schema location as uri2 . If ui2 is empty, then no schema location was specified. If xsrobject-type is EXTERNAL ENTITY, then identification for the external entity is based on uri-type1 of SYSTEM ID with the system identifier as uri1 and uri-type2 of PUBLIC ID with the public identifier as uri2 . If uri2 is empty, then no public identifier was specified. The statement cannot be processed.", "response": "If both uri1 and uri2 are indicated, then either drop duplicate XSROBJECTs of type xsrobject-type from the XML schema repository or, for XML schemas, explicitly specify the XMLSCHEMA ID for one of these XML schemas. If the schema location ( uri2 ) is empty, it may also be possible to explictly specify XMLSCHEMA URI and LOCATION to uniquely identify an XML schema. sqlcode :  -20335 sqlstate :  22533, 4274B", "version": "12.1"}
{"id": "SQL20336N", "message": "A value with data type source-data-type cannot be XMLCAST to type target-data-type .", "explanation": "The statement contains a CAST with the first operand having a data type of source-data-type to be cast to the data type target-data-type . This cast is not supported.", "response": "Change the data type of either the source or target so that the cast is supported. For predefined data types these are documented in the SQL Reference. For a cast involving a user-defined distinct type, the cast can be between the base data type and the user-defined distinct type or from a data type that is promotable to the base data type to the user-defined distinct type. sqlcode :  -20336 sqlstate : 42846", "version": "12.1"}
{"id": "SQL20337N", "message": "The BY REF clause is missing or used incorrectly.  Reason code= reason-code .", "explanation": "The following explain the error based on possible values for reason-code . The BY REF clause cannot be specified when the corresponding data type is other than XML for an argument of a XMLQUERY, XMLEXISTS, or XMLTABLE function. This error may also occur when the BY REF clause is issued within an XMLTABLE column definition and the type of the column is not XML. The BY REF clause must be specified when XMLTABLE clause defines a column with data type XML. The BY REF clause must be specified in an XMLQUERY function that returns an XML sequence. The BY REF clause can be specified explicitly following the RETURNING SEQUENCE clause or in the PASSING clause.", "response": "Take the following action based on the reason-code . Remove the BY REF clause where it is associated with a data type other than XML. Specify the BY REF clause where the data type argument of an XMLTABLE function is XML. Specify the BY REF clause following the RETURNING SEQUENCE keywords or specify a PASSING BY REF clause. sqlcode :  -20337 sqlstate : 42636", "version": "12.1"}
{"id": "SQL20338N", "message": "The data type of either the source or target operand of an XMLCAST specification must be XML.", "explanation": "The XMLCAST specification must have one operand that has the data type XML. The XMLCAST operation can be from an XML type value to an SQL type value or from an SQL type value to and XML type value. The XMLCAST specification also accepts having both the source and target operands as XML but no actual casting operation is performed in this case.", "response": "If both operands are SQL data types other than XML, use the CAST specification. Otherwise, change the XMLCAST specification so that at least one operand is the XML data type. sqlcode :  -20338 sqlstate : 42815", "version": "12.1"}
{"id": "SQL20339N", "message": "The XML schema xmlschema-name is not in the correct state to perform operation operation .", "explanation": "The operation specified by operation cannot be performed on the XML schema\n\tidentified by the XML schema identifier xmlschema-name because it is not in the\n\tcorrect state. For example, the XML schema has already been completed and the operation\n\tis attempting to add additional XML schema documents. The statement cannot be processed.", "response": "Check the current state of the XML schema to determine the operations that\n\tare valid for the XML schema.\n\tIf the XML schema is completed, no further XML schema documents can be added. sqlcode :  -20339 sqlstate : 55063", "version": "12.1"}
{"id": "SQL20340N", "message": "The XML schema xmlschema-name includes at least one XML schema document in namespace namespace with component ID component-id that is not connected to the other XML schema documents in the same namespace using an include or redefine.", "explanation": "The XML schema identified by identifier xmlschema-name includes\n\tmultiple XML schema documents in the namespace namespace .\n\tAt least one of these XML schema documents is not connected to the other\n\tXML schema documents in the same namespace using an include or redefine.\n\tOne such XML schema document is identified in the XML schema repository\n\twith component identifier component-id . The statement cannot be processed.", "response": "Correct the XML schema documents so that all XML schema documents\n\twithin a namespace are connected using an include or a redefine.\n\tThe component-id can be used to query SYSCAT.XSROBJECTCOMPONENTS\n\tfor further information about the specifically reference XML schema\n\tdocument that is not connected within the namespace. sqlcode :  -20340 sqlstate : 22534", "version": "12.1"}
{"id": "SQL20341W", "message": "Transfer operation ignored since auth-ID is already the owner of the database object.", "explanation": "The TRANSFER statement specified to transfer the database object to authorization ID auth-ID . The authorization ID is already the owner of the database object. There is no need to transfer the database object.", "response": "No action is required. sqlcode :  +20341 sqlstate : 01676", "version": "12.1"}
{"id": "SQL20342N", "message": "auth-ID does not have one or more required privileges privilege-list on object object-name of type object-type necessary for ownership of the object.", "explanation": "The TRANSFER statement attempted to transfer ownership of the object to authorization ID auth-ID which does not have the necessary privileges to be the owner of the object. The privileges privilege-list on the object object-name are the privileges that are missing. The statement cannot be processed.", "response": "Grant the authorization ID auth-ID all the privileges necessary, as indicated by privilege-list , on object object-name , for the authorization ID to be the owner of the object being transferred. sqlcode :  -20342 sqlstate : 42514", "version": "12.1"}
{"id": "SQL20344N", "message": "Transferring ownership of object-name1 failed because of a dependency involving object-name2 . Reason code: reason-code .", "explanation": "When an object is created, one authorization ID is assigned ownership of the object.  Ownership means the user is authorized to reference the object in any applicable SQL or XQuery statement.  You can transfer ownership of a database object by using the TRANSFER OWNERSHIP statement. This message is returned when an attempt to transfer the ownership of an object fails.  The reason code indicates the specifics of the failure: 1 The table object-name1 in table hierarchy object-name2 cannot be transferred because the table is a subtable. 2 The view object-name1 in view hierarchy object-name2 cannot be transferred because the view is a subview. 3 The index object-name1 cannot be transferred because the table that the index is defined on, object-name2 , is a declared global temporary table. 4 The method body or function object-name1 cannot be transferred because the method body or function was implicitly generated when user-defined type object-name2 was created. 5 The package object-name1 cannot be transferred because an SQL routine, a trigger, or an index object-name2 depends on the package. 6 The event monitor object-name1 cannot be transferred because the event monitor is active. 7 The transfer of the view object-name1 failed because the view is  a system-generated statistical view for the expression-based index named object-name2 .", "response": "Respond to this message according to the reason code: 1 Transfer the whole table hierarchy. 2 Transfer the whole view hierarchy. 3 Drop the declared global temporary table. 4 Drop the type that created this method or function. 5 Transfer the SQL procedure. 6 Set the event monitor state to inactive. 7 Transfer the ownership of the expression-based index. sqlcode :  -20344 sqlstate :  429BT", "version": "12.1"}
{"id": "SQL20345N", "message": "The XML value is not a well-formed document with a single root element.", "explanation": "The XML value is not a well-formed document. An XML value that is being\n\tstored in a table or validated must be a well-formed XML document with a single\n\troot element. The document node of the XML value must not have any text node children, although it can have comment node or processing instruction node children. The statement cannot be processed.", "response": "Storing or validating the XML value requires that the XML value be modified so that it is a well-formed document with a single root element. If the document is well-formed, ensure that the document node of the XML value has only a single element node as a child and no text node child. Otherwise, do not attempt store or validate the XML value. sqlcode :  -20345 sqlstate : 2200L", "version": "12.1"}
{"id": "SQL20346N", "message": "The XML schema xmlschema-id does not contain a global element named element-local-name in namespace namespace-uri .", "explanation": "A validation operation specified that an explicit element local name element-local-name in namespace namespace-uri should be the\n\troot element of the XML document to be validated. However, the XML schema\n\twith SQL identifier xmlschema-id does not have element-local-name declared as a global element in namespace namespace-uri . The statement cannot be processed.", "response": "Check that the element local name element-local-name in namespace namespace-uri is correct for the XML schema and the XML document that\n\tis being validated. Change the element local name, namespace or the XML schema\n\tand try the validation again. sqlcode :  -20346 sqlstate : 22535", "version": "12.1"}
{"id": "SQL20347N", "message": "The XML value does not contain a root element named element-local-name in namespace namespace-uri .", "explanation": "The root element of the XML document does not match the required element\n\tlocal name element-local-name in namespace namespace-uri specified\n\tfor validation. The statement cannot be processed.", "response": "Provide an XML value where the root element matches with the specified\n\telement local name and namespace. If the XML value is correct, change the\n\tspecified element local name or namespace. sqlcode :  -20347 sqlstate : 22536", "version": "12.1"}
{"id": "SQL20349N", "message": "The user mappings from the user mapping repository for plugin plugin-name cannot be accessed. Reason code reason-code .", "explanation": "The user mapping from the user mapping repository for plugin plugin-name cannot be accessed. The cause of the error is indicated by the reason-code : 1 The user mapping plugin cannot be loaded. 2 The version of the user mapping plugin API reported by the user mapping plugin is not compatible with the version federation supports. 3 A connection to the user mapping repository cannot be established or the connection request timed out. 4 The user mapping entry cannot be found on the user mapping repository. 5 A decryption error occurred while processing the user mapping entry from the user mapping repository. 6 Disconnection from the user mapping repository has failed. 7 Invalid parameter has been passed to the user mapping plugin. 8 Unauthorized invocation of the user mapping plugin has been detected. 9 Terminating the user mapping plugin has failed. 10 Unexpected error detected.", "response": "See the federation documentation for details on user mapping plugins. The action is based on the reason-code as follows: 1 Verify that the user mapping plugin exists and is in the correct location. 2 Ensure that the user mapping plugin is using a federation supported version of the user mapping plugin API and that it is reporting the correct version number. 3 Verify that the user mapping repository is up and  running and that the repository connection parameters of the user mapping plugin are correct. 4 Create a corresponding user mapping entry on the user mapping repository. 5 Ensure that the decryption logic in the user mapping plugin is implemented correctly. 6 Check if the user mapping repository and network are up and running. 7 Ensure that all the parameter values passed onto the user mapping plugin are correct. 8 Verify that federation has the authority to invoke the user mapping plugin. 9 Verify if plugin level global resources can be released. 10 Ensure the plugin maps the error to one of the defined errors. Trace information for the error may be available in the db2diag log file. sqlcode :  -20349 sqlstate :  429BU", "version": "12.1"}
{"id": "SQL20350N", "message": "Authentication at the user mapping repository for plugin plugin-name failed.", "explanation": "The user mapping from the user mapping repository for plugin plugin-name cannot be accessed because authentication at the user mapping repository failed.", "response": "See the federation documentation for details on user mapping plugins. Correct the repository connection credential parameters of the plugin. sqlcode :  -20350 sqlstate : 42516", "version": "12.1"}
{"id": "SQL20351W", "message": "Wrapper options were ignored for servers of wrapper wrapper-name that already have the plugin defined.", "explanation": "The existing DB2_UM_PLUGIN related options specified for a server are not overwritten when DB2_UM_PLUGIN related options of the corresponding wrapper are created or altered.", "response": "To change the DB2_UM_PLUGIN related options that are already specified for a server, alter the server options directly. sqlcode :  +20351 sqlstate : 01677", "version": "12.1"}
{"id": "SQL20352W", "message": "Changes to the user mapping apply only to the federated catalog table and not to the external user mapping repository.", "explanation": "The DB2_UM_PLUGIN option has been set for the server.  User mappings for this server are read from the external user mapping repository, however CREATE USER MAPPING, ALTER USER MAPPING, and DROP (USER MAPPING) statements only affect user mappings in the federated catalog table.", "response": "Use another interface to the external user mapping repository to create, alter, or drop the user mappings. sqlcode :  +20352 sqlstate : 01678", "version": "12.1"}
{"id": "SQL20353N", "message": "An operation involving comparison cannot use operand name defined as data type type-name .", "explanation": "The use of the value identified by name defined as data type type-name is not permitted in operations involving comparisons. An expression\n\tresulting in a type-name data type is not permitted in: A SELECT DISTINCT statement A GROUP BY clause An ORDER BY clause An aggregate function with DISTINCT A SELECT or VALUES statement of a set operator other than UNION ALL. The statement cannot be processed.", "response": "The requested operation on the data type type-name is not supported.\n\tYou may be able to change the data type of the value to a data type that is\n\tsupported using a cast or some other function. sqlcode :  -20353 sqlstate : 42818", "version": "12.1"}
{"id": "SQL20354N", "message": "Invalid specification of a row change timestamp column for table table-name .", "explanation": "The specification of a row change timestamp column is invalid for one of the following reasons. A row change\n\ttimestamp column cannot: be a column of a primary key. be a column of a foreign key. be a column of a functional dependency DEPENDS ON clause. be a column of a database partitioning key. be defined for a temporary table. The statement cannot be executed.", "response": "Correct the syntax and resubmit the statement. sqlcode :  -20354 sqlstate : 429BV", "version": "12.1"}
{"id": "SQL20356N", "message": "The table table-name cannot be truncated because DELETE triggers exist for the table, or the table is the parent in a referential constraint.", "explanation": "The TRUNCATE statement could not be processed for one of the following reasons: The TRUNCATE statement would result in the activation of DELETE triggers.  However, the statement specifies RESTRICT WHEN DELETE TRIGGERS (implicitly or explicitly). This can occur when DELETE triggers exist for the table to be truncated, and the result of the TRUNCATE statement would activate the triggers. The table to be truncated is the parent table in a referential constraint. The statement cannot be processed.", "response": "If the statement failed because of the existence of DELETE triggers, specify the IGNORE DELETE TRIGGERS clause on the TRUNCATE statement. If the statement failed because of referential constraints, use the ALTER TABLE statement to drop the referential constraints, and then re-issue the TRUNCATE statement. sqlcode :  -20356 sqlstate :  428GJ", "version": "12.1"}
{"id": "SQL20357N", "message": "One or more federated one-phase commit data source sites have failed commit or rollback processing.  As a result, the transaction outcome might not be consistent across all sites.  Subsequent SQL statements can be processed.  Reason code reason-code .", "explanation": "A federated server has sent a transaction commit or rollback request and one or\n\tmore of the\n\tfederated one-phase commit data source sites cannot complete the request. This\n\tmay be caused\n\tby a server failure, communication link failure, or other failure. The transaction is not\n\tcompletely committed or rolled back. The reason code indicates the specific situation. Commit failure does not involve an update federated data source. Commit failure involves an update federated data source. Rollback failure does not involve an update federated data source. Rollback failure involves an update federated data source. Commit or rollback processing encountered an error due to db2fmp process\n\tabnormal termination at the federated server, error '-430'.", "response": "Check the administration notification log for details. Compensating actions may\n\tneed to be applied manually at the federated one-phase commit data source sites. It may be necessary to contact the system administrator for assistance. For reason 5, disconnect the application from the federated server, e.g. issue a 'connect reset' clp command and reconnect. sqlcode :  -20357 sqlstate :  40003", "version": "12.1"}
{"id": "SQL20358N", "message": "Commit or rollback processing encountered an error.  The transaction at some federated two-phase commit data source sites could be indoubt.  Subsequent SQL statements can be processed.  Reason code reason-code .", "explanation": "A federated server has sent a transaction commit or rollback request and one or\n\tmore of the federated two-phase commit data source sites cannot complete the request. This may be caused by a server failure, communication link failure, or other failure. The transaction might be indoubt at the federated two-phase commit data source site. The reason code indicates the specific situation. Missing commit acknowledgement from federated data source site. Missing abort acknowledgement from federated data source site. Rollback processing encountered an error. The transaction might be indoubt at the federated two-phase commit data source site. Commit or rollback processing encountered an error due to db2fmp process\n\tabnormal termination at the federated server, error '-430'.", "response": "Determine the cause of the error. It may be necessary to contact the system\n\tadministrator for assistance since the most common cause of the error is a federated server failure, federated  data source site failure, or connection failure. For a federated server failure, the RESTART DATABASE command will complete the commit or rollback processing for this transaction. For a federated data source site failure, restart the failed data source. For a connection failure, consult with your network administrator and/or communication expert to determine the cause of the problem. For reason 3, check possible indoubt transactions on the federated data source\n\tsite, and manually resolve them if existing. For reason 4, disconnect the application from the federated server, e.g. issue a 'connect reset' clp command and reconnect. sqlcode :  -20358 sqlstate :  08007", "version": "12.1"}
{"id": "SQL20360W", "message": "A trusted connection cannot be established for the specified authorization ID.", "explanation": "A trusted connection cannot be established for the specified authorization ID. A matching trusted context is not currently defined or the server does not support trusted context. The attempt to create a trusted connection was not successful and a normal connection was created. Federated system users: If this message is returned during a federated request, then the attempt to create a trusted connection between the federated database and the remote server was not successful, and a normal connection was created instead.", "response": "Ensure that the server supports trusted contexts and that the trusted context has been correctly defined, and try to re-establish a trusted connection. Federated system users: Ensure that the remote server supports trusted contexts and that the trusted context has been correctly defined on the remote server. sqlcode :  +20360 sqlstate :  01679", "version": "12.1"}
{"id": "SQL20361N", "message": "The switch user request using authorization ID authorization-name within trusted context context-name failed with reason code reason-code .", "explanation": "The switch user request within the trusted context context-name failed.\n\tThe trusted connection is in an unconnected state.", "response": "Use the authorization ID authorization-name and the following explanations\n\tfor reason code reason-code to determine what action to take. 1 The authorization ID is not an allowed user of the trusted context. Provide an authorization ID that is an allowed user of the trusted context as described in the trusted context definition. 2 The switch user request did not include the authentication token. Provide the authentication token for the authorization ID. 3 The trusted context object is either disabled, dropped, or its system authorization ID altered. Only the authorization ID that established the trusted connection is allowed. Provide this authorization ID. sqlcode :  -20361 sqlstate :  42517", "version": "12.1"}
{"id": "SQL20362N", "message": "Attribute attribute-name with value value cannot be dropped or altered because it is not part of the definition of trusted context context-name .", "explanation": "Attribute attribute-name was specified for a trusted context, but the trusted context is not defined with an attribute with this name.  The statement could not be processed.", "response": "Remove the name of the unsupported attribute and re-issue the statement. sqlcode :  -20362 sqlstate :  4274C", "version": "12.1"}
{"id": "SQL20363N", "message": "Attribute attribute-name with value value is not unique for trusted context context-name .", "explanation": "During the create or alter of trusted context context-name , a duplicate value value was specified for the attribute-name attribute. Each pair of attribute name and value must be unique for a trusted context. The statement cannot be processed.", "response": "Remove the non-unique specification of attribute-name and and re-issue the statement. sqlcode :  -20363 sqlstate :  4274D", "version": "12.1"}
{"id": "SQL20364N", "message": "The identifier with the name name at ordinal position number in the statement is too long.", "explanation": "At least one identifier in the described statement is too long to fit in the destination buffer. The first name that is too long is identified by the name name and ordinal position number. If performing a describe output of a prepared query, the ordinal position is relative to the select list column of the query. If performing a describe output of a CALL statement, the ordinal position is relative to the OUT or INOUT parameters of the procedure to which the CALL resolved. If performing a describe input of a CALL statement, the ordinal position is relative to the IN or INOUT parameters of the procedure to which the CALL resolved. The column name, parameter name, user defined type name or user defined type schema name was either too long, or became too long after code page conversion.\n\tNote that the lengths of the column name, parameter name, user defined type name, and user defined type schema name are limited when using the SQLDA structure.", "response": "Do one of the following: Use a client whose code page does not cause expansion beyond the supported maximum length. For a column name, change the table, view, or nickname so the column has a shorter name. For a parameter name, change the procedure so the parameter has a shorter name. For a user defined type name or user defined type schema name, drop and recreate the user defined type with a shorter name. For a schema name, change the table, view, procedure, or user defined type. sqlcode :  -20364 sqlstate :  42622", "version": "12.1"}
{"id": "SQL20365W", "message": "A signaling NaN was encountered in an arithmetic operation or function involving DECFLOAT", "explanation": "A signaling NaN (sNaN) was encountered in an expression, arithmetic operation, or function involving a DECFLOAT column or value. The result is NaN", "response": "To stop the warning from being returned, find the tuple or tuples containing a signaling NaN and exclude them from the query. sqlcode :  +20365 sqlstate :  01565", "version": "12.1"}
{"id": "SQL20371W", "message": "The ability to use trusted context context-name was removed from some, but not all authorization IDs  specified in the statement.", "explanation": "An ALTER TRUSTED CONTEXT statement for context-name contained a DROP USE FOR clause with multiple authorization IDs or PUBLIC, but one or more authorization IDs were not defined to use the trusted context.  One or more users were removed from the definition of the trusted context, but one or more other users were not previously allowed to use the trusted context. The statement was processed.", "response": "Verify that the ability to use the trusted context was removed from all of the authorization IDs that was intended. sqlcode :  +20371 sqlstate :  01682", "version": "12.1"}
{"id": "SQL20372N", "message": "The trusted context context-name specified authorization ID authorization-name which is already specified for another trusted context.", "explanation": "A CREATE TRUSTED CONTEXT or ALTER TRUSTED CONTEXT statement for context-name specified SYSTEM AUTHID authorization-name , but this authorization ID is already defined to use a different trusted context. A system authorization ID that is defined as the SYSTEM AUTHID for a trusted context cannot be associated with any other trusted context as the SYSTEM AUTHID. Use the following query to determine which trusted context is already using the authorization ID: SELECT CONTEXTNAME FROM SYSCAT.CONTEXTS\n\tWHERE SYSTEMAUTHID = <authorization-name> Copy to clipboard The statement could not be processed.", "response": "Change the authorization ID to be the system authorization ID for the trusted context and reissue the CREATE or ALTER statement. sqlcode :  -20372 sqlstate :  428GL", "version": "12.1"}
{"id": "SQL20373N", "message": "A CREATE TRUSTED CONTEXT or ALTER TRUSTED CONTEXT statement specified authorization-name more than once or the trusted context is already defined to be used by this authorization ID or PUBLIC.", "explanation": "The statement specified that authorization-name be allowed to use the trusted context, but the specified authorization ID or PUBLIC is already defined to use the trusted context, or the authorization ID was specified more than once in the statement. The authorization ID or PUBLIC must not already be allowed to use the trusted context, and it can only be specified once within a statement for a trusted context. The statement could not be processed.", "response": "If the authorization ID or PUBLIC was specified more than once, remove the extra specifications of authorization-name , and re-issue the statement. If an ALTER TRUSTED CONTEXT statement contained an ADD USE FOR clause, and the trusted context already was defined for use by that authorization ID or PUBLIC, use the REPLACE USE FOR clause instead to redefine the usage characteristics for the specified users to use the trusted context. sqlcode :  -20373 sqlstate :  428GM", "version": "12.1"}
{"id": "SQL20374N", "message": "An ALTER TRUSTED CONTEXT statement for context-name specified authorization-name but the trusted context  is not currently defined to be used by this authorization ID or PUBLIC.", "explanation": "An ALTER TRUSTED CONTEXT statement for context-name attempted to replace or remove the ability for authorization-name to use the trusted context, but the specified authorization ID or PUBLIC is not currently defined to use the trusted context. The statement could not be processed.", "response": "If an ALTER TRUSTED CONTEXT statement contained a REPLACE USE FOR clause, and the trusted context was not already defined for use by that authorization ID or PUBLIC, use the ADD USE FOR clause instead to define the trusted context to be used by the specified users. If the ALTER TRUSTED CONTEXT statement contained the DROP USE FOR clause, none of the specified authorization IDs or PUBLIC were currently defined to use the trusted context. sqlcode :  -20374 sqlstate :  428GN", "version": "12.1"}
{"id": "SQL20377N", "message": "An illegal XML character hex-char was found in an SQL/XML expression or function argument that begins with string start-string .", "explanation": "An SQL/XML expression or function attempted to convert an SQL string\n\tvalue from one of the arguments to an XML string, but the string\n\tincluded a character at Unicode code point hex-char that is not\n\ta legal XML 1.0 character.\n\tThe character is included in a string that begins with the string start-string .\n\tThe value for hex-char represents the illegal character as a\n\tUnicode code point in the form \"#xH\", where H is one or more\n\thexadecimal characters.\n\tThe following set of Unicode characters (defined using a\n\tregular expression) are allowed:\n\t#x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF].\n\tExamples of the SQL/XML expression or function that may encounter\n\tthis error are XMLCAST, XMLELEMENT, XMLFOREST, XMLAGG, XMLDOCUMENT,\n\tXMLTEXT, XMLATTRIBUTES, XMLQUERY, or XMLTABLE. The statement cannot be processed.", "response": "Remove the illegal character hex-char or replace it with a\n\tcharacter that is allowed. sqlcode :  -20377 sqlstate : 0N002", "version": "12.1"}
{"id": "SQL20379N", "message": "An authorization ID cannot use its SECADM authority to transfer the ownership of an object to itself.", "explanation": "An authorization ID that has the SECADM authority cannot transfer the ownership of an object it does not already own to itself. It can, however, transfer the ownership of the object to another authorization ID. The statement cannot be processed.", "response": "Choose a different authorization ID as the new owner of the object. sqlcode :  -20379 sqlstate : 42502", "version": "12.1"}
{"id": "SQL20383W", "message": "Errors were encountered and tolerated as specified by the RETURN DATA UNTIL clause.", "explanation": "At least one error as specified by the RETURN DATA UNTIL clause\n\twas encountered and tolerated, with execution continuing for the query.\n\tThe results of the query might not be the same as they would be if the\n\terror had not occurred.", "response": "Be aware that the query results might not be complete.  If\n\tappropriate, check the source of the tolerated error and correct the situation. sqlcode :  +20383 sqlstate :  02506", "version": "12.1"}
{"id": "SQL20384W", "message": "The specified locale is not supported. The message was returned in the English locale.", "explanation": "The specified locale is not supported by the database manager.", "response": "Refer to the Administration Guide: Planning for the \"Supported code pages and territories\" or refer to the DB2 infocenter for the supported server languages and the corresponding locale values. sqlcode :  +20384 sqlstate : 01684", "version": "12.1"}
{"id": "SQL20386N", "message": "An XQuery expression cannot be specified in a DECLARE CURSOR statement.", "explanation": "The DECLARE CURSOR statement does not allow an XQuery expression to be\n\tspecified directly following the FOR keyword.\n\tAn XQuery expression can only be associated with a cursor using\n\ta prepared statement name.", "response": "Remove the XQuery expression from the DECLARE CURSOR statement\n\tand replace it with a statement name.\n\tPrepare the XQuery expression by issuing a PREPARE statement\n\tusing the same statement name. sqlcode :  -20386 sqlstate : 42637", "version": "12.1"}
{"id": "SQL20387N", "message": "Two or more elements are specified for the security label component component-name .", "explanation": "A security label cannot have multiple elements for a component of type ARRAY.", "response": "Specify only one element for the security label component component-name . sqlcode :  -20387 sqlstate : 428GP", "version": "12.1"}
{"id": "SQL20388N", "message": "Too many elements are specified for the security label component component-name .", "explanation": "A security label component of type SET or TREE can have no more than 64 elements. More than this number are specified for security label component component-name . For a security label component of type ARRAY, the maximum number of elements is 65 535. If elements are added via the ALTER SECURITY LABEL COMPONENT statement, the actual limit may be lower than this maximum due to the way DB2 assigns an encoded value to each new element.", "response": "For TREE and SET security label components, remove elements so that there are no more than 64. For ARRAY security components, if the maximum has not been reached, drop and create the component again with all the desired elements specified. sqlcode :  -20388 sqlstate : 54061", "version": "12.1"}
{"id": "SQL20389N", "message": "The component element element is not defined in the security label component component-name .", "explanation": "The component element element does not exist in the definition of security label component component-name .", "response": "Provide a valid element for the component. You can submit the following query to list the valid elements for the security label components: SELECT ELEMENTVALUE FROM\n\t\tSYSCAT.SECLABELCOMPONENTELEMENTS\n\t  WHERE COMPID=(SELECT COMPID FROM\n\t\tSYSCAT.SECLABELCOMPONENTS\n\t\tWHERE  COMPNAME = component-name) Copy to clipboard If you get this error when executing the scalar function SECLABEL, then also check  the security label string to make sure that the values are listed in the same order that their components are listed in the security policy. sqlcode :  -20389 sqlstate : 4274F", "version": "12.1"}
{"id": "SQL20390N", "message": "The security label component component-name is not defined in the security policy security-policy so that component cannot be used in the security label security-label .", "explanation": "Security labels can only contain values for those components that are defined in the security policy that the label is part of. The security label component component-name is not part of the security policy security-policy . The security label security-label is part of that security policy so the component component-name cannot be used in that security label.", "response": "Provide a security label component that is part of the security policy security-policy .  You can execute the following query to list the security label components that are part of the security policy: SELECT COMPNAME FROM\n\t  SYSCAT.SECURITYLABELCOMPONENTS\n\t  WHERE COMPID=(SELECT COMPID FROM\n\t\tSYSCAT.SECURITYPOLICYCOMPONENTRULES\n\t\tWHERE SECPOLICYID = (SELECT\n\t\t  SECPOLICYID FROM\n\t\t  SYSCAT.SECURITYPOLICIES\n\t\t  WHERE SECPOLICYNAME =\n\t\t\t'<security-policy>') ) Copy to clipboard sqlcode :  -20390 sqlstate : 4274G", "version": "12.1"}
{"id": "SQL20391N", "message": "Label-based access control cannot be applied to the column column-name because there is no security policy associated with the table.", "explanation": "In order to use the SECURED WITH clause with column column-name or to define it with a data type of DB2SECURITYLABEL, a security policy must be associated with the table.", "response": "Add a security policy to the table using the SECURITY POLICY clause of the CREATE TABLE statement or the ADD SECURITY POLICY clause of the ALTER TABLE statement. sqlcode :  -20391 sqlstate : 55064", "version": "12.1"}
{"id": "SQL20392N", "message": "The table table already has a security policy.", "explanation": "A table can have at most one security policy. Once associated, a security policy cannot be changed for a table.", "response": "Do not try to assign another security policy to the table. sqlcode :  -20392 sqlstate : 55065", "version": "12.1"}
{"id": "SQL20393N", "message": "The maximum number of components in security policy security-policy has been exceeded.", "explanation": "A security policy can have maximum of 16 components.", "response": "Reduce the number of components specified for the security policy security-policy . sqlcode :  -20393 sqlstate : 54062", "version": "12.1"}
{"id": "SQL20394N", "message": "The access rule access-rule does not exist in the rule set used by the security policy policy-name .", "explanation": "The access rule access-rule specified in the GRANT EXEMPTION or REVOKE EXEMPTION statement is not part of the LBAC rule set that is used by the security policy policy-name .", "response": "The specified access rule does not exists for in the rule set used by the specified security policy. sqlcode :  -20394 sqlstate : 4274H", "version": "12.1"}
{"id": "SQL20395N", "message": "The GRANT of security label security-label1 conflicts with security label security-label2 that is also granted to authorization ID authorization-name .", "explanation": "If the user, group, or role is granted two distinct labels, one for WRITE access and another for READ access, they must satisfy the following rules: For security label components of type ARRAY,  the value must be the same in both security labels. For security label components of type SET, the values given in the security label used for WRITE access must be a subset of the values given in the security label used for READ access. for security label components of type TREE, either the values must be the same, or the values given in the security label used for WRITE access must be one of the sub tree values of the security label used for READ access.", "response": "Grant a different security label or make one of these modifications to the security label that is being granted: For security label components of type ARRAY, make sure the value given is the same in both security labels. For security label components of type SET, make sure the values given in the security label used for WRITE access are a subset of the values given in the security label used for READ access. For security label components of type TREE, make sure either the values are the same or the value given in the security label used for WRITE access is one of the sub tree values of the security label used for READ access. sqlcode :  -20395 sqlstate : 428GQ", "version": "12.1"}
{"id": "SQL20396N", "message": "The security label named security-label-name cannot be found for the security policy policy-name .", "explanation": "The security label named security-label-name cannot be found for the security policy policy-name . This caused execution of the built-in function SECLABEL_BY_NAME to fail.", "response": "Check the spelling of security-label-name . Make sure you are using the correct security policy name. sqlcode :  -20396 sqlstate : 4274I", "version": "12.1"}
{"id": "SQL20397W", "message": "Routine routine-name execution has completed, but at least one error, error-code , was encountered during the execution. More information is available.", "explanation": "Routine routine-name execution has completed. At least one error was\n\tencountered during the internal execution of the requested function. The last error\n\tencountered was error-code . More detailed information on the errors encountered\n\tis available. For the ADMIN_CMD routine, its output parameter and result set, if any, have been\n\tpopulated.", "response": "Retrieve the output parameter and result set, if any, for more\n\tinformation on the errors encountered. If message files were generated during the\n\texecution, examine their content and resolve the error situations. If appropriate,\n\treinvoke the routine again. sqlcode :  +20397 sqlstate : 01H52", "version": "12.1"}
{"id": "SQL20401N", "message": "The table cannot be protected by a security policy because an MQT or staging table named object-name depends on the table.", "explanation": "The table cannot be protected with LBAC because, a materialized query table (MQT) or staging table depends on the table.", "response": "If appropriate, drop the MQT or staging table object-name and resubmit the statement. sqlcode :  -20401 sqlstate : 55067", "version": "12.1"}
{"id": "SQL20402N", "message": "Authorization ID auth-id does not have the LBAC credentials to perform the operation-name operation on table table-name .", "explanation": "The authorization ID auth-id is not allowed to perform operation operation-name on the table table-name . A user is not allowed to insert, update or delete a row in a protected table or alter the table to become a protected table if they do not have appropriate security label and/or exemption credentials.", "response": "Ask your database security administrator to grant the authorization ID auth-id the proper security label or exemptions required  to perform the insert, update or delete operation. To alter the table to become a protected table, a grant of a security label for WRITE access is required. sqlcode :  -20402 sqlstate : 42519", "version": "12.1"}
{"id": "SQL20403N", "message": "The authorization ID auth-id already has a security label ( security-label ) for access-type access.", "explanation": "Each authorization ID can have at most one security label for WRITE access and at most one for READ access. The security label security-label has already been granted to the authorization ID auth-id for access-type access.", "response": "If you want to change the security label used for access-type access you must first use the REVOKE SECURITY LABEL statement to revoke the security label security-label from authorization ID auth-id . sqlcode :  -20403 sqlstate : 428GR", "version": "12.1"}
{"id": "SQL20404N", "message": "The security label object policy-name.object-name cannot be dropped because it is currently in use.  Reason code reason-code .", "explanation": "The security label object object-name could not be dropped. The reason it could not be dropped is specified by the reason code reason-code : It is granted to one or more users, groups, or roles. It is being used to protect one or more columns.", "response": "The user response corresponding to the reason code is: Revoke this label from all users, groups, or roles who have been granted this security label for this security policy. The following  query can be used to find all the users who has been granted with this label. SELECT GRANTEE FROM SYSCAT.SECURITYLABELACCESS\n\t  WHERE SECLABELID = (SELECT SECLABELID FROM\n\t  SYSCAT.SECURITYLABELS\n\t  WHERE SECLABELNAME = '<object-name>' AND\n\t\tSECPOLICYID = (SELECT SECPOLICYID FROM\n\t\tSYSCAT.SECURITYPOLICIES\n\t  WHERE SECPOLICYNAME = '<policy-name>' ) ) Copy to clipboard For all the tables that use this security label to protect a column, either alter the table to drop this security label or drop the table.  The following query can be used to find all  protected tables  and all the columns that are protected with this label. SELECT TABNAME, COLNAME FROM SYSCAT.COLUMNS\n\t  WHERE SECLABELNAME = '<object-name>' AND\n\t\tTABNAME = (SELECT TABNAME FROM\n\t\tSYSCAT.TABLES\n\t  WHERE SECPOLICYID = (SELECT SECPOLICYID FROM\n\t  SYSCAT.SECURITYPOLICIES\n\t  WHERE SECPOLICYNAME = '<policy-name>' ) ) Copy to clipboard sqlcode :  -20404 sqlstate :  42893", "version": "12.1"}
{"id": "SQL20405N", "message": "The security policy object object-name cannot be dropped because it is currently in use.  Reason code reason-code .", "explanation": "The security object object-name could not be dropped. The reason it could not be dropped is specified by the reason code reason-code : It is being used to protect one or more tables. There are one or more security labels that use it. There are one or more exemptions granted on one or more of its rules.", "response": "The user response corresponding to the reason code is: Drop the security policy from the tables protected by it using the ALTER TABLE statement. The following query can\n\tbe used to find all the tables protected by this security policy: SELECT TABNAME FROM SYSCAT.TABLES\n\t  WHERE SECPOLICYID=(SELECT SECPOLICYID FROM\n\t  SYSCAT.SECURITYPOLICIES\n\t  WHERE SECPOLICYNAME = '<object-name>' ) Copy to clipboard Drop all the security labels that are part of this security policy. The following query can be used find all security labels that belongs to this security policy: SELECT SECLABELNAME FROM SYSCAT.SECURITYLABELS\n\t  WHERE SECPOLICYID=(SELECT SECPOLICYID FROM\n\t  SYSCAT.SECURITYPOLICIES\n\t  WHERE SECPOLICYNAME = '<object-name>' ) Copy to clipboard Revoke all the exemptions granted on rules used by this security policy from all users. The following query can\n\tbe used find all users that have been granted exemptions on rules used by this security policy. SELECT GRANTEE, ACCESSRULENAME FROM\n\t  SYSCAT.SECURITYPOLICYEXEMPTIONS\n\t  WHERE SECPOLICYID=(SELECT SECPOLICYID FROM\n\t  SYSCAT.SECURITYPOLICIES\n\t  WHERE SECPOLICYNAME = '<object-name>' ) Copy to clipboard sqlcode :  -20405 sqlstate : 42893", "version": "12.1"}
{"id": "SQL20406N", "message": "The security label component object object-name cannot be dropped because it is part of a security policy.", "explanation": "The security label component object object-name cannot be dropped because one or more security policies refer to it.", "response": "Drop all the security policies that refer to this security component. The following query can be used find all the security policies that refer to this security component: SELECT SECPOLICYNAME FROM SYSCAT.SECURITYPOLICIES\n\t  WHERE SECPOLICYID = (SELECT SECPOLICYID FROM\n\t  SYSCAT.SECURITYPOLICYCOMPONENTRULES\n\t  WHERE COMPID = (SELECT COMPID FROM\n\t  SYSCAT.SECURITYLABELCOMPONENTS\n\t  WHERE COMPNAME = '<object-name>' ) ) Copy to clipboard sqlcode :  -20406 sqlstate : 42893", "version": "12.1"}
{"id": "SQL20408N", "message": "Table source-tablename cannot be attached to table target-tablename because column source-columnname of the source table and its associated column target-columnname of the target table do not match. Reason code = reason-code .", "explanation": "An attribute of the target table column does not match the attribute of the corresponding column (aligned by ordinal position) in the source table in the ALTER TABLE ... ATTACH PARTITION statement.  The reason-code indicates the type of mismatch and in which column of the SYSCAT.COLUMNS view to find the table attribute. In cases where it is difficult or impossible to modify the characteristics of either the source or target table for compatibility, you can create a new table that is compatible with the target table, and copy the data from source-tablename to this new table. 1 The data type of the columns (TYPENAME) does not match. 2 The nullability of the columns (NULLS) does not match. 3 The implicit default value (IMPLICITVALUE) of the columns are incompatible. Implicit defaults must match exactly if both the target table column and source table column have implicit defaults (if IMPLICITVALUE is not NULL). Refer to the SQL Reference Manual for details on interpreting the values in IMPLICITVALUE. 4 The code page (COMPOSITE_CODEPAGE) of the columns does not match. 5 The system compression default clause (COMPRESS) does not match. 6 The security label protecting the source-columnname for the source table is not identical to that of target-columnname for the target table. The two tables must have the same set of protected columns and each pair of corresponding columns must be protected with same security label. 7 The row change timestamp attribute of the columns does not match. 8 For structured, XML, or LOB data types, the inline length of the columns (INLINE LENGTH) do not match. 9 If a column mask on source-columnname for the source table exists and is enabled, a column mask on target-columnname for the target table must also exist and be enabled. 10 The ROW BEGIN system-generated attributes of the columns do not match. 11 The ROW END system-generated attributes of the columns do not match. 12 The TRANSCATION START ID system-generated attributes of the columns do not match.", "response": "Correct the mismatch in the tables. 1 To correct a mismatch in data type, issue the statement: ALTER TABLE ... ALTER COLUMN ...\n\t   SET DATA TYPE ... Copy to clipboard 2 Alter the nullability of the column that does not match for one of the tables by issuing one of the following statements: ALTER TABLE... ALTER COLUMN...\n\t   DROP NOT NULL ALTER TABLE...\n\t\t  ALTER COLUMN...   SET NOT NULL Copy to clipboard 3, 4 Create a new source table. 5 To alter the system compression of the column issue one of the following statements to correct the mismatch: ALTER TABLE ... ALTER COLUMN ...\n\t   COMPRESS SYSTEM DEFAULT\n\t\t  ALTER TABLE ... ALTER COLUMN ...\n\t\t\t COMPRESS OFF Copy to clipboard 6 To alter the security protection of a column, issue one of the following statements: ALTER TABLE ... ALTER COLUMN ...\n\t   SECURED WITH ... ALTER TABLE ...\n\t\t  ALTER COLUMN ...\n\t\t\t DROP COLUMN SECURITY Copy to clipboard 7 When the target-columnname of the target table is defined as a row change timestamp column, the source-columnname must also be defined as a row change timestamp column. 8 Alter the inline length of the column that does not match by issuing the following statement: ALTER TABLE ... ALTER COLUMN ...\n\t   SET INLINE LENGTH ... Copy to clipboard 9 Create an enabled mask on the column target-columnname by issuing the following statement, and then try ALTER again. CREATE MASK ON target-table...\n\t\tFOR target-columnname... ENABLE Copy to clipboard 10 When the target-columnname of the target table is defined as a ROW BEGIN system-generated column, the source-columnname must also be defined as a ROW BEGIN system-generated column. 11 When the target-columnname of the target table is defined as a ROW END system-generated column, the source-columnname must also be defined as a ROW END system-generated column. 12 When the target-columnname of the target table is defined as a TRANSCATION START ID system-generated column, the source-columnname must also be defined as a TRANSCATION START ID system-generated column. sqlcode :  -20408 sqlstate :  428GE", "version": "12.1"}
{"id": "SQL20409N", "message": "An XML document or constructed XML value contains a combination of XML nodes that causes an internal identifier limit to be exceeded.", "explanation": "An internal identifier that must be associated with each XML node of an XML value\n\tcannot be generated because the combination of the number of levels of XML\n\tnodes and the number of children nodes within these levels causes the identifier to\n\toverflow.", "response": "For a document or constructed XML value, reduce the number of levels of XML\n\tnodes or the number of children nodes especially at the deeper levels of XML\n\tnodes. sqlcode :  -20409 sqlstate :  560CG", "version": "12.1"}
{"id": "SQL20410N", "message": "The number of children nodes of an XML node in an XML value has exceeded the limit of limit-number children nodes.", "explanation": "An expression generated an XML value with an XML node that has a number of\n\tchildren nodes which exceeds the limit of limit-number children nodes.", "response": "Rewrite the expression generating the XML value such that the number of children\n\tnodes does not exceed the limit. sqlcode :  -20410 sqlstate :  560CH", "version": "12.1"}
{"id": "SQL20412N", "message": "Serialization of an XML value resulted in characters that could not be represented in the target encoding.", "explanation": "Serialization of XML data may require conversion to an encoding different from the source UTF-8 encoding. If characters exist\n\tin the source encoding that cannot be represented in the target encoding, code page conversion produces substitution characters\n\twhich are not allowed in the result of XML serialization.", "response": "Choose a target encoding that can represent all characters in the XML value. Unicode encodings are recommended as they can\n\trepresent all characters. sqlcode :  -20412 sqlstate :  2200W", "version": "12.1"}
{"id": "SQL20413N", "message": "The built-in function SECLABEL_TO_CHAR could not be executed because authorization ID auth-id has had its security label for READ access revoked.", "explanation": "To execute the built-in function SECLABEL_TO_CHAR, the authorization ID must have a security label for READ access. The security label for READ access has been revoked from authorization ID auth-id .", "response": "Contact the database security administrator or a user with SECADM authority and ask that the security label be granted again. sqlcode :  -20413 sqlstate :  42520", "version": "12.1"}
{"id": "SQL20414N", "message": "The authority-or-privilege authority or privilege cannot be granted to authorization ID authorization-ID .", "explanation": "The GRANT statement attempted to grant an authority or privilege to an authorization name that is not allowed to receive that authority or privilege. The statement cannot be processed", "response": "Grant a different authority or privilege or grant it to an authorization ID that can receive the authority or privilege. sqlcode :  -20414 sqlstate :  42521", "version": "12.1"}
{"id": "SQL20415N", "message": "Update, delete, or Insert into a UNION ALL view failed because one of the underlying tables is protected.", "explanation": "Updates, deletes, and Inserts are not allowed into a UNION ALL view if that view is created on one or more protected tables. The statement cannot be processed", "response": "Do not update, delete, or insert into the UNION ALL view. sqlcode :  -20415 sqlstate :  429BZ", "version": "12.1"}
{"id": "SQL20416N", "message": "The value provided ( seclabel ) could not be converted to a security label. Labels for the security policy with a policy ID of policy-id should be correct-length characters long. The value is value-length characters long.", "explanation": "An INSERT or UPDATE statement specified a value for a column of type DB2SECURITYLABEL. The value cannot be converted to a valid security label because it is not the correct length for security labels that are part of the security policy that is protecting the table. If the seclabel value is *N, then the actual value has been written in the db2diag log file.", "response": "Check the INSERT or UPDATE statement and make sure that the value being set in the security label column is valid for the security policy protecting the table. Sometimes an invalid value can be generated as a result of a SELECT done from a table that is not protected with the same security policy as the target table. You should only copy security labels between tables protected by the same security policy. To get the security policy name for the given policy ID use this SQL query. Replace policy-id with the policy ID number given in the error message. SELECT SECPOLICYNAME\n\t\t\t  FROM  SYSCAT.SECURITYPOLICIES\n\t\t\t  WHERE SECPOLICYID = policy-id Copy to clipboard sqlcode :  -20416 sqlstate :  23523", "version": "12.1"}
{"id": "SQL20417W", "message": "The SQL compilation completed without connecting to the data source data-source-name . Connection error error-text was encountered.", "explanation": "The federated server could not connect to the data source data-source-name during SQL compilation to determine which features the data source supports.  The SQL query has been compiled using default settings.  At run time an error may be received because the remote server's capabilities were not correctly determined at compilation time. The error-text contains information about what connection error was encountered.", "response": "Recompile the statement or bind the package again when the data source is available, or if an error tolerant nested table expression is used in the SQL statement, execute the package immediately after the compilation to reduce the chance of the connection state changing between compilation and run time. Use the information in error-text to resolve the error connecting to the data source, if necessary. sqlcode :  +20417 sqlstate :  01689", "version": "12.1"}
{"id": "SQL20418N", "message": "The database partition group is already assigned to the buffer pool.", "explanation": "The database partition group that you are attempting to add has already been assigned to the buffer pool.", "response": "Choose another database partition group and try again. sqlcode :  -20418 sqlstate :  4274J", "version": "12.1"}
{"id": "SQL20419N", "message": "For table table-name , authorization ID auth-id does not have LBAC credentials that allow using the security label security-label-name to protect column column-name .", "explanation": "A user cannot use a security label to protect a column unless that user has LBAC credentials that allow writing to a column protected by the security label. Authorization ID auth-id does not have LBAC credentials that allow write access to data protected by the security label security-label-name and therefore cannot use it to protect column column-name in table table-name .", "response": "Ask a database security adminstrator to grant the authorization ID authid LBAC credentials that allow write access to a column protected by security label security-label-name . sqlcode :  -20419 sqlstate :  42522", "version": "12.1"}
{"id": "SQL20420N", "message": "For table table-name , authorization ID auth-id does not have LBAC credentials that allow removing the security label security-label-name from column column-name .", "explanation": "To be able to drop or replace a security label that is protecting a column, an authorization ID must have LBAC credentials that allow both reading from and writing to a column. The authorization ID auth-id does not have LBAC credentials that allow both reading from and writing to a column  protected by the security label security-label-name and therefore cannot drop or replace that security label.", "response": "Ask a database security adminstrator to grant the authorization ID authid LBAC credentials that allow both read and write access to a column protected by security label security-label-name . sqlcode :  -20420 sqlstate :  42522", "version": "12.1"}
{"id": "SQL20421N", "message": "The table table-name is not protected with a security policy.", "explanation": "A security policy cannot be dropped from a table that is not protected with a security policy.", "response": "Specify a table that is protected with a security policy. sqlcode :  -20421 sqlstate :  428GT", "version": "12.1"}
{"id": "SQL20422N", "message": "The statement failed because the table table-name would only contain hidden columns.", "explanation": "A CREATE TABLE or ALTER TABLE statement attempted to  create or alter table table-name in which all the columns are considered implicitly hidden. This can occur  when: A CREATE TABLE statement specifies IMPLICITLY HIDDEN as part of the definition of all columns. An ALTER TABLE statement alters any not hidden columns to implicitly hidden Change the column definition ensuring it includes at least one column that is defined as not hidden.", "response": "Ensure that the table definition includes at least one column that is not defined as implicitly hidden. sqlcode :  -20422 sqlstate :  428GU", "version": "12.1"}
{"id": "SQL20423N", "message": "Error occurred during text search processing on server server-name using index index-name . The error message is text-search-error-msg .", "explanation": "An error described by text-search-error-msg occurred during the  processing of a text search function that used the text search index index-name .", "response": "Use text-search-error-msg to determine the cause of the error. If the error message  is truncated, you can see the complete message in the db2diag log file. The first word in text-search-error-msg is an error identifier. If the error  identifier starts with 'CIE', use the db2ts command to obtain more details, for example, db2ts help error-identifier . If the error identifier does not start with 'CIE', use the DB2 Text Search documentation to obtain more details about text-search-error-msg . sqlcode :  -20423 sqlstate :  38H10", "version": "12.1"}
{"id": "SQL20424N", "message": "Text search support is not available. Reason code = reason-code .", "explanation": "An error occurred while attempting to use text search. The reason code provides more information about the error: 11 Socket communication with the search server failed. 12 Unrecoverable error during a search system operation.", "response": "Restart the text search instance service and try the operation again. If the error reoccurs,  contact your system administrator to ensure that support for text searching has been  installed, properly configured, and has been started on your system. sqlcode :  -20424 sqlstate :  38H11", "version": "12.1"}
{"id": "SQL20425N", "message": "The statement failed because the column named column-name in the table named table-name was specified as an argument to a text search function, but an active text search index does not exist for the specified column.", "explanation": "A text search function, such as CONTAINS or SCORE, specified a column as an argument but a text search index does not exist for this column. The text search index is inactive. The text search index is invalid. A text search index may be invalidated automatically, for example, if the underlying base table was dropped and recreated. The query combines different types of text search indexes. Text search processing cannot be performed for the specified column.", "response": "Ensure that the database is enabled for text search and a text search index has been created on the specified column. Activate the text index with the ALTER INDEX command, with the ACTIVATE option. If the table column has an invalid text search index, drop the text index and create a new one. If the query combines multiple text search indexes, make sure that all indexes are active and of the same type. sqlcode :  -20425 sqlstate :  38H12", "version": "12.1"}
{"id": "SQL20426N", "message": "Conflicting text search administration procedures or commands running on the same index.", "explanation": "Two or more conflicting administration procedures or commands are running on the same index.", "response": "Invoke the administration procedure or command after the currently running procedure or command completes.\n\tIf the operation attempted is DISABLE, retry this operation later or use the FORCE option of the command.\n\tTo fix this conflict, the text search administrator needs to clear the lock: db2ts clear command locks for text connect to database-name sqlcode :  -20426 sqlstate :  38H13", "version": "12.1"}
{"id": "SQL20427N", "message": "An error occurred during a text search administration procedure or command. The error message is text-search-error-msg .", "explanation": "A text search administration operation failed with an error message text-search-error-msg .", "response": "Use the error message text-search-error-msg to determine the cause of the error. If the message  is truncated, you can see the db2diag log file. The first word in text-search-error-msg is an error identifier. If the error identifier starts  with 'CIE', use the db2ts command to obtain more details, for example, db2ts help error-identifier . If the error identifier does not start with 'CIE', use the DB2 Text Search documentation to obtain more details about text-search-error-msg . sqlcode :  -20427 sqlstate :  38H14", "version": "12.1"}
{"id": "SQL20428N", "message": "URI specified in the the ACCORDING TO XMLSCHEMA clause is an empty string.", "explanation": "The target namespace URI specified following the URI keyword or the schema location URI specified following the LOCATION keyword is an empty string.", "response": "Ensure that every target namespace URIs and every schema location URI in the ACCORDING TO XMLSCHEMA clause is a valid URI that is not an empty string. sqlcode :  -20428 sqlstate :  428GV", "version": "12.1"}
{"id": "SQL20429N", "message": "The XML operation operation-name is not allowed on strings that are not FOR BIT DATA on this database.", "explanation": "The specified operation could not be performed on the string because it is not FOR BIT DATA. operation-name is either XMLPARSE or another prohibited operation.", "response": "The database configuration parameter ENABLE_XMLCHAR is set to NO. To allow XMLPARSE on strings that are not FOR BIT DATA, set ENABLE_XMLCHAR to YES. Note that character substitution may occur if the database is not Unicode and the XML value being parsed contains characters that are not present in the database code page. Alternatively, rework the statement to use a host variable, expression or parameter marker of type XML. sqlcode :  -20429 sqlstate :  428GW", "version": "12.1"}
{"id": "SQL20430N", "message": "Global variable variable-name cannot be set or referenced in this context.", "explanation": "In some contexts a global variable cannot be set and in other contexts it cannot be referenced. This message can be returned in the following situations: A statement attempted to set the named global variable in one of the following contexts: compound SQL (inline) statements functions where the body is not a compound SQL (compiled) statement methods triggers where the body is not a compound SQL (compiled) statement A global variable is being referenced in a procedure that is defined as AUTONOMOUS The statement cannot be processed.", "response": "Remove the unsupported setting or reference of the global variable. sqlcode :  -20430 sqlstate :  428GX", "version": "12.1"}
{"id": "SQL20431N", "message": "ROW CHANGE TIMESTAMP FOR table-designator cannot be returned for the table designator.", "explanation": "A ROW CHANGE TIMESTAMP FOR table-designator expression is not valid for a table\n\twhich does not have a column defined as a row change timestamp column. The statement cannot be processed.", "response": "Remove the ROW CHANGE TIMESTAMP FOR expression from the statement or alter the table and add the row change timestamp column. sqlcode :  -20431 sqlstate :  55068", "version": "12.1"}
{"id": "SQL20432N", "message": "The original XML schema contains schema-component that is enclosed within or referenced by enclosing-schema-component which is not compatible with the updated XML schema.  The reason for the incompatibility is: reason-code ( reason-string ).", "explanation": "The XML schema specified to update another existing XML schema does not meet the criteria for a compatible XML schema update. The original XML schema contains an element, attribute, or type schema-component that is enclosed within or referenced by the element or attribute enclosing-schema-component which is not compatible with the updated XML schema. The specific  reason for the incompatibility is given by reason-code ( reason-string ). 1 (ATTRIBUTE CONTENT) An attribute declared or referenced inside a complex type has been removed or some required  attributes have been added as part of the content model. The value of schema-component is the name of the enclosing complex type in the original XML schema and the value of enclosing-schema-component is the name of the element that refers to the complex type. In the case of an anonymous complex type the value of schema-component is empty. 2 (ELEMENT CONTENT) An element declared or referenced inside a complex type has been removed or some required  elements have been added as part of the content model. The value of schema-component is the name of the enclosing complex type in the original XML schema and the value of enclosing-schema-component is the name of the element that refers to the complex type. In the case of an anonymous complex type the value of schema-component is empty. 3 (FACET CONFLICT) The facet value of the simple type has been changed in a way that is not compatible with the range of values for the simple type. The value of schema-component is the name of the simple type that defines this facet in the original XML schema and the value of enclosing-schema-component is the name of the element or attribute that refers to the simple type. In the case of anonymous simple type the value of schema-component is empty. 4 (INCOMPATIBLE TYPE) The type of an element or attribute has been changed in a way that results in instance document validation failure or that is not compatible because of a simple type annotation change. The value of schema-component is the name of the type in the original XML schema and the value of enclosing-schema-component is the name of the element or attribute that refers to the type. In the case of an anonymous type the value of schema-component is empty. 5 (MIXED INTO NOT MIXED CONTENT) The content model of a complex type which is declared as mixed in the original XML schema has been changed to not mixed content in the updated XML schema. The value of schema-component is the name of the complex type in the original XML schema and the value of enclosing-schema-component is the name of the  element that refers to the complex type. In the case of an anonymous complex type the value of schema-component is empty. 6 (NILLABLE INTO NOT NILLABLE) The nillable attribute in an element declaration is turned on in the original XML schema but gets turned off in the updated XML schema. The value of schema-component is the name of the element in the original XML schema and the value of enclosing-schema-component is empty. 7 (REMOVED ELEMENT) A global element declared in schema-component has either been removed from the updated XML schema or made abstract. The value of enclosing-schema-component is empty. 8 (REMOVED TYPE) The original XML schema contains a global type in schema-component that is derived from another type and the global type gets removed from the updated XML schema. The value of enclosing-schema-component is empty. 9 (SIMPLE TO COMPLEX) A complex type that contains simple content in the original XML schema cannot be redefined to contain complex content in the updated XML schema. The value of schema-component is the name of the complex type in the original XML schema and the value of enclosing-schema-component is the name of the element that refers to the complex type. In the case of an anonymous complex type the value of schema-component is empty. 10 (SIMPLE CONTENT) The simple type defined in the original XML schema and the updated XML schema have different base types. The value of schema-component is the name of the simple type in the original XML schema and the value of enclosing-schema-component is the name of the element or attribute that refers to the simple type. In the case of an anonymous simple type the value of schema-component is empty.", "response": "Compare the explanations provided with reason-code ( reason-string ) and identify the cause of the incompatibility. Next, correct the problem and then resubmit the command to update the XML schema. sqlcode :  -20432 sqlstate :  22538", "version": "12.1"}
{"id": "SQL20435N", "message": "The SELECT clause includes an ARRAY_AGG function and all invocations of ARRAY_AGG, LISTAGG, XMLAGG, and XMLGROUP functions in the same SELECT clause do not have the same order.", "explanation": "The SELECT clause includes an ARRAY_AGG and one of the following conditions exists: The ARRAY_AGG function invocation includes an ORDER BY clause and the specified sort key is different from the sort key of at least one occurrence of an ARRAY_AGG, LISTAGG, XMLAGG, or XMLGROUP function invocation in the same SELECT clause. The ARRAY_AGG function invocation does not include an ORDER BY clause and the specified sort keys are not the same for all invocations of ARRAY_AGG, LISTAGG, XMLAGG, or XMLGROUP functions in the same SELECT clause.", "response": "Change the sort-keys to make them identical, or remove the specification of sort-key in all but one of the function invocations. sqlcode :  -20435 sqlstate :  428GZ", "version": "12.1"}
{"id": "SQL20436N", "message": "The data type specified for an array is not valid.", "explanation": "The data type specified for an array in the CREATE TYPE statement, CREATE HADOOP TABLE statement with columns of type array, array constructor, argument to UNNEST, argument to ARRAY_AGG, or target of ARRAY_AGG is not valid. The following restrictions apply when specifying a data type. The following data types are not supported: LONG VARCHAR LONG VARGRAPHIC REFERENCE XML BOOLEAN (prior to Version 9.7.5) user-defined data types other than row data type and array data type The array index data type for an associative array must be INTEGER or VARCHAR. For Hadoop tables, the only supported nesting is array of rows. An argument to UNNEST cannot be a nested array. An argument to ARRAY_AGG and the target of ARRAY_AGG cannot be a nested array. The target of an ARRAY_AGG cannot be a nested array. ARRAY types or ROW types can be nested as elements in other ARRAY types, but there is a maximum nesting level which must not be exceeded.", "response": "Ensure that the data type specified in a CREATE TYPE (array) statement, a CREATE HADOOP TABLE statement with columns of type array, an array constructor, the argument to UNNEST, the argument to ARRAY_AGG, or as the target of ARRAY_AGG is supported. sqlcode :  -20436 sqlstate :  429C2", "version": "12.1"}
{"id": "SQL20437N", "message": "The array index operation cannot be applied to an object of a data type that is not ARRAY.", "explanation": "The array index operation of the form object[array index] cannot be applied to an object whose type is not ARRAY.", "response": "Change the variable or parameter to be of type ARRAY. sqlcode :  -20437 sqlstate :  428H0", "version": "12.1"}
{"id": "SQL20438N", "message": "The data type of an array index expression is not assignable to the array index type.", "explanation": "The type of an array index expression in an expression of the form object[array_index] must be assignable to INTEGER if the object is an ordinary array. If the object is an associative array, then the type of the array index expression must be assignable to the data type of the array index (INTEGER or VARCHAR).", "response": "Change the data type of the array index expression to be one that is supported. sqlcode :  -20438 sqlstate :  428H1", "version": "12.1"}
{"id": "SQL20439N", "message": "Array index with value value is out of range or does not exist.", "explanation": "The value of an array index for an array element specification or the second argument to TRIM_ARRAY is out of range or the null value. If the array index is specified in an array element specification for an associative array and is valid for the array index data type, the element with array index value value does not exist in the array.", "response": "For an associative array: Specify a value that is not the null value. If the array index data type is integer, specify a value that is a number within the range of integers. Specify an array index value that exists in the array. For an ordinary array: If the value is an array index used in an array element specification that is the target of an assignment statement, change the value to be not the null value, not less than 1 and not greater than the maximum cardinality defined for the array. If the value is an array index used in an array element specification that is part of an expression or the value is the second argument to the TRIM_ARRAY function, change the value to be not less than 0 and not greater than the cardinality of the array. sqlcode :  -20439 sqlstate :  2202E", "version": "12.1"}
{"id": "SQL20440N", "message": "Array value with cardinality cardinality is too long. The maximum cardinality allowed is max-cardinality .", "explanation": "The array value required truncation from its cardinality of cardinality to a maximum cardinality of max-cardinality . A system (built-in) cast or adjustment function was called to transform the value in some way. The truncation is not allowed where the value is used. The array value being transformed is one of the following: An argument to a stored procedure call The result of a call to the ARRAY_AGG function The result of an array constructor used in the right side of a SET statement An argument to a cast function", "response": "Examine the SQL statement to determine where the transformation is taking place. Either the input to the transformation is too long, or the target is too short. Explicitly reduce the cardinality of the input, or increase the cardinality that the target can support. sqlcode :  -20440 sqlstate :  2202F", "version": "12.1"}
{"id": "SQL20441N", "message": "A type-name data type is not supported in the context where it is being used.", "explanation": "The data type can be specified in multiple contexts, including the following. Parameters to SQL functions: Defined in a module With a compound SQL (compiled) statement as function body not defined in a module Return types from SQL functions: Defined in a module With a compound SQL (compiled) statement as function body not defined in a module Parameters to SQL procedures Local variables declared in SQL functions: Defined in a module With a compound SQL (compiled) statement as function body not defined in a module Local variables declared in SQL procedures Local variables declared in triggers with a compound compiled SQL statement as trigger body Expressions in SQL statements within compound compiled SQL statements Global variables The following is a list of some invalid contexts: Parameters or variables in external  routines Return type of a function with a function body definition defined by a compound SQL (inlined) statement Columns in tables Data types in SQL statements outside of SQL PL contexts Global variable (includes module-variable) being referenced outside of an SQL PL context. Input or output parameter to a procedure or function being invoked from outside of an SQL PL context. In a partitioned database environment (DPF) or symmetric multiprocessor (SMP) environment, only top level SET and CALL statements can reference objects defined in nested types. A sub-query cannot reference objects with nested types. Nested types with global variables, module variables, or PL/SQL package variables in autonomous routines.", "response": "Refer to the documentation for the most up to date list of supported contexts and for restrictions on the use of this data type.  Remove any data types used in unsupported contexts. If referencing the data type in a routine reference from a command interface, invoke the routine from within an SQL PL context or provide a global variable of the specified data type as the routine argument. sqlcode :  -20441 sqlstate :  428H2", "version": "12.1"}
{"id": "SQL20442N", "message": "There is not enough storage to represent the array value.", "explanation": "The amount of memory required to represent an array value is larger than the maximum allowed for the system.", "response": "Possible solutions may include: Correct the statement that is attempting to create the array value Reduce the number of elements in the array or the sizes of some of the elements Increase the value of APPLHEAPSZ or APPL_MEMORY if they are not set to AUTOMATIC Increase the amount of physical memory available to the system. sqlcode :  -20442 sqlstate :  57011", "version": "12.1"}
{"id": "SQL20443N", "message": "The value for attribute attribute-name cannot exceed length .", "explanation": "An attribute specified for a trusted context or workload definition is too long. Attribute attribute-name was specified, but the value exceeds the maximum\n\tlength of length .", "response": "Specify a valid value with a length no longer than length . sqlcode :  -20443 sqlstate :  42907", "version": "12.1"}
{"id": "SQL20445N", "message": "The security label name name is not valid as specified.", "explanation": "In the context where it is specified, the security label name must be explicitly qualified with an\n\texisting security policy name.", "response": "Provide a security label name that is explicitly qualified with an existing security policy name. sqlcode :  -20445 sqlstate :  42704", "version": "12.1"}
{"id": "SQL20447N", "message": "Format string format-string is not valid for the function-name function.", "explanation": "The given format string format-string is invalid for the function named function-name . The function identified as function-name could be VARCHAR_FORMAT or TIMESTAMP_FORMAT, even if the name used to invoke the function was TO_CHAR, TO_DATE, or TO_TIMESTAMP. This message is returned when there is one of the following problems with the format-string argument: There are unsupported format elements. The format does not contain a format element, is the empty string, or is all blanks. A format element is specified more than once. The length of the format string argument exceeds the maximum allowable length. There are unsupported separator characters. There are too many format elements. A prefix or suffix format element is specified in the wrong place in the string. There are multiple format elements that represent the same component.  For example, the TIMESTAMP_FORMAT function YYYY and YY (format element to indicate the YEAR) must not both be specified in the format string. The statement cannot be processed.", "response": "Change the format string argument and call the function-name function again. sqlcode :  -20447 sqlstate :  22007", "version": "12.1"}
{"id": "SQL20448N", "message": "string-expression cannot be interpreted using format string format-string for the TIMESTAMP_FORMAT function.", "explanation": "The TIMESTAMP_FORMAT function was invoked with string-expression and format-string .\n\tThe name used to invoke the function could also be TO_DATE or TO_TIMESTAMP. The value string-expression cannot be interpreted\n\twith the format string format-string to produce a timestamp value. This error can occur for any of the following reasons: string-expression is too short for the specified format string string-expression is too long for the specified format string string-expression does not conform to the template specified in the format string. For example: too many digits were specified in string-expression for the corresponding format element in the format string, such as in the specific\n\tcase where 92007 is not a valid value for YYYY a value in string-expression is not valid for the corresponding format element in the format string,\n\tsuch as in the specific case where 45 is not a valid value for DD The statement cannot be processed.", "response": "Change the format string argument of the TIMESTAMP_FORMAT function. For more information, see the TIMESTAMP_FORMAT function in the SQL Reference. sqlcode :  -20448 sqlstate :  22007", "version": "12.1"}
{"id": "SQL20449N", "message": "Tree element element-value is not valid where specified.", "explanation": "The tree element element-value is an existing element in the tree, but is not valid where it is specified in the statement. The tree structure of the tree component must be maintained. For example, in an ALTER SECURITY LABEL COMPONENT statement, the element-name specified in the OVER clause of the ADD ELEMENT clause is not an immediate child element of the tree element specified immediately after the UNDER keyword.", "response": "Specify a valid tree element that would maintain the tree structure. For example, only specify existing tree elements that are immediate children elements of the tree element specified immediately after the UNDER keyword. sqlcode :  -20449 sqlstate : 428H3", "version": "12.1"}
{"id": "SQL20450N", "message": "Recursion limit exceeded within a hierarchical query.", "explanation": "Hierarchical queries using the CONNECT BY clause are limited to a recursive\n\tdepth of 64 levels. The query has exceeded this level.", "response": "Validate the correctness of the START WITH and CONNECT BY clauses.\n\tIf recursions deeper than 64 levels are expected, rewrite the query using a\n\trecursive common table expression. Recursive common table expressions support\n\tarbitrary recursive depth. sqlcode :  -20450 sqlstate :  54066", "version": "12.1"}
{"id": "SQL20451N", "message": "Cycle detected in a hierarchical query.", "explanation": "The hierarchical query using the CONNECT BY clause has found a row which is a\n\tdirect or indirect parent to itself, given the CONNECT BY search condition. The statement cannot be processed.", "response": "Validate the correctness of the CONNECT BY clause, paying particular attention to the\n\tPRIOR operator. If no cycles are expected, validate that the result table provided by the FROM clause\n\tdoes contain cyclic data based on the search condition specified in the CONNECT BY clause. If the presence of cycles is expected, add the NOCYCLE keyword to the CONNECT BY clause. For example: SELECT PK FROM T START WITH PK = 5\n\t\tCONNECT BY NOCYCLE PRIOR PK = FK Copy to clipboard sqlcode :  -20451 sqlstate :  560CO", "version": "12.1"}
{"id": "SQL20452N", "message": "Hierarchical query construct name is used out of context.", "explanation": "One of the following constructs has been found outside of the context of a hierarchical query: the LEVEL pseudocolumn the PRIOR or CONNECT_BY_ROOT unary operator the SYS_CONNECT_BY_PATH() function the ORDER SIBLINGS BY clause The reason can be one of the following: Within the subselect where name is specified no CONNECT BY clause is present.\n\tNote that name cannot be correlated. ORDER SIBLINGS BY has been specified, but there is a DISTINCT, GROUP BY\n\tor HAVING clause present which has destroyed the partial order provided by\n\tthe hierarchical query One of the arguments of name is an aggregate function or an OLAP function name is itself an argument to a hierarchical query construct PRIOR has been specified outside of the context of a CONNECT BY clause name has been specified in an implicit join predicate in the WHERE clause name has been specified in the START WITH clause. The statement cannot be processed.", "response": "If no hierarchical query is intended and name is LEVEL, validate that\n\tcolumns or variables matching name do exist and can be resolved within the query.\n\tThese identifiers are considered pseudocolumns only after the usual identifier\n\tresolution has failed. Verify that the CONNECT BY clause is present within the subselect containing name When combining aggregate functions and hierarchical queries, consider using name as an argument to the aggregate function instead of the reverse.\n\tFor example, use MAX(CONNECT_BY_ROOT name ) instead of\n\tCONNECT_BY_ROOT MAX( name ) Remove name from the query. sqlcode :  -20452 sqlstate :  428H4", "version": "12.1"}
{"id": "SQL20453N", "message": "The task task-name cannot be removed because it is currently executing.", "explanation": "An attempt to remove task task-name failed because it is currently executing.", "response": "Wait until the task completes and then use the SYSPROC.ADMIN_TASK_REMOVE procedure to remove the task. The SYSTOOLS.ADMIN_TASK_STATUS view\n\tcan be used to check the execution status of the task. sqlcode :  -20453 sqlstate :  5UA01", "version": "12.1"}
{"id": "SQL20454N", "message": "Invalid use of an outer join operator. Reason code = reason-code .", "explanation": "The outer join operator (specified as \"(+)\") was used incorrectly in an SQL statement.\n\tThe meaning of the invalid use is given by the reason code reason-code . 1 The outer join operator is used in a subselect that uses the JOIN syntax in the FROM clause. 2 The outer join operator is used in an AND-factor that has a correlated reference to another subselect. 3 The outer join operator is used on columns from more than one table-reference within an AND-factor. 4 The outer join operator is used in an AND-factor that references columns from more than two table-references. 5 The outer join operator is missing from some column references for the NULL-producer within an AND-factor. 6 The outer join operator is specified in an AND-factor where the column references are from only one table-reference and there are no other\n\tAND-factors that perform an outer join using the same NULL-producer table-reference. 7 The same table-reference is used as the NULL-producer in more than one outer join. 8 The same table-reference is used as the NULL-producer and the outer table in separate outer joins that form a cycle. 9 The outer join operator is used with an identifier that is not the name of a column. The identifier could be a global variable, local variable, transition variable, or parameter name. The statement cannot be processed.", "response": "Replace the use of the outer join operator with explicit OUTER JOIN syntax in\n\tthe FROM clause. Alternatively, correct or remove the invalid use of the\n\touter join operator based on the reason code. sqlcode :  -20454 sqlstate :  428H5", "version": "12.1"}
{"id": "SQL20456N", "message": "An insert or update operation of multiple rows failed because both DEFAULT and explicit values cannot be specified for a column defined as ROW CHANGE TIMESTAMP and GENERATED BY DEFAULT.", "explanation": "An insert or update operation on multiple rows of data attempted to insert or update rows specifying\n\tDEFAULT for some rows and explicit values for some rows for a column that is defined with both the ROW\n\tCHANGE TIMESTAMP attribute and GENERATED BY DEFAULT attribute.", "response": "Modify the statement so that only DEFAULT is specified for the column for all of the rows, or explicit\n\tvalues are provided for the column for all of the rows. Alternatively, use two statements for this operation,\n\tone to set the column values to DEFAULT, and the other to set the column values to the explicitly provided\n\tvalues. sqlcode :  -20456 sqlstate :  560CP", "version": "12.1"}
{"id": "SQL20457N", "message": "The procedure procedure-name has encountered an unsupported version, version , for parameter number .", "explanation": "The version, version , specified for the parameter in ordinal position number is not supported\n\tby the procedure procedure-name .", "response": "Call the procedure and specify a supported version number for the parameter. The highest supported version number for the parameter can be obtained by calling the\n\tprocedure and specifying NULL for the value of this parameter. sqlcode :  -20457 sqlstate :  38554", "version": "12.1"}
{"id": "SQL20458W", "message": "The procedure procedure-name has encountered an internal parameter processing error in parameter number1 . The value for parameter number2 contains further information about the error.", "explanation": "The format or content of the parameter in ordinal position number1 in the call to the procedure procedure-name is invalid. The output parameter specified in ordinal position number2 contains information on how to respond to the error.", "response": "Use the information in the output parameter specified in ordinal position number2 to correct the format or content of\n\tthe parameter value and call the procedure again. sqlcode :  +20458 sqlstate :  01H54", "version": "12.1"}
{"id": "SQL20459W", "message": "The procedure procedure-name has encountered an internal processing error. The value for parameter number contains further information about the error.", "explanation": "An error occurred when the procedure procedure-name was processing a request. The output parameter specified in ordinal\n\tposition number contains information on how to respond to the error.", "response": "Use the information in the output parameter specified in ordinal position number to correct the error and call the procedure again. sqlcode :  +20459 sqlstate :  01H55", "version": "12.1"}
{"id": "SQL20460W", "message": "The procedure procedure-name supports a higher version, version1 , than the specified version, version2 , for parameter number .", "explanation": "A higher version, version1 , for the parameter in ordinal position number is supported by\n\tthe procedure procedure-name . The specified version, version2 , is supported for the parameter.", "response": "Check the documentation for the procedure to understand the additional features supported by the newer version of the parameter. Upgrade to the current version to\n\ttake advantage of these additional features. sqlcode :  +20460 sqlstate :  01H56", "version": "12.1"}
{"id": "SQL20461W", "message": "The procedure procedure-name returned output in the alternate locale, locale1 , instead of the locale, locale2 , specified in parameter number .", "explanation": "The locale, locale2 , specified in the parameter in ordinal position number was not\n\tavailable for the output of the procedure procedure-name . The output is returned using locale locale1 .", "response": "Install the message file support on the server for the specified locale, locale2 , or specify a supported locale. sqlcode :  +20461 sqlstate :  01H57", "version": "12.1"}
{"id": "SQL20462W", "message": "Unable to return distinct row change columns. Reason code = reason-code .", "explanation": "WITH ROW CHANGE COLUMNS ALWAYS DISTINCT was specified as a prepare attribute, but the database manager is unable to return distinct row change columns. The statement was prepared successfully.", "response": "If distinct row change columns are desired, use the following reason-code values to determine what to do. 1 The prepared select-statement is not eligible for row change columns. For example, it includes a GROUP BY, join, or UNION. Modify the select-statement so that it supports the returning of distinct row change columns. 2 A column defined AS ROW CHANGE TIMESTAMP does not exist in the table. Alter the table so it has a column with the AS ROW CHANGE TIMESTAMP attribute. 3 A column defined AS ROW CHANGE TIMESTAMP was added to the table, but the table has not yet been reorganized. Reorganize the table. sqlcode :  +20462 sqlstate :  0168T", "version": "12.1"}
{"id": "SQL20464N", "message": "An attempt to revoke the SECADM authority from authorization-ID was denied because it is the only external authorization ID of type user with SECADM authority.", "explanation": "The SECADM authority must be held by at least one external authorization ID of type user, and the REVOKE statement is attempting to revoke the authority from the last authorization ID of type user that holds this authority. The statement cannot be executed. The SECADM authority is not revoked.", "response": "Grant the SECADM authority to another external authorization ID of type user to allow the SECADM authority to be revoked from authorization-ID . sqlcode :  -20464 sqlstate :  42523", "version": "12.1"}
{"id": "SQL20465N", "message": "The binary XML value is incomplete or contains unrecognized data at location position starting with the hex data text . Reason code = reason-code .", "explanation": "An error occurred when processing a binary XML value. The first eight bytes of XML data in hexadecimal at position bytes is text . If the unrecognized data is located within the last eight bytes of the binary XML data, only the data starting at location position up to the end of the binary XML data is displayed. The reason code indicates the specific problem: The XDBX data specified is incomplete. An XML sequence was specified for an insert operation and this is not supported. The XDBX data specified for an insert operation contains an unsupported tag. The referenced string ID is not previously defined. The length specified is not correct. The statement cannot be processed.", "response": "Fix the problem in your XML data or change your application to use textual XML format for data transfer. sqlcode :  -20465 sqlstate :  22541", "version": "12.1"}
{"id": "SQL20467N", "message": "The statement was not executed because an expression cannot be computed as a single value for the query. The invalid expression is in the statement near the syntax element text .", "explanation": "The expression in the statement near the syntax element text must result in a single value and must consist of one of the following elements: A constant A special register A parameter marker A variable A deterministic function with no external action An expression whose operands are any of the previously listed elements The expression cannot include any of the following elements: A column name A non-deterministic function A function with external action An expression whose operands are any of the previously listed elements", "response": "Run the statement again, after changing the expression to remove any elements that cannot be included. sqlcode :  -20467 sqlstate :  428H7", "version": "12.1"}
{"id": "SQL20469N", "message": "Row or column access control activation for table table-name has failed due to reason code reason-code .", "explanation": "Row access control cannot be activated explicitly or implicitly, or column access control cannot be activated explicitly for table table-name .  The reason code indicates more specifically why the activation failed: 37 A trigger, object-name , is defined for the table and the trigger is not defined as secure. 38 A view is defined on the table, a trigger, object-name , is defined for that view, and the trigger is not defined as secure. 40 The table is either a typed table, or a catalog table. 41 The table is referenced by a materialized query table and the materialized query table references functions with NOT SECURED attribute. 48 The table is the base table of a shadow table.", "response": "Correct the error and retry the activation of the row or column access control for the table. sqlcode :  -20469 sqlstate :  55019", "version": "12.1"}
{"id": "SQL20470N", "message": "The CREATE or ALTER statement failed because object-type1 object-name1 was not defined as secure and object-type2 object-name2 is dependent on it.", "explanation": "object-type1 object-name1 must be defined as secure because object-type2 objectname2 depends on it for row or column access control. The statement cannot be processed.", "response": "The object needs to remain secure as long as a row permission or a mask depends on it, or a materialized query table that references tables with row or column access control activated depends on it.  To complete the CREATE or ALTER statement, drop the dependent object after ensuring that it is not needed. sqlcode :  -20470 sqlstate :  428H8", "version": "12.1"}
{"id": "SQL20471N", "message": "The INSERT or UPDATE statement failed because a resulting row did not satisfy row permissions.", "explanation": "Row access control is enforced for the object of the INSERT or UPDATE operation. All attempts to INSERT or UPDATE rows in the table are checked to ensure that the resulting rows conform to the row permissions defined for that table. The statement cannot be processed. No INSERT or UPDATE operation was performed, and the contents of the table remain unchanged.", "response": "Examine the definitions of the row permissions to determine why the requested INSERT or UPDATE operation failed. This  may be a data-dependent condition. sqlcode :  -20471 sqlstate :  22542", "version": "12.1"}
{"id": "SQL20472N", "message": "The ALTER statement on the permission or mask object-name failed due to reason code reason-code .", "explanation": "The ALTER MASK or ALTER PERMISSION statement cannot be processed for one of the following reasons: 1 A default row permission cannot be altered. 2 ENABLE cannot be specified because the object is invalid. The statement cannot be processed.", "response": "1 Specify the name of a row permission or column mask that can be changed. 2 For the invalid state, disable the row permission or column mask, then drop and recreate it. sqlcode :  -20472 sqlstate :  428H9", "version": "12.1"}
{"id": "SQL20473N", "message": "The function function-name , created with the NOT SECURE option failed. The function referenced column column-name which has a column mask with column access control activated for the table.", "explanation": "The input argument of an insecure function must not reference a column which has a column mask defined with column access control activated for the table. The statement cannot be processed.", "response": "Do not reference such a column as the input argument to the function. Disable or drop the column mask then invoke the function again. sqlcode :  -20473 sqlstate :  428HA", "version": "12.1"}
{"id": "SQL20474N", "message": "The CREATE PERMISSION or CREATE MASK statement failed on the database object object-name of object type object-type due to reason code reason-code .", "explanation": "The CREATE PERMISSION or CREATE MASK statement could not be processed because the definition in the CREATE PERMISSION or CREATE MASK statement references an unsupported object.  The reason code indicates what is unsupported: 1 The table for which the row permission or the column mask is being defined 2 A table function 3 A user-defined function that is not secure 4 A function that is defined as not deterministic or is defined to have an external action 5 An OLAP specification 6 An XMLEXISTS predicate 7 A ROW CHANGE expression 8 A sequence reference 9 A created or declared temporary table 10 A table that was implicitly created for an XML column 11 A * or name.* in a SELECT clause 12 A column that is defined with a FIELDPROC 13 A language element that requires multiple encoding scheme processing 14 An ordinary SQL identifier that contains a dash (-) 16 A row permission or column mask that includes a period specification 17 A row permission or column mask that references a history table or a table that is defined within a period 18 An aggregate function that does not specify a SELECT clause 19 A nickname 20 A method 21 A pseudocolumn 22 An XMLQUERY scalar function 24 The base table of a shadow table 33 A data type of the return expression that is not the same as the data type of the column on which the column mask is defined 34 A length attribute of the return expression that is not the same as the length attribute of the column on which the column mask is defined 35 A null attribute of the return expression that is not the same as the null attribute of the column on which the column mask is defined 36 A subtype or encoding scheme that is not the same as the corresponding attribute of the column on which the column mask is defined 37 An attribute of the return expression other than the attributes covered 38 The column is referenced in an expression that defines a generated column. 51 A row permission cannot be created for a table that has a security label column. 52 A row permission cannot reference a table that has a security label column. The statement cannot be processed.", "response": "Correct the error and run the CREATE statement again. sqlcode :  -20474 sqlstate :  428HB", "version": "12.1"}
{"id": "SQL20475N", "message": "The CREATE MASK statement failed because a column mask is already defined for the specified column. Column name: column-name . Table name: table-name . Existing mask name: mask-name .", "explanation": "Only a single mask can be defined for a column. The statement cannot be processed.", "response": "Drop the existing column mask by issuing the DROP MASK SQL statement. Then create the new column mask by issuing the CREATE MASK statement again. sqlcode :  -20475 sqlstate :  428HC", "version": "12.1"}
{"id": "SQL20476N", "message": "The function-name function was invoked with an invalid format string format-string .", "explanation": "An invalid format string was specified for the function-name function. The value for function-name could be VARCHAR_FORMAT or DECFLOAT_FORMAT, even if the name used to invoke the function was TO_CHAR or TO_NUMBER. A valid format string for the VARCHAR_FORMAT function must: Have an actual length of the data type that is not greater than 254 bytes Only contain supported format elements Not result in a string with an actual length that is greater than the length attribute of the result A valid format string for the DECFLOAT_FORMAT function must: Have an actual length of the data type that is not greater than 254 bytes Contain at least one format element Only contain supported format elements The statement cannot be processed.", "response": "Change the format string argument of the function-name function. For more information, see the corresponding description of the function in the SQL Reference. sqlcode :  -20476 sqlstate :  22018", "version": "12.1"}
{"id": "SQL20477N", "message": "The function-name function is not able to use format string format-string to interpret the argument string-expression .", "explanation": "The function-name function was invoked with format-string and string-expression . The value for function-name would be DECFLOAT_FORMAT, even if the name used to invoke the function was TO_NUMBER. The value of the argument string-expression cannot be interpreted with the format string format-string to produce a DECFLOAT(34) value. This error can occur for any of the following reasons: string-expression is too long for the specified format string string-expression does not conform to the template specified in the format string; for example: Too many digits were specified in string-expression for the corresponding format element in the format string, such as in the specific case where 1234 is not a valid value for 999 A value in string-expression is not valid for the corresponding format element in the format string, such as in the specific case where $ is not a valid value for S The statement cannot be processed.", "response": "Change the arguments of the function-name function to valid values. For more information, see the corresponding description of the function in the SQL Reference. sqlcode :  -20477 sqlstate :  22018", "version": "12.1"}
{"id": "SQL20478N", "message": "The statement failed because the column mask mask-name defined for column column-name exists and the column mask cannot be applied or the column mask conflicts with the failed statement. Reason code reason-code", "explanation": "A reference to a column mask is not supported.  The cause of the error is described by the following reason codes: 22 The column column-name is input to a table or row function in the statement. Some references to the function result require the column mask mask-name be applied to the function input, and some references to the function result do not require the column mask.  If the specified column is input to a table or row function, all references to the function result must have the same mask requirement. 30 An INSERT or UPDATE operation uses a masked value returned from the column mask mask-name for column-name .  The expression specified in the THEN or ELSE clause of the column mask definition that is used to return the masked value is not a simple reference to the column column-name . For the specified INSERT or UPDATE operation, the return expression in the column mask definition must be a simple reference to the column for which the mask is defined. The statement cannot be processed.", "response": "Remove the reference to the column in the INSERT or UPDATE operation and retry the operation. Contact the Security Administrator to have the return expression in the column mask definition modified. sqlcode :  -20478 sqlstate :  428HD", "version": "12.1"}
{"id": "SQL20479N", "message": "The ALTER or RENAME statement failed on the table table-name because the table is part of row or column access control definitions. Reason code reason-code .", "explanation": "The table table-name in an ALTER or RENAME statement cannot be altered as specified for one of the following reasons: 1 The table is referenced in one or more column mask or row permission definitions. 2 A column in the table is referenced in one or more column mask or row permission definitions. The statement cannot be processed.", "response": "Drop the permission or mask and recreate them after the alter or rename operation is completed. Consider temporarily protecting the table on which the permission or mask was defined at the row level to ensure there is no window in which the table remains without row and column access control protection. sqlcode :  -20479 sqlstate :  42917", "version": "12.1"}
{"id": "SQL20480W", "message": "The newly defined object object-name is marked as invalid because it references an object object-name2 which is not defined or is invalid, or the definer does not have privilege to access it.", "explanation": "The object object-name was successfully defined, but has been marked as invalid. Objects such as views, triggers, SQL procedures, and SQL functions, can be defined successfully even though they reference an object, such as object-name2 , that is either not defined at the application server, or is in the invalid state, or the definer does not have privilege to access it. Invalid objects can be automatically revalidated implicitly the next time they are accessed or explicitly by using the procedure SYSPROC.ADMIN_REVALIDATE_DB_OBJECTS.", "response": "If object-name2 was expected to be defined or valid, then create or revalidate the object and then redefine object-name . Ensure that all objects referenced by object-name are valid and the definer has the privilege to access them before the first access to the object, so it will be revalidated successfully. sqlcode :  +20480 sqlstate :  0168Y", "version": "12.1"}
{"id": "SQL20481N", "message": "The creation or revalidation of object object-name would result in an invalid direct or indirect self-reference.", "explanation": "The definition of the object being created or replaced contains a direct or indirect reference to itself. This self-reference can either be explicit in the definition, or implicit by a reference to another object that explicitly or implicitly references the object. An object definition can only contain a valid reference to itself when it is created using the CREATE SCHEMA statement. Such an object can only be replaced or revalidated if the new definition does not contain the self-reference.", "response": "Remove the self-reference or use the CREATE SCHEMA statement to create the object that has a valid reference to itself. sqlcode :  -20481 sqlstate :  429C3", "version": "12.1"}
{"id": "SQL20482N", "message": "Revalidation failed for all objects that were specified to be revalidated. One object, object-name1 , could not be revalidated because it references object object-name2 .", "explanation": "All of the objects specified to be revalidated by the SYSPROC.ADMIN_REVALIDATE_DB_OBJECTS procedure were not able to be revalidated successfully because at least one object that they reference does not exist or continues to be invalid. One of the objects, object-name1 , could not be revalidated because it references object object-name2 which either does not exist or continues to be invalid.", "response": "Create any objects that should exist and correct any objects that continue to be invalid that are referenced by the objects to be revalidated. The SYSCAT.INVALIDOBJECTS catalog view contains information on invalid objects. sqlcode :  -20482 sqlstate :  429C4", "version": "12.1"}
{"id": "SQL20483N", "message": "Invalid use of named argument parameter-name when invoking routine routine-name . Reason code: reason_code .", "explanation": "This error can occur for the following reasons: 1 The procedure invocation of routine-name includes a named argument parameter-name which does not exist in the procedure definition.  Change parameter-name to one that exists in the procedure definition.  This reason code does not apply to Version 9.7 Fix Pack 1 or later. 2 The routine invocation of routine-name includes a named argument parameter-name which is followed by one or more unnamed arguments.   All arguments following a named argument must also be named.  Change the routine invocation so that all arguments following a named argument are also named. 3 The routine invocation of routine-name specifies the named argument parameter-name more than once (either explicitly or implicitly).  Change the routine invocation so that there is only one reference to argument parameter-name . 4 The procedure invocation of an uncataloged routine routine-name uses a named argument parameter-name .  Named parameters are not supported for uncataloged procedures.  Change the procedure invocation so that it does not include named arguments. 5 The function invocation of routine-name specifies the named argument parameter-name and the ordinal position of the corresponding parameter is different for at least two candidate functions. Function resolution cannot proceed using this argument name and the associated set of candidate functions. Change the function invocation so that it is more specific and reduces the set of candidate functions or change the set of candidate functions considered by adjusting the SQL path or replacing function definitions. The statement cannot be processed.", "response": "Correct the routine invocation in the SQL statement. sqlcode :  -20483 sqlstate :  4274K", "version": "12.1"}
{"id": "SQL20484N", "message": "The invocation of routine routine-name omits a parameter parameter-name which is not defined with a DEFAULT.", "explanation": "A parameter value is omitted from a procedure invocation.   This is invalid unless the parameter is defined to have a DEFAULT value.    The statement cannot be processed.", "response": "Correct the procedure invocation to provide a parameter value for the omitted parameter. sqlcode :  -20484 sqlstate :  428HF", "version": "12.1"}
{"id": "SQL20485N", "message": "The CREATE statement for routine routine-name defines a parameter without a DEFAULT after a parameter that has been defined with a DEFAULT.", "explanation": "During the creation of procedure routine-name, a parameter is specified without a defined DEFAULT value after the specification of a parameter with a defined DEFAULT value.  All parameters without a defined DEFAULT must be specified before those which have a defined DEFAULT value.    The statement cannot be processed.", "response": "Provide a DEFAULT value for all parameters that follow the first parameter that is defined with a DEFAULT value or re-order the parameter list such that all parameters defined with a DEFAULT value are after all parameters defined without a DEFAULT value. sqlcode :  -20485 sqlstate :  428HG", "version": "12.1"}
{"id": "SQL20490N", "message": "The statement failed because a VERSIONING clause was specified for table table-name , but the table cannot be used as a system-period temporal table. Reason code reason-code .", "explanation": "The CREATE or ALTER TABLE statement attempted to make the table into a system-period temporal table, but the  table definition is invalid for reason code indicated: 1 The table is already defined as a system-period temporal table or history table. 2 The table does not have a SYSTEM_TIME period or a transaction-start-ID column. A system-period temporal table  must have a SYSTEM_TIME period and a transaction-start-ID column. 3 The table is a materialized query table. 4 For a DB2 for z/OS server, the table has a column mask or row permission defined. 5 The transaction-start-ID column must be defined with the same data type, length, precision, and scale as the  row-begin column and row-end column of the SYSTEM_TIME period in the table. 6 The table or the associated history table has the NOT LOGGED INITIALLY attribute activated. 7 The table has a security policy associated with it. The statement cannot be processed.", "response": "Correct the syntax and resubmit the statement. sqlcode :  -20490 sqlstate :  428HM", "version": "12.1"}
{"id": "SQL20491N", "message": "The statement failed because the specification of a period period-name is not valid. Reason code reason-code .", "explanation": "The specification of a period attribute in a CREATE or ALTER statement is invalid for the reason code indicated: 1 The row-begin column name must not be the same as the row-end column name for the period. 2 The name of a column in a period must not be the same as a column used in the definition of another period  for the table. 3 The data type, length, precision, and scale for the row-begin column must be the same as for the row-end  column. 4 The type of timestamp specified for the row-begin column must be the same as the type of timestamp specified  for the row-end column. 5 For a BUSINESS_TIME period, the column must not be a column defined with a GENERATED clause. 6 For a SYSTEM_TIME period, the row-begin column must be defined as ROW-BEGIN and the row-end column must  be defined as ROW-END. The statement cannot be processed.", "response": "Correct the syntax and resubmit the statement. sqlcode :  -20491 sqlstate :  428HN", "version": "12.1"}
{"id": "SQL20494N", "message": "A public alias name, name , can be qualified only with SYSPUBLIC and not the schema name schema-name .", "explanation": "A qualified name was specified for a public alias but the qualifier was not SYSPUBLIC.", "response": "Change the two-part name to a one-part name or specify the qualifier SYSPUBLIC. If a public alias was not intended and PUBLIC was specified in the statement, remove the keyword PUBLIC. sqlcode :  -20494 sqlstate :  428EK", "version": "12.1"}
{"id": "SQL20495N", "message": "The definition of the module initialization procedure SYS_INIT is not valid. Reason code rc .", "explanation": "Initialization procedure definitions can be invalid for the following reasons: 1 The SYS_INIT procedure definition contains parameters. 2 The SYS_INIT procedure definition returns result sets. 3 The SYS_INIT procedure cannot be published.", "response": "Modify the initialization procedure definition so that it conforms to the valid syntax. sqlcode :  -20495 sqlstate :  428HP", "version": "12.1"}
{"id": "SQL20496N", "message": "The routine name cannot be invoked because it is only a routine prototype.", "explanation": "Routine name is defined as a prototype in a module, but is not fully implemented. A routine prototype with the specified routine name was found in the module, but without a routine body. The routine definition is incomplete and therefore cannot be invoked.", "response": "Alter the module and add a full routine definition. Try again. sqlcode :  -20496 sqlstate :  55019", "version": "12.1"}
{"id": "SQL20498N", "message": "The data type that was specified for the following field is not supported: field-name Specified data type type-name .", "explanation": "The data type specified for a row in the CREATE TYPE statement or CREATE HADOOP TABLE statement with columns of type array is not valid. The following restrictions apply when specifying a data type. The following data types are not supported: XML LONG VARCHAR LONG VARGRAPHIC User-defined type based on any of these previously listed types REF (an OID-column-name reference) BOOLEAN (prior to Version 9.7.5) CURSOR SYSPROC.DB2SECURITYLABEL User-defined structured data type Anchor to a table column or a variable of a data type not supported in row data types Anchor to a row of a weakly-typed cursor User-defined weakly typed distinct type that includes a data type constraint Nested types in local types declared inside an SQL routine ARRAY types or ROW types can be nested as elements in other ROW type field types, but the maximum nesting level has been exceeded. For Hadoop tables, the only supported nesting is array of rows.", "response": "Ensure that the data types specified for fields in the CREATE TYPE (row) statement, CREATE HADOOP TABLE statement with columns of type array, fields defined by the columns of the anchor table, or anchor view are supported sqlcode :  -20498 sqlstate :  429C5", "version": "12.1"}
{"id": "SQL20499N", "message": "The data type typename is not valid for the operand of the keywords predicate.", "explanation": "The predicate indicated by keywords does not support the data type typename as the operand of the predicate.", "response": "Change the operand to have a data type that is supported by the predicate or remove the predicate with the invalid operand data type. sqlcode :  -20499 sqlstate :  428HQ", "version": "12.1"}
{"id": "SQL20500N", "message": "Invalid use of row data type value in a list of values.", "explanation": "The use of a row type in a list is invalid. Invalid uses of a row variable in a list include: In a list of source variables for an assignment statement or the assignment clause of an update operation. In a list of target variables for a simple assignment statement or an assignment statement in a SELECT INTO, FETCH, or VALUES INTO statement. In a list of expressions representing a row in the VALUES clause of an insert operation. The statement cannot be executed.", "response": "Rewrite the statement so that the list contains no row variable or replace the list with a single row variable value. sqlcode :  -20500 sqlstate :  428HR", "version": "12.1"}
{"id": "SQL20501N", "message": "The specified section could not be found.  Reason code = reason-code .", "explanation": "The specified section could not be found. The reason codes are as follows: 1 The section identified by the specified executable ID could not be found in the specified source location. 2 The section identified by the specified activity information could not be located in the specified activity event monitor. 3 The section identified by the specified package and section information could not be located in the catalogs. 4 The section was not captured by the activity event monitor. 5 The identified section is not appropriate for this function. 6 The identification provided for the section is not in the correct format.", "response": "The user response corresponding to the reason code is: 1 Verify that the executable ID and section source location were specified correctly. Confirm that the section with the specified executable ID is still present in the source location. If the source location is the in-memory package cache, the section may already have been removed from the cache, in which case, no further action can be taken. 2 Verify that the specified activity information is correct and corresponds to an activity captured by the specified activity event monitor. 3 Verify that the specified package and section information corresponds to a section in the catalogs. 4 Ensure that section collection has been enabled for the activities of interest using the COLLECT ACTIVITY WITH DETAILS, SECTION clause on a workload management object. 5 Ensure that the type of section identified is appropriate for this function. Only dynamic SQL may be the target of a FLUSH PACKAGE CACHE DYNAMIC statement. 6 Ensure that the section identification is acquired from the same database as the function being called. sqlcode :  -20501 sqlstate :  4274L", "version": "12.1"}
{"id": "SQL20502N", "message": "The explain facility failed because the specified activity event monitor evmon_name is not a write-to-table event monitor.", "explanation": "The Explain facility has been invoked to provide access plan information from a section captured by an activity event monitor. The event monitor must be a write-to-table event monitor type. The activity event monitor specified as the section source location is not a write-to-table event monitor.", "response": "Provide the name of a write-to-table activity event monitor. The CREATE EVENT MONITOR ...WRITE TO TABLE statement can be used to create a write-to-table event monitor. sqlcode :  -20502 sqlstate :  55074", "version": "12.1"}
{"id": "SQL20503N", "message": "The explain facility is not supported for the specified section.  Reason code: reason-code .", "explanation": "The explain facility has been invoked to provide access plan information from a section but the section does not support this action. The reason codes indicates the reason for the failure: 1 The section specified as input was captured in a release prior to DB2 Version 9.7. The explain facility cannot be used on a section captured from a release prior to DB2 V9.7. 2 The section specified as input was captured in a release prior to the current DB2 version and the explain facility is no longer supported on sections in that release. 3 The section specified as input was captured in a release later than the current DB2 version. The explain facility cannot be used on a section captured from a release later than the current release. 4 The section specified as input is not recognized as a valid section. 5 The section does not contain access plan information. Some sections for statements such as DDL do not contain an access plan. The explain facility cannot be used on these sections. 6 The section does not exist because the statement is invalid. The statement was in error when the package was bound. 7 The section does not exist because the statement is an incremental bind statement. Incremental bind statements do not have a section stored in the catalogs. These statements are bound during the execution of an application process.", "response": "Respond according to the reason code: 1 Invoke the explain facility specifying a section captured from a valid release. 2 Invoke the explain facility specifying a section captured from a valid release. 3 Invoke the explain facility specifying a section captured from a valid release. 4 Invoke the explain facility specifying a valid section as input. 5 Invoke the explain facility specifying a section that contains access plan information. 6 If the statement is supposed to execute at this database server, correct the problem found and reissue the PRECOMPILE or BIND command using the ACTION REPLACE option. After correcting the problem, retry the explain facility. 7 To use the explain facility on the section for an incremental bind statement, follow a process similar to dynamic statements:  identify the statement in the package cache after it has been bound, and invoke the explain facility specifying the executable ID corresponding to the section for the statement. sqlcode :  -20503 sqlstate :  55075", "version": "12.1"}
{"id": "SQL20504N", "message": "The statement failed because the target object of the anchored data type is unsupported or is being used in an unsupported context.", "explanation": "An anchored data type is a data type that is defined to be the same as that of another object. If the underlying object data type changes, the anchored data type also changes.  An anchored data type can reference a variety of objects, but certain objects cannot be referenced. This message is returned when an attempt is made to reference an unsupported target in an anchored data type, or to reference a target in an anchored data type in an unsupported context.", "response": "Remove any anchored data type references that are unsupported or that are used in unsupported contexts and then reissue the statement. sqlcode :  -20504 sqlstate :  428HS", "version": "12.1"}
{"id": "SQL20505N", "message": "The WITH ORDINALITY clause is not valid with UNNEST of an associative array.", "explanation": "The WITH ORDINALITY clause must not be specified when the argument of the UNNEST table function is an associative array. An associative array is not organized according to ordinal position.", "response": "Remove the WITH ORDINALITY clause or change the argument of the UNNEST function to an ordinary array.  Try the statement again. sqlcode :  -20505 sqlstate :  428HT", "version": "12.1"}
{"id": "SQL20506N", "message": "The cursor variable could not be used in an OPEN statement in the current scope because the cursor constructor value was assigned in a different scope.", "explanation": "A cursor variable cannot be used in an OPEN statement that is outside the scope in which the cursor constructor value is assigned to the cursor variable.", "response": "Use the cursor variable in an OPEN statement that is in the same scope as the assignment of the cursor constructor to the cursor variable. sqlcode :  -20506 sqlstate :  51044", "version": "12.1"}
{"id": "SQL20507N", "message": "The query associated with the cursor variable used in an OPEN or FETCH statement recursively invokes another cursor operation using the same cursor.", "explanation": "The query associated with a cursor variable used in an OPEN or FETCH statement includes an invocation of a function that is passed a cursor variable as an argument and that cursor argument is used to perform some cursor operation within the function. If the query specifies the same variable name as specified in the cursor operation, or specifies a cursor variable that references the same cursor, then the function would be recursively operating on the same cursor. Such recursive cursor operations are not supported. The statement cannot be processed.", "response": "Change the query associated with the cursor variable used in the OPEN or FETCH statement so that the function which is passed a cursor variable argument is using a different cursor variable that does not reference the same cursor as the OPEN or FETCH statement. Try the statement again. sqlcode :  -20507 sqlstate :  24525", "version": "12.1"}
{"id": "SQL20508N", "message": "An error occurred during the revalidation of object object-name . Operation operation failed with SQLCODE sqlcode , SQLSTATE sqlstate , and message tokens token-list .", "explanation": "The processing of statement operation by the SYSPROC.ADMIN_REVALIDATE_DB_OBJECTS procedure failed. During this processing an error was encountered. The SQLCODE, SQLSTATE and  message token list (each token is separated by the vertical bar character) are provided. The  message tokens might be truncated. See the corresponding message for the sqlcode for further explanation of the error.", "response": "Check the message associated with the SQLCODE of the SQL statement that failed. Follow the action suggested by that message. sqlcode :  -20508 sqlstate :  5UA03", "version": "12.1"}
{"id": "SQL20509N", "message": "The statement was not processed because the specified alias cannot be used as the target of the statement.  Specified alias: alias-name .", "explanation": "When you create a new database object, you specify a name for the new object with the CREATE statement.  After the object is created, you can also define one or more aliases for that object. This message is returned when an alias is specified as the target of a statement when the name of the object must be specified instead of an alias.", "response": "Resubmit the SQL statement, specifying the name of the object to which the alias alias-name refers instead of specifying the alias. sqlcode :  -20509 sqlstate :  560CT", "version": "12.1"}
{"id": "SQL20510N", "message": "Invalid context of use for a compound SQL (compiled) statement.", "explanation": "Compound SQL (compiled) statements can be used in contexts including the following: As a standalone statement As the body of a SQL procedure As the body of a SQL scalar function As the body of a trigger when the trigger is not defined using the: FOR EACH STATEMENT clause REFERENCING OLD TABLE clause REFERENCING NEW TABLE clause", "response": "Do one of the following and try the request again: Remove the invalid compound SQL (compiled) statement. Replace the invalid compound SQL g(compiled) statement with a compound SQL (inlined) statement. If used within a trigger definition, modify the trigger definition so that the clause that restricts the use of the compound SQL (compiled) statement is removed. sqlcode :  -20510 sqlstate :  429C6", "version": "12.1"}
{"id": "SQL20511N", "message": "The attempt to put data into the message buffer failed because there is not enough available space in the message buffer.  Message buffer name: buffer-name .", "explanation": "The attempt to put data into the message buffer failed because the available free space in the buffer is not large enough for the data.", "response": "Respond to this message in one of the following ways: For the DBMS_OUTPUT buffer, take one of the following actions: Call the DBMS_OUTPUT.GET_LINE procedure or DBMS_OUTPUT.GET_LINES procedure to retrieve the data from the local message buffer to free up space. Increase the size of the buffer using the DBMS_OUTPUT.ENABLE procedure. For the DBMS_PIPE buffer, invoke DBMS_OUTPUT.SEND_MESSAGE function to send the content in the message buffer through the pipe. For the UTL_TCP.READ_LINE buffer, decrease the amount of data per line transmitted by the sender. sqlcode :  -20511 sqlstate :  5UA0P", "version": "12.1"}
{"id": "SQL20512N", "message": "No alert has been registered previously with the DBMS_ALERT.REGISTER procedure.", "explanation": "No alert has been registered previously with the DBMS_ALERT.REGISTER procedure for the current session.", "response": "Call the DBMS_ALERT.REGISTER procedure to register an alert. sqlcode :  -20512 sqlstate :  5UA04", "version": "12.1"}
{"id": "SQL20513N", "message": "The UTL_FILE procedure procedure-name failed to delete or rename the file file-name . Operating system error = error-text .", "explanation": "The procedure procedure-name in module UTL_FILE failed to either delete or rename the specified file, file-name , and received the error error-text from the operating system.", "response": "The system error error-text provides more details on the error situation and an appropriate response might be: Verify that the arguments of the procedure are valid. Verify that the file file-name exists and has the appropriate attributes. If renaming the file file-name , verify that the target file does not exist or set the OVERRIDE parameter to TRUE. sqlcode :  -20513 sqlstate :  5UA0C, 5UA0D", "version": "12.1"}
{"id": "SQL20514N", "message": "A UTL_SMTP module routine encountered an SMTP server error. SMTP error code = error-code .", "explanation": "A UTL_SMTP module routine encountered either a transient or permanent SMTP server error.", "response": "The error code error-code provides more details on the specific SMTP error encountered. If the error code value is in the range 400 to 499, the error is a transient error and the same request may be successful at a later time. If the error code value is in the range 500 to 599, the error is a permanent error and the exact error code can help to determine how to resolve the error situation. You might need to contact the person responsible for the SMTP server to have them fix the error with the SMTP server or you might choose a different SMTP server. sqlcode :  -20514 sqlstate :  5UA0E, 5UA0F", "version": "12.1"}
{"id": "SQL20515N", "message": "A dynamic statement name cannot be used in the cursor value constructor.", "explanation": "A dynamic statement name is specified in a cursor value constructor that: also specifies one or more named parameters in a cursor value constructor parameter list. is assigned to a variable with a strongly typed cursor data type. The statement cannot be processed.", "response": "Do one of the following and try the request again: Replace the dynamic statement name with a SELECT statement. Remove the parameter list from the cursor value constructor. Change the cursor variable to a weakly typed cursor data type. sqlcode :  -20515 sqlstate :  428HU", "version": "12.1"}
{"id": "SQL20516W", "message": "The statement compilation was successful but the access plan for this statement could not be preserved.  Reason code = reason-code .", "explanation": "The statement was compiled successfully during a BIND, REBIND, or PRECOMPILE, but the previous access plan could not be preserved. The reason codes are as follows: 101 The package was last bound or rebound in a version prior to DB2 Version 9.7. The access plan of a section generated by a version prior to DB2 Version 9.7 cannot be preserved. 102 The package was last bound or rebound in a version of the database product that is previous to the version installed, but access plans from that previous version cannot be preserved in the version installed. 103 The package was last bound or rebound in a version of the database product later than the version installed, but access plans from later versions might not be able to be preserved in earlier versions. This can occur when the installed version of the database manager is reverted back to an earlier fix pack level or version. 104 A section within the package is not recognized as a valid section. 105 The query could not be found in the existing package. New statements may have been introduced, the statement text may have changed or new host variables may have been created in the source file. 106 The internal representation of the query changed in such a way that the previous access plan is no longer applicable. Examples of changes that might have occurred are: changes to referenced database objects, changes to the database manager's configuration, and changes to the SQL query compiler. 107 The query compiler could no longer produce the same access plan due to changes in the circumstances under which a query is compiled. Examples of this are: the previous access plan accesses an index which no longer exists, or the query is being compiled at a different optimization level than before and the new optimization level does not allow the access plan strategy that was previously chosen.", "response": "In most situations, you can choose to ignore this warning because the failure to preserve the previous access plan can be the result of normal and expected database object changes or database configuration changes. In some circumstances, you might want to monitor the performance of the queries or use the explain facility to examine the access plans and compare them to the access plans generated in the past for the same query. You can then follow accepted query performance tuning and monitoring procedures to verify that the query performs well, or if necessary, improve the performance. To avoid having this warning returned, take one of the following actions based on the reason code: 101 Bind or rebind the package with a version of at least DB2 Version 9.7 before enabling the access plan reuse option of the BIND, REBIND, or PRECOMPILE command. 102 Bind or rebind the package with the installed version before enabling the access plan reuse option of the BIND, REBIND, or PRECOMPILE command. 103 Bind or rebind the package with the installed version or a version whose access plans are supported for access plan reuse by the installed version before enabling the access plan reuse option of the BIND, REBIND, or PRECOMPILE command. 104 To report this unexpected result, contact IBM software support and provide the db2diag diagnostic log files and the contents of the diagnostic directory path (as specified by the DIAGPATH database manager configuration parameter). 105 If preserving existing access plans for this query is essential, do not reformat or change the queries, or refer to new host variables. Alternatively you can confirm that the new access plan is satisfactory. 106 If preserving existing access plans for this query is essential, do not change referenced database objects or the database manager configuration (in some cases, an access plan cannot be reused because of changes to the database manager code). Alternatively you can follow accepted query performance tuning and monitoring procedures to verify that the query performs as expected. 107 If preserving existing access plans for this query is essential, do not change referenced database objects, the database manager configuration, or optimization options. Alternatively you can follow accepted query performance tuning and monitoring procedures to verify the query performs as expected or use the explain facility diagnostics to examine why the previous access plan could not be preserved. sqlcode :  +20516 sqlstate :  01602", "version": "12.1"}
{"id": "SQL20518N", "message": "The operation is invalid because the UTL_SMTP module routine routine_name is called out of sequence.", "explanation": "The SMTP protocol requires that the operations be performed in a particular order. The routine routine-name was called but the SMTP protocol requires that another operation be performed before the operation this routine was attempting to perform can complete successfully. For example, the UTL_SMTP.WRITE_DATA routine must be called after the UTL_SMTP.OPEN_DATA routine completes successfully, and the UTL_SMTP.RCPT routine must be called after the UTL_SMTP.MAIL routine completes successfully.", "response": "Refer to the SMTP protocol and ensure that the UTL_SMTP module routines are called in the correct order. sqlcode :  -20518 sqlstate :  5UA0N", "version": "12.1"}
{"id": "SQL20519N", "message": "There is no data in the local message buffer to unpack.", "explanation": "You can call one of the DBMS_PIPE.UNPACK_MESSAGE procedures to receive the next data item from the local message buffer and assign that data to a variable. This message is returned when there is no more data in the local message buffer to receive.", "response": "Change the application logic to check if DBMS_PIPE.NEXT_TYPE() returns a non-zero value before calling one of the DBMS_PIPE.UNPACK_MESSAGE procedures. sqlcode :  -20519 sqlstate :  55019", "version": "12.1"}
{"id": "SQL20521N", "message": "Error occurred processing a conditional compilation directive near string . Reason code= rc .", "explanation": "The SQL compiler was processing a statement that included conditional compilation directives. An error occurred at or near the statement text given in the token string . Possible reasons are given by the reason code. 1 A global variable reference in a selection directive is not a valid data type. Valid data types are BOOLEAN, INTEGER, or VARCHAR. 2 A global variable reference in a selection directive is not defined as a constant. 3 A global variable reference in a selection directive is defined as a constant, but requires the evaluation of an expression. 4 A constant was found that is not a BOOLEAN, INTEGER, or VARCHAR constant. 5 The search condition specifies an unsupported expression or predicate. 6 An invalid conditional compilation directive was specified. A single underscore character (or dollar character) is used as a prefix, but the characters that follow do not match a supported conditional compilation directive. 7 A conditional compilation directive was specified in a context where conditional compilation directives are not supported. 8 A new selection directive is specified in the code fragment of a selection directive. Nesting of selection directives is not supported. 9 Keywords for a selection directive are incorrectly specified. A required keyword is missing or a keyword is used in the incorrect order. 10 An inquiry directive could not be processed because the value of the SQL_CCFLAGS database configuration parameter is not valid.", "response": "Correct the error based on the reason code. 1 Change or remove the global variable reference from the selection directive or replace the global variable so that it has a supported data type. 2 Change or remove the global variable reference from the selection directive or replace the global variable so that it is defined using a CONSTANT clause. 3 Change or remove the global variable reference from the selection directive or replace the global variable so that it is defined using a CONSTANT clause with a simple literal value. 4 Replace the constant with a BOOLEAN, INTEGER, or VARCHAR constant. 5 Ensure that there are no expressions in the search condition and that only basic predicates or NULL predicates are used. Remove any unsupported expressions or predicates. 6 Ensure that the conditional compilation prefix character is used only with supported directives. If an inquiry directive was intended, the prefix character must be doubled. If use of conditional compilation was not intended, an identifier must be delimited with double quotation mark characters or have the underscore character (or dollar character) removed. 7 Ensure that the context in which the compilation directive is used is valid. Valid contexts include: SQL procedure definitions, compiled SQL function definitions, compiled trigger definitions, and PL/SQL package definitions. 8 Ensure that no selection directive is started before an already started selection directive is ended. Use separate selection directives without nesting, or make use of additional _ELSEIF or _ELSE blocks to determine the code fragments that are to be selected for compilation. 9 Check the syntax for the selection directive to ensure that each _IF and _ELSEIF is followed by a corresponding _THEN keyword. Also, ensure that the _END keyword completes the selection directive. 10 Perform the following steps: [Optional] Temporarily override the SQL_CCFLAGS database configuration parameter using the CURRENT SQL_CCFLAGS special register. Set the SQL_CCFLAGS database configuration parameter to a valid value. sqlcode :  -20521 sqlstate :  428HV", "version": "12.1"}
{"id": "SQL20522N", "message": "The statement failed because of an invalid specification of the WITHOUT OVERLAPS clause. Reason code reason-code .", "explanation": "The specification of the WITHOUT OVERLAPS clause is invalid for one of the following reasons: 1 A partitioned index must not specify BUSINESS_TIME WITHOUT OVERLAPS if the table partitioning key includes the begin column or end column of the BUSINESS_TIME period. 2 The columns of the specified period must not be specified in the constraint clause. 3 For a DB2 Database for Linux, UNIX, and Windows server, WITHOUT OVERLAPS can only be specified in a CREATE INDEX statement and only if the index is defined as UNIQUE. For a DB2 for z/OS, WITHOUT OVERLAPS can only be specified in a CREATE or ALTER INDEX statement if the index is defined as UNIQUE or UNIQUE WHERE NOT NULL. 4 A unique index must not specify BUSINESS_TIME WITHOUT OVERLAPS if the table distribution key includes the begin column or end column of the BUSINESS_TIME period. 5 The columns of the specified period must not be specified in the index specification. The statement cannot be processed.", "response": "Correct the syntax and resubmit the statement. sqlcode :  -20522 sqlstate :  428HW", "version": "12.1"}
{"id": "SQL20523N", "message": "Table table-name was specified as a history table, but the table definition is not valid for a history table. Reason code reason-code .", "explanation": "For a table specified as a history table in a CREATE or ALTER statement, the table definition is invalid for the reason code indicated: 1 The table must not be an existing system-period temporal table, history table, declared global temporary  table, created global temporary table, materialized query table, typed table, or view. For a DB2 for z/OS server, the table  must also not be an auxiliary table, clone table, table with a clone defined on it, or a table that was implicitly  created for an XML column. 2 For a DB2 for z/OS server, the table must not have an incomplete table definition. 3 For a DB2 for z/OS server, the table must be the only table in the table space. 4 The table must not contain an identity column, row change timestamp column, row-begin column, row-end column,  transaction-start-ID column, or generated expression column. 5 The table must not include a period definition. 6 The table must not be involved in any referential integrity constraints. 7 The history table must have the same number and order of columns as the table used as the system-period  temporal table. 8 The table must not contain a security label column or have a security policy associated with it. 9 For a DB2 for z/OS server, if a column of the system-period temporal table is defined as ROWID, then  the corresponding history column should be defined as ROWID with the same generation attribute  (GENERATED ALWAYS or GENERATED BY DEFAULT). 10 The corresponding columns of the system-period temporal table and associated history table must have these same  attributes: name data type length (including inline LOB length, precision, and scale) null attribute hidden attribute field procedure (DB2 for z/OS only) subtype (FOR BIT, SBCS, or MIXED DATA attribute) and CCSID 11 For a DB2 for z/OS server, the table must not have a column mask or row permission defined on it. The statement cannot be processed.", "response": "Correct the syntax and resubmit the statement. sqlcode :  -20523 sqlstate :  428HX", "version": "12.1"}
{"id": "SQL20524N", "message": "The statement failed because of an invalid period specification or period clause for period period-name . Reason code reason-code .", "explanation": "A period specification or period clause is invalid for the reason code indicated: 1 The period name was specified more than once for the table reference. 2 The SYSTEM_TIME period was specified, but the table is not a system-period temporal table. 3 The specified expression is unsupported for one of the following reasons: The expression contains an invalid operand The expression returns an unsupported data type 4 For a DB2 for LUW server, the period specification was specified with a view where the view definition  includes a compiled function or external function with a data indication other than NO SQL. 5 For a DB2 for z/OS server, an expression must not include a time zone and must not have a precision  greater than the precision of the columns of the period. 6 FOR SYSTEM_TIME was specified but the value of the CURRENT TEMPORAL SYSTEM_TIME special register is not  null and the SYSTIMESENSITIVE bind option is set to YES. 7 FOR BUSINESS_TIME was specified but the value of the CURRENT TEMPORAL BUSINESS_TIME special register is not  null and the BUSTIMESENSITIVE bind option is set to YES. 8 The period clause was specified for a table that is not an application-period temporal table, or for  a view for which an application-period temporal table is not referenced in the outermost FROM clause of the  view definition, or an instead of trigger is defined on the view. 9 A period specification or period clause was specified for a nickname or a remote object. 10 The specified expression cannot be resolved to an Iceberg table snapshot. The statement cannot be processed.", "response": "Correct the syntax and resubmit the statement. sqlcode :  -20524 sqlstate :  428HY", "version": "12.1"}
{"id": "SQL20525N", "message": "The requested action is not valid for table table-name because the table is of the wrong type. Reason code reason-code .", "explanation": "The table cannot be used as specified for the reason code indicated: 1 An ALTER TABLE statement was specified with an ADD PERIOD clause, but the table is a history table and a period cannot be defined for a history table. 2 An ALTER TABLE statement was specified with a DROP PERIOD clause, but the table is a system-period temporal table and the period cannot be dropped. 3 An ALTER TABLE statement was specified with an ALTER VERSIONING clause, but the table is not a system-period temporal table. 4 An ALTER TABLE statement was specified with a DROP VERSIONING clause, but the table is not a system-period temporal table. 5 An ALTER TABLE statement was specified with a DROP VERSIONING clause with the RESTRICT keyword, but system data versioning cannot be dropped if there are any triggers, functions, procedures, views, or materialized query tables that reference historical versions of rows in the table. 6 An ALTER TABLE statement was specified with a DROP PARTITION clause for a system-period temporal table or history table. 7 For DB2 for z/OS, an ALTER TABLE statement was specified with a ROTATE PARTITION clause for a system-period temporal table or h istory table. 8 For DB2 for z/OS, an ALTER TABLE statement was specified with an ADD CLONE clause was specified for a table that is a  system-period temporal table or a history table. 9 A TRUNCATE statement attempted to truncate a table, but the table is a system-period temporal table. 10 For DB2 for z/OS, an ALTER TABLESPACE statement attempted to alter the CCSID of a table space that contains a system-period  temporal table or history table. 11 A CREATE or ALTER TABLE statement attempted to define a referential constraint where either the parent or child table is a history table. 12 For DB2 for Linux, UNIX, and Windows, an ALTER TABLE statement with a DETACH PARTITION clause was specified for a system-period temporal table. 13 An ALTER TABLE statement with an ADD COLUMN clause was specified for a history table. 16 An ALTER TABLE statement was specified to add a generated column to a system-period temporal table. 17 For DB2 for Linux, UNIX, and Windows, an ALTER TABLE statement was specified  with ACTIVATE NOT LOGGED INITIALLY for a system-period temporal table or a history table. 18 For DB2 for Linux, UNIX, and Windows, an ALTER TABLE statement was specified  with ADD SECURITY POLICY for a system-period temporal table or a history table.", "response": "Change the statement to specify the name of table for which the action is valid, or specify a different action for the table. sqlcode :  -20525 sqlstate :  428HZ", "version": "12.1"}
{"id": "SQL20526N", "message": "The variable variable-name is the target of two or more assignments with no defined order of assignment.", "explanation": "A variable is the target of two or more assignments with no defined order of assignment.  Multiple assignments of a variable can occur when  a variable on the left hand side of a SET variable statement is also used as an output parameter to a function on the right hand side of the SET variable statement. In the following example, assume that the function my_function was declared with one OUT parameter.  The variable called my_variable is the target of two assignments in the example: CREATE VARIABLE my_variable INTEGER; SET my_variable = my_function( my_variable );", "response": "Change one or more of the variable references to a different variable. sqlcode :  -20526 sqlstate :  42810", "version": "12.1"}
{"id": "SQL20527N", "message": "The statement failed because referenced period period-name is not a period in table table-name", "explanation": "No period with the specified period-name occurs in the table table-name . The statement cannot be processed.", "response": "Verify that the period and table names are specified correctly (including any required qualifiers) in the  SQL statement. Resubmit the statement. sqlcode :  -20527 sqlstate :  4274M", "version": "12.1"}
{"id": "SQL20528N", "message": "The target of the data change operation is a table table-name , which includes a period period-name . The data change operation failed because a row that it attempted to modify was also modified by another transaction.", "explanation": "Table table-name is a system-period temporal table. The table includes a period period-name .  The requested data change operation attempted to change a row that has been modified by another transaction, and would result in a situation where the row-begin column value of the associated row in the history table is greater than the end column value. This can occur for one of the following reasons: Another transaction updated or inserted a row after the transaction of the failing statement had started. This resulted in a later timestamp value in the row begin column than the failing statement would use when it updated or deleted that same row. Data has been loaded into the system-period temporal table with values for the row begin column that override the generated values. The row begin column value that was loaded is in the future relative to the timestamp that the failing transaction would use. The requested operation cannot be performed.", "response": "Retry the statement. The systime_period_adj configuration parameter can be set to allow the affected values to be adjusted so that they are unique. Contact the system administrator. sqlcode :  -20528 sqlstate :  57062", "version": "12.1"}
{"id": "SQL20529N", "message": "The argument to the WRAP function or to the CREATE_WRAPPED procedure is not valid.", "explanation": "The argument to the WRAP function or to the CREATE_WRAPPED procedure is not a valid SQL PL or PL/SQL statement.", "response": "Ensure that the argument to the WRAP function or to the CREATE_WRAPPED procedure is valid. If the statement is already wrapped by an unsupported application server, it cannot be processed using this version of DB2. sqlcode :  -20529 sqlstate :  5UA0O", "version": "12.1"}
{"id": "SQL20530N", "message": "An obfuscated statement is not valid. Reason code= rc .", "explanation": "An error occurred processing a data definition statement that includes the WRAPPED clause. Possible reasons are: 1 The statement was wrapped on a platform or version that is not supported. 2 The obfuscated portion of the statement is corrupted.", "response": "Ensure that the statement was wrapped on a supported platform, and that the statement is not corrupted. sqlcode :  -20530 sqlstate :  42638", "version": "12.1"}
{"id": "SQL20531N", "message": "The version number flowed-version specified in a binary XML value is not supported. The highest supported version is highest-version .", "explanation": "The version specified does not support binary XML format.  A value of 0 (zero) for the highest supported version indicates that the platform does not support binary XML format. A value of *N for the version number specified indicates that the version cannot be determined, because the server could not read binary XML format.", "response": "Use a server that supports binary XML format. sqlcode :  -20531 sqlstate :  22544", "version": "12.1"}
{"id": "SQL20532N", "message": "The command, SQL statement, or API function call failed because the command, SQL statement or API function is discontinued.  Command, SQL statement, or API function name: command-SQL-or-function-name .", "explanation": "This message is returned when an attempt is made to run a command, SQL statement, or call to an API function that has been discontinued.", "response": "Use other commands, SQL statements, or API functions to accomplish the same task. Update automated scripts and applications to use different commands, SQL statements, or API functions to accomplish the same task. sqlcode :  -20532 sqlstate :  560CZ", "version": "12.1"}
{"id": "SQL20533N", "message": "The SELECT statement failed because an unsupported data type was specified in the typed-correlation clause.  Column with unsupported data type: column-name .", "explanation": "The typed-correlation clause in the sub-select of a SELECT statement is used to define the appearance and contents of the table generated by a generic table function. This message is returned when the data type specified in the typed-correlation clause is not supported.", "response": "Execute the SELECT statement again, specifying only supported data types in the typed-correlation clause. sqlcode :  -20533 sqlstate :  429BB", "version": "12.1"}
{"id": "SQL20534W", "message": "The schema schema-name includes one or more tables with the attribute data-capture-option1 which is different from the schema attribute data-capture-option2 .", "explanation": "The DATA CAPTURE setting for one or more tables in the schema are different from the schema-level setting. You can set different DATA CAPTURE attribute at the table and schema levels because the setting of the DATA CAPTURE attribute for a table is independent of the setting at the schema level. After the DATA CAPTURE attribute is set at the schema level, newly created tables inherit the schema-level setting if one is not specified at the table level.", "response": "To find the list of tables that have DATA CAPTURE attribute set to CHANGES, issue the following query: SELECT TABNAME, TABSCHEMA FROM SYSCAT.TABLES\n\t  WHERE TYPE IN ('T','S','L')\n\t\tAND DATACAPTURE <> 'N' Copy to clipboard To find the list of tables that have DATA CAPTURE attribute set to NONE, issue the following query: SELECT TABNAME, TABSCHEMA FROM SYSCAT.TABLES\n\t  WHERE TYPE IN ('T','S','L')\n\t\tAND DATACAPTURE = 'N' Copy to clipboard sqlcode :  +20534 sqlstate :  01696", "version": "12.1"}
{"id": "SQL20535N", "message": "The data change operation operation is not supported for the target object object-name because of an implicit or explicit period specification involving period-name . Reason code: reason-code .", "explanation": "The data change operation is not supported because the target of the operation references a temporal table and a period specification was specified. The period specification was either implicitly specified by using a special register, or explicitly specified in the fullselect specified as the target. More information is provided by the reason code indicated: 1 The CURRENT TEMPORAL SYSTEM_TIME special register contains a non-null value and the target of the data change operation is a system-period temporal table (directly or indirectly). The data in a system-period temporal table cannot be changed when a period specification is in effect. The target of the data change statement is one of the following: a system-period temporal table a view that is defined with an outer fullselect that references a system-period temporal table in the FROM clause (directly or indirectly) and that does not have an INSTEAD OF trigger defined for the data change operation a fullselect that references a system-period temporal table in the FROM clause (directly or indirectly) 2 The CURRENT TEMPORAL SYSTEM_TIME special register contains a non-null value and the target of the data change statement is a view defined with the WITH CHECK OPTION. The data change statement cannot be processed because the view definition includes a WHERE clause containing one of the following syntax elements: a subquery that references a system-period temporal table (directly or indirectly) an invocation of an SQL routine that has a package associated with it an invocation of an external routine with data access indication other than NO SQL 3 The target of the data change statement is specified as a fullselect that references a view in the FROM clause which is followed by a period specification for SYSTEM_TIME. The referenced view is defined with the WITH CHECK OPTION. The data change statement cannot be processed because the view definition includes a WHERE clause containing one of the following syntax elements: a subquery that references a system-period temporal table (directly or indirectly) an invocation of an SQL routine that has a package associated with it an invocation of an external routine with data access indication other than NO SQL 4 The CURRENT TEMPORAL BUSINESS_TIME special register contains a non-null value and the target of the data change statement is a view defined with the WITH CHECK option.  The data change statement cannot be processed because the view definition includes a WHERE clause containing one of the following syntax elements: a subquery that references an application-period temporal table (directly or indirectly) an invocation of an SQL routine that has a package associated with it an invocation of an external routine with data access indication other than NO SQL 5 The target of the data change statement is specified as a fullselect that references a view in the FROM clause which is followed by a period specification for BUSINESS_TIME. The referenced view is defined with the WITH CHECK OPTION. The data change statement cannot be processed because the view definition includes a WHERE clause containing one of the following syntax elements: a subquery that references an application-period temporal table (directly or indirectly) an invocation of an SQL routine that has a package associated with it an invocation of an external routine with data access indication other than NO SQL The statement cannot be processed.", "response": "Take an appropriate action for the reason-code: 1 Set the CURRENT TEMPORAL SYSTEM_TIME special register to the null value and try the data change operation again. If the statement is included in an application package that should not be sensitive to the setting of the CURRENT TEMPORAL SYSTEM_TIME special register, then bind the package using SYSTIMESENSITIVE NO. 2 Set the CURRENT TEMPORAL SYSTEM_TIME special register to the null value and try the data change operation again. If the statement is included in an application package that should not be sensitive to the setting of the CURRENT TEMPORAL SYSTEM_TIME special register, then bind the package using SYSTIMESENSITIVE NO. Another possible alternative could be to replace the reference to the view with another view that is defined without the WITH CHECK OPTION if the associated checking of data changes is not required. 3 Remove the period specification in the target fullselect of the data change operation. Another possible alternative could be to replace the reference to the view with another view that is defined without the WITH CHECK OPTION if the associated checking of data changes is not required. 4 Set the CURRENT TEMPORAL BUSINESS_TIME special register to the null value and try the data change operation again. If the statement is included in an application package that should not be sensitive to the setting of the CURRENT TEMPORAL BUSINESS_TIME special register, then bind the package using BUSTIMESENSITIVE NO. 5 Remove the period specification in the target fullselect of the data change operation and use explicit predicates in the WHERE clause of the fullselect to specify the target rows for the data change operation. sqlcode :  -20535 sqlstate :  51046", "version": "12.1"}
{"id": "SQL20536N", "message": "The operation cannot be processed because it involves a text index. Reason code = reason-code .", "explanation": "The operation either targets a text index directly or has a text index that depends on the result of the operation. The operation cannot proceed because of the text index. The specific reason is indicated by the reason code. 1 A text index exists on the table that the operation requested to drop. 2 A text index is the target of a RUNSTATS command. 3 A text index is the target of a REORG command. 4 A text index exists on the nickname that the operation requested to drop.", "response": "1 If the table must be dropped, then first drop the the text indexes on the table. 2 Remove the reference to the text index from the RUNSTATS command. Statistics cannot be collected on text indexes. 3 Remove the reference to the text index from the REORG command. Text indexes cannot be reorganized. 4 If the nickname must be dropped, then first drop the the text indexes on the nickname.", "version": "12.1"}
{"id": "SQL20537W", "message": "The precompiler detected a combination of arrays with different cardinalities in the same SQL statement.  The application was compiled to populate all arrays in the applicable statement with the minimum cardinality: minimum_cardinality", "explanation": "The COMPATIBILITY_MODE ORA precompiler option allows the use of host variable arrays, indicator arrays, or a structure array in an embedded SQL statement.   When multiple arrays that are declared with different cardinalities are used in the same SQL statement, all the arrays are precompiled with the same cardinality. This warning message is returned when the COMPATIBILITY_MODE ORA precompile option is specified and there are arrays in an SQL statement that are declared with different cardinalities.  The statement was successfully compiled, but all the arrays were precompiled with the same cardinality.", "response": "To avoid this warning during the precompile process, use the same cardinality for all arrays that are used in the same SQL statement. sqlcode :  +20537 sqlstate :  01697", "version": "12.1"}
{"id": "SQL20538W", "message": "A permission or mask was changed for the table named table-name . This change might require a change to the permissions or masks of a materialized query table (MQT) based on this table to maintain the security of the data.", "explanation": "A permission or mask was created, altered, or dropped for table table-name . At least one MQT is based on this table that has access controlled using masks or permissions, other than the default permission. The MQT includes data from the base table table-name . In order to maintain data security, the access control change made to the base table of the MQT must be reflected in the permissions and masks of the MQT.", "response": "Verify the permissions and masks of each MQT that is based on table table-name is consistent with the access control on the base table table-name . sqlcode :  +20538 sqlstate :  01698", "version": "12.1"}
{"id": "SQL20539N", "message": "The query failed because a negative value or the null value is used in the clause keywords.", "explanation": "A query can include a FETCH FIRST clause or a LIMIT clause to control the number of rows that are returned from a query. A query can also include an OFFSET clause to begin fetching rows starting at a specified row number. The row count value for these clauses can be specified as an expression that is evaluated at query open time and must result in a positive numeric constant value for the query. The expression specified for the indicated clause returns a negative value or the null value.", "response": "Change the expression so that it returns a positive number and reissue the query. sqlcode :  -20539 sqlstate :  2201W, 2201X", "version": "12.1"}
{"id": "SQL20540N", "message": "An autonomous transaction executing a procedure has been terminated abnormally. Routine name: routine-name . Specific name: specific-name . Reason code: reason-code .", "explanation": "A procedure can be defined as AUTONOMOUS, to make its execution occur within a separate autonomous transaction. The execution of the procedure may encounter an error that required the procedure to terminate and the autonomous transaction to be rolled back without rolling back the parent or calling transaction. This message is returned when the autonomous procedure terminated with an error that normally causes a transaction to roll back. In this case, the autonomous transaction for the autonomous procedure is rolled back but without affecting the calling transaction. Possible reason codes for this message are the SQLCODEs that terminated the autonomous procedure.", "response": "Check the message associated with the SQLCODE in the reason code and use the information there to determine the reason that the autonomous procedure was terminated. Correct any problems in the autonomous procedure or the calling application and run the procedure again. sqlcode :  -20540 sqlstate :  560D2", "version": "12.1"}
{"id": "SQL20541N", "message": "An error code was received from an in-database analytics provider. Error code: error-code . Provider name: provider-name . Associated text and tokens: tokens .", "explanation": "You can perform in-database analytics using an embedded analytics provider. While referencing an in-database analytics provider, an unexpected error code was received from the specified provider.", "response": "Respond to this error by performing the following troubleshooting steps: Ensure that the process for the provider is available. Identify and correct the root cause of the problem by locating the appropriate message text and corrective action for the specified error at the provider. Check any appropriate diagnostic logs that are generated by the provider. sqlcode :  -20541 sqlstate :  560D4", "version": "12.1"}
{"id": "SQL20542N", "message": "The statement was not executed because the connection to the database server was dropped, and the automatic client reroute (ACR) feature failed to successfully re-execute the statement.", "explanation": "The ACR feature attempts to reconnect to the database when a connection to a database server is dropped.  This message is returned when the ACR feature is unable to seamlessly re-execute the statement after a successful reconnect. When this message is returned, the database connection is in an open state.", "response": "Execute the statement again. If the error persists, perform the following troubleshooting steps: Collect information from diagnostic logs on the client and the server. Investigate why the connection to the database server is being lost. sqlcode :  -20542 sqlstate :  54068", "version": "12.1"}
{"id": "SQL20544N", "message": "The statement failed because an error was encountered while the ANALYZE_TABLE expression was being processed. Analytics provider name: provider-name . Reason code: reason-code .", "explanation": "You can use the ANALYZE_TABLE expression to invoke an analytics routine from the provider. The routine performs analytics processing based on the input table and returns a set of rows as output. Details about routine implementation, such as information about the analytics provider, the name of the routine to use, and the table in which the routine source is located, are specified in an implementation string. The IMPLEMENTATION parameter passes the implementation string to the ANALYZE_TABLE expression. This message is returned when the specified routine cannot be found or loaded for the ANALYZE_TABLE expression. In general, this message is returned when there is a problem with the routine source table or with the routine source. The reason code indicates the cause of the problem more specifically: 1 The format or content of the implementation string is not valid. It must begin with PROVIDER=xxx, where xxx identifies a supported provider. This must be followed by name=value pairs for the specified provider, each pair ending with a semicolon. 2 The specified routine source table does not contain the minimum required columns, correctly defined for the provider. If PROVIDER=SAS is specified, there are four minimum required columns: \"MODELNAME\" \"MODELDS2\" \"MODELFORMATS\" \"MODELMETADATA\" 3 The specified routine source table is not a base table. The name of the routine source table must not identify a global temporary table, a view, a common table expression, or a nickname. 4 The combined, total length of a set of the columns is too long in a row of the specified routine source table. If PROVIDER=SAS is specified, the columns in the set are named \"MODELDS2\", \"MODELFORMATS\", and \"MODELMETADATA\". 5 In one or more rows of the specified routine source table, the contents of one or more of the columns are empty, but not null. If PROVIDER=SAS is specified, it could be the column named \"MODELDS2\". 6 The specified routine source name could not be found in the specified routine source table. 7 The routine source table does not include a required primary key constraint. If PROVIDER=SAS is specified, the MODELNAME column must be defined as the primary key. 8 The specified provider is not supported.", "response": "Respond to this message according to the reason code: 1 Specify a correctly formatted implementation string with content that is required by the specified provider. 2 Modify the definition of the routine source table so that the table contains the minimum required columns. 3 Correct the implementation string to specify a routine source table name that identifies a base table. 4 Modify the definition of the routine source table so that the combined total length of the set of columns does not exceed the maximum length permitted in a routine source table. 5 Review the contents of the columns that cannot have empty string values in all rows of the routine source table. If PROVIDER=SAS is specified, correct any rows that contain empty (zero-length) strings in the column named \"MODELDS2\". 6 Correct the implementation string to specify a valid routine source table and routine source name. 7 Modify the routine source table to include the required primary key constraint. 8 Specify a supported provider in the implementation string. sqlcode :  -20544 sqlstate :  5507A", "version": "12.1"}
{"id": "SQL20545N", "message": "The statement failed because a connection to the in-database analytics provider could not be established or maintained.  Analytics provider name: provider-name .  Reason code: reason-code .", "explanation": "You can perform in-database analytics using an embedded analytics provider.  To successfully perform analytics using an embedded provider, the database manager must establish and maintain a connection with the provider. This message is returned when the database manager encounters an error while attempting to communicate with an embedded provider.  The reason code indicates the source of the problem: 1 The embedded provider process is not up and running. 2 An attempt to connect to the embedded provider timed out. 3 The database manager is unable to allocate enough shared memory from the FMP memory set to communicate with the embedded provider.", "response": "In general, respond to this message by taking the following actions: Collect diagnostic information from the db2diag log files. Troubleshoot the installation and configuration of the embedded analytics provider. More specifically, when the provider name is 'SAS', respond to this message according to the reason code: 1 Respond to reason code 1 according to the value of the ENABLE_SAS_EP parameter of the DB2_SAS_SETTINGS registry variable: If ENABLE_SAS_EP is set to TRUE, wait for the instance to automatically restart the embedded process.  If the process does not restart after approximately 10 seconds, collect the following diagnostic information and troubleshoot the embedded analytics provider: The values of the parameters of the DB2_SAS_SETTINGS registry variable. Related information in the db2diag diagnostic log files. If ENABLE_SAS_EP is not set or if ENABLE_SAS_EP is set to FALSE, manually start up the embedded process by running the db2ida command. 2 Respond to reason code 2 by performing the following steps: Wait until the embedded process is restarted. Rerun the query. If the same error occurs again, collect the following diagnostic information and troubleshoot the embedded analytics provider: The values of the parameters of the DB2_SAS_SETTINGS registry variable. Related information in the db2diag diagnostic log files. 3 Respond to reason code 3 by performing one of the following actions: Wait for some queries to finish processing and then rerun the failed query. Increase the amount of memory in the FMP memory set by increasing the DB2_FMP_COMM_HEAPSZ registry variable. sqlcode :  -20545 sqlstate :  57065", "version": "12.1"}
{"id": "SQL20546N", "message": "The statement cannot be processed because it violates one of the restrictions for using the ANALYZE_TABLE expression.", "explanation": "You can use the ANALYZE_TABLE expression to invoke an analytics routine from the provider. The routine performs analytics processing based on the input table and returns a set of rows as output. Details about routine implementation, such as information about the analytics provider, the name of the routine to use, and the table in which the routine source is located, are specified in an implementation string. The IMPLEMENTATION parameter passes the implementation string to the ANALYZE_TABLE expression. This message is returned when an attempt is made to run a statement that uses the ANALYZE_TABLE expression in a way that is not supported.", "response": "Rewrite the application so that none of the ANALYZE_TABLE expression restrictions is violated. sqlcode :  -20546 sqlstate :  429CA", "version": "12.1"}
{"id": "SQL20547N", "message": "The statement failed because the target of an assignment is a read-only variable. Variable name: variable-name .", "explanation": "Global variables can generally be used as the target of an assignment in various SQL statement with the appropriate write access. However, the definition of some global variables makes them read only. This applies to some built-in global variables and also to user-defined variables that are defined using the CONSTANT clause, A variable that is read only cannot be used in an SQL statement as the target of an assignment.", "response": "Change the name of the target variable so that it does not refer to a read-only variable. sqlcode :  -20547 sqlstate :  428I3", "version": "12.1"}
{"id": "SQL20548N", "message": "The statement failed because a column of the input table of an ANALYZE_TABLE expression has an unsupported data type. Unsupported type: type-name .", "explanation": "You can use the ANALYZE_TABLE expression to invoke an analytics routine from the provider. The routine performs analytics processing based on the input table and returns a set of rows as output. Details about routine implementation, such as information about the analytics provider, the name of the routine to use, and the table in which the routine source is located, are specified in an implementation string. The IMPLEMENTATION parameter passes the implementation string to the ANALYZE_TABLE expression. The input table of an ANALYZE_TABLE expression can be specified using a table name, a view name or the name of a common table expression specified at the beginning of the query. This message is returned when a column of the specified input table is of a type that is not supported.", "response": "Respond to this error in one of the following ways: Change the input table to remove the column with the unsupported data type or cast the column to a valid data type. If the input table is specified with a table name or a view name, a column can be removed or cast to another data type by specifying a common table expression at the beginning of the query and using the name of the common table expression as the input table to the ANALYZE_TABLE expression. sqlcode :  -20548 sqlstate :  428H2", "version": "12.1"}
{"id": "SQL20549N", "message": "The statement cannot be precompiled  because an indicator variable array contains fewer elements than its the corresponding host variable array. Indicator variable array name: var_name1 . Required array size: cardinality_of_array2 .", "explanation": "An indicator variable contains a small integer value that indicates some information about an associated host variable.  For example you can use an indicator variable to indicate that the associated host variable contains a null value. In embedded SQL applications, when parameters of type array are passed to CALL statements, information about the contents of those arrays can be stored in corresponding indicator variable arrays.  When an indicator variable array is specified for an array parameter, the size of the indicator variable array must be greater than or equal to the size of the corresponding host variable array.", "response": "Modify the embedded SQL application to declare any indicator variable array as the same size as, or larger than, the associated host variable array size. Recompile and rerun the embedded SQL application.", "version": "12.1"}
{"id": "SQL20551N", "message": "Constructing an associative array failed because the input data includes at least one duplicate array index value. Duplicated index value: value .", "explanation": "In an associative array, each element is associated with a unique index value. When constructing an array using an ARRAY_AGG aggregate function, if more than one element is associated with the same array index value, only one of the element values can be included in the array. This potential loss of element data is the reason that index values must be unique within the input data used to construct an associative array.", "response": "Change the input data so that there are no duplicate array index values. When using an ARRAY_AGG aggregate function, this might require adding predicates to the query that produces the aggregation grouping sets to ensure that none of the rows include duplicate values for the array index expression argument of the ARRAY_AGG. sqlcode :  -20551 sqlstate :  22545", "version": "12.1"}
{"id": "SQL20552N", "message": "The cast or assignment failed because the value does not conform to the data type constraint of the user-defined type.  User-defined type: type-name .  Value: value .", "explanation": "A user-defined distinct type can include a NOT NULL constraint and a CHECK constraint that limit the valid values for the data type. These data type constraints can be violated when a value is cast to the user-defined type or a value is assigned to a variable, parameter, or column defined with that user-defined type. An assignment can also happen implicitly using the default for the variable, parameter, or column.", "response": "Ensure that the values being assigned or cast are valid for the data type constraints of the user-defined type by taking actions such as the following actions: Change the value to conform to the data type constraints. Change the data type to a different data type. This might be most applicable when performing an explicit cast to a user-defined type. If the invalid value is the result of using a default, change the definition of the variable, parameter, or column to use a default value that is valid for the user-defined type. Change the definition of the user-defined type by dropping the type and creating it with different data type constraints that would allow the value. sqlcode :  -20552 sqlstate :  23528", "version": "12.1"}
{"id": "SQL20556N", "message": "The operation failed because multiple result values cannot be returned from a scalar function function-name .", "explanation": "A scalar function was invoked with arguments that disallow the return of multiple result values for a single invocation.  The processing of the scalar function determined a result that consisted of multiple values.", "response": "One of the following options can be used to avoid the error: Change the values of the input arguments to the scalar function to return a single value from the multiple value result. If possible, as an alternative to the scalar function invocation, create a user-defined table function to return multi-valued results. sqlcode :  -20556 sqlstate :  22547", "version": "12.1"}
{"id": "SQL20557N", "message": "The statement failed because of an error in the Hive metastore. Log entry identifier: log-entry-identifier . Reason code: reason-code .", "explanation": "In IBM Big SQL, you can use standard DDL and SQL to create and query tables for which data is stored in a Hadoop Distributed File System (HDFS). The DDL and SQL processing is handled  by both a processing engine in Big SQL as well as the Hive metastore. The reason code indicates the type of problem: 1 The Hive metastore encountered an error processing the DDL or SQL. 2 Data in the Hive metastore is missing or incorrect. For example, a table property might be missing or contain an invalid value. The log identifier in the token log-entry-identifier is composed of three parts: A three-letter prefix that indicates which log file includes diagnostic details. A three-digit number that indicates on which database partition the log file resides. An identifier that is printed in the log file near the related diagnostic details.", "response": "Locate the diagnostic details in the appropriate log file by using the information in the log-entry-identifier token. Resolve the cause of the problem. Run the statement again. sqlcode :  -20557 sqlstate :  58039", "version": "12.1"}
{"id": "SQL20558N", "message": "The statement failed because the regular expression string is not valid. Reason code: reason-code .  Function name: function-name . Position in regular expression string: position . Regular expression string: string .", "explanation": "This message is returned when the regular expression string specified as the argument of a regular expression function is not a valid regular expression. The position in the string provides and indication of where the regular expression is not correct. If the position could not be determined, a value of 0 is returned. The reason code provides additional information about the error in the pattern. 1 Syntax error in regular expression pattern. 2 Unrecognized backslash escape sequence in pattern. 3 Incorrect Unicode property name. 4 Use of regular expression feature that is not supported. 5 Incorrectly nested parentheses in regular expresion pattern. 6 Decimal number is too large. 7 Error in {min,max} interval. 8 Maximum is less than minimum in {min,max} interval. 9 Back-reference is made to a non-existent capture group. 10 Look-behind pattern matches must have a bounded maximum length. 11 Regular expressions cannot have UnicodeSets containing strings. 12 Octal character constants must be less than or equal to 0377. 13 Missing a closing bracket on a bracket expression. 14 In a character range [x-y], x is greater than y.", "response": "Determine what is incorrect about the regular expression argument of the regular expression function using the position and the reason code. Invoke the function again with a valid regular expression. sqlcode :  -20558 sqlstate :  2201S", "version": "12.1"}
{"id": "SQL20559W", "message": "The analytics operation succeeded with a warning.  Routine name: routine-name . Analytics message identifier: message-ID .  Diagnostic details: runtime-details .", "explanation": "You can perform analytics on data stored in databases by calling IBM in-database analytics routines: You can build analytics models for input data You can perform classification, clustering, regression, and other analytics operations by applying generated models You can manage analytics meta data This message is returned when an IBM in-database analytics routine has completed successfully, but encountered a minor error or warning at run time. The runtime tokens provide more information about the problem: The runtime token routine-name identifies the routine. The token message-ID provides a unique identifier for an analytics error message that explains the problem in detail. Depending on the nature of the problem, the token runtime-details might be empty, or might contain addition details that clarify the source of the problem.", "response": "Learn the details of the problem by reading the text of the message identified by message-ID . If necessary, take action to address the cause of the underlying error or warning and then call the routine again. sqlcode :  +20559 sqlstate :  01H58", "version": "12.1"}
{"id": "SQL20560N", "message": "The routine did not run because the formatting or content of the specified string argument is invalid.  Routine name: routine-name . Reason code: reason-code .  Sub-string: sub-string .  Analytics message identifier: message-ID .  Diagnostic details: runtime-details .", "explanation": "The IBM in-database analytics routines take one argument: a string containing a list of parameter-value pairs, separated by a comma.  This message is returned when an analytics routine is unable to successfully process a given string argument. The runtime tokens provide more information about the problem: The runtime token routine-name identifies the routine. The source of the problem in the string is in or near to the sub-string shown in the runtime token sub-string . Depending on the nature of the problem, the token message-ID might be empty, or might contain a unique identifier for an analytics error message that explains the problem in detail. Depending on the nature of the problem, the token runtime-details might be empty, or might contain addition details that clarify the source of the problem. The runtime token reason-code indicates more specifically the type of the problem: 1 The string argument is not in the expected format: <parameter>=<value> pairs, separated by a comma. 2 An unsupported parameter was specified. 3 A parameter was specified more than once. 4 Mutually exclusive parameters were specified. 5 Only one parameter was specified of a pair of parameters that must be specified together. 10 The value specified with a parameter is not in the expected format. 11 An unsupported value was specified with a parameter for which only one of a specific list of values may be specified. 12 A value of the wrong data type was specified with a parameter. 13 An out-of-range numeric value was specified with a parameter. 14 A string value was specified that is longer than the maximum-allowed length for that parameter value. 15 A string value was specified that contains an unsupported control character, such as a horizontal tab, line-feed, or carriage-return character. 16 An empty value was specified for a parameter. 20 In the value specified with the incolumn parameter, a column was specified more than once. 21 In the value specified with the incolumn parameter, the properties string that was specified for a column is not in the expected format. 22 In the value specified with the incolumn parameter, an unsupported property was specified for a column. 23 In the value specified with the incolumn parameter, a value of the wrong data type was specified for the weight property.", "response": "Call the routine again, specifying a valid parameter string. sqlcode :  -20560 sqlstate :  22548", "version": "12.1"}
{"id": "SQL20561N", "message": "The analytics operation could not be performed because of a problem with a table.  Routine name: routine-name . Table name: table-name .  Analytics message identifier: message-ID .  Diagnostic details: runtime-details .", "explanation": "When you call IBM in-database analytics routines, you specify input tables such as: The table containing the data upon which the analytics will be performed A column properties table A table indicating weighting that should be applied to instance or class data A table containing sample data with which to validate a generated analytical model A table containing the meta data for an analytical model This message is returned when there is a problem with an input table that has been specified with an analytics routine. The runtime tokens provide more information about the problem: The runtime token routine-name identifies the routine. The token table-name indicates which table has a problem. The token message-ID provides a unique identifier for an analytics error message that explains the problem in detail. Depending on the nature of the problem, the token runtime-details might be empty, or might contain addition details that clarify the source of the problem.", "response": "Learn the details of the problem by reading the text of the message identified by message-ID . Correct the table. Call the routine again. sqlcode :  -20561 sqlstate :  22549", "version": "12.1"}
{"id": "SQL20562N", "message": "The analytics operation could not be performed because the specified options are not valid.  Routine name: routine-name . Analytics message identifier: message-ID .  Diagnostic details: runtime-details .", "explanation": "You can perform analytics on data stored in databases by calling IBM in-database analytics routines.  To perform analytics, you must specify options that control the behavior of the analytics, such as the following examples: The name of an input table containing input data A collection of analytics-related properties that are to be applied to the columns of the input table Information about weighting to be applied to data points Metrics to be used for scoring the quality of the generated analytics model This message is returned when a collection of options that is unsupported, inconsistent, or otherwise invalid has been specified with an IBM in-database analytics routine. The runtime tokens provide more information about the problem: The runtime token routine-name identifies the routine. The token message-ID provides a unique identifier for an analytics error message that explains the problem in detail. Depending on the nature of the problem, the token runtime-details might be empty, or might contain addition details that clarify the source of the problem.", "response": "Learn the details of the problem by reading the text of the message identified by message-ID . Call the routine again, specifying valid options. sqlcode :  -20562 sqlstate :  22550", "version": "12.1"}
{"id": "SQL20563N", "message": "The analytics operation failed.  Routine name: routine-name . Analytics message identifier: message-ID .  Diagnostic details: runtime-details .", "explanation": "You can perform analytics on data stored in databases by calling IBM in-database analytics routines: You can build analytics models for input data You can perform classification, clustering, regression, and other analytics operations by applying generated models You can manage analytics meta data This message is returned when an IBM in-database analytics routine fails because of a runtime error. The runtime tokens provide more information about the problem: The runtime token routine-name identifies the routine. The token message-ID provides a unique identifier for an analytics error message that explains the problem in detail. Depending on the nature of the problem, the token runtime-details might be empty, or might contain addition details that clarify the source of the problem.", "response": "Learn the details of the problem by reading the text of the message identified by message-ID . Resolve the problem. Call the routine again. sqlcode :  -20563 sqlstate :  560DA", "version": "12.1"}
{"id": "SQL20564N", "message": "The analytics operation could not be performed because the authorization ID authorization-ID does not have the required privilege to perform the operation.  Operation: operation .  Analytics message identifier: message-ID .  Diagnostic details: runtime-details .", "explanation": "To call IBM in-database analytics routines requires appropriate privileges. This message is returned when a user attempts to call a routine (such as LIST_PRIVILEGES or DROP_MODEL, for example) and the authorization ID does not have the required privilege to call that routine.", "response": "Call the routine as an authorization ID with the required privilege. sqlcode :  -20564 sqlstate :  42526", "version": "12.1"}
{"id": "SQL20566N", "message": "The CREATE FUNCTION or ALTER MODULE statement used to define routine-name failed because the identified component routine is not valid. Component routine clause: component-routine-clause . Specific name: specific-name . Reason code: reason-code .", "explanation": "The identified component routine for the clause component-routine-clause with specific name specific-name when creating an aggregate interface function is not valid for the reason specified by the reason code as follows: 1 The data types of one or more parameters of the identified component routine are incorrect. 2 The mode of one or more parameters of the identified component routine are incorrect. 3 The data type of the return value of the identified component routine is incorrect. 4 The number of parameters of the identified component routine is incorrect. 5 One or more options of the identified component routine are incorrect.", "response": "Determine what is incorrect about the identified component routine and either correct the definition of that routine or specify a different routine for that component routine that does have the valid characteristics based on the reason by the reason-code as follows. 1 Ensure the data types of all parameters of the identified component routine are correct. 2 Ensure the modes of all parameters of the identified component routine are correct. 3 Ensure the data type of the return value of the identified component routine is correct. 4 Ensure the number of parameters of the identified component routine is correct. 5 Ensure that all options of the identified component routine are correct. sqlcode :  -20566 sqlstate :  428IA", "version": "12.1"}
{"id": "SQL20568W", "message": "The table was successfully created with random distribution.  However, since the distribution key that was chosen by the database manager may not guarantee unique values, the data distribution of this table might be sub-optimal.  Columns in the distribution key: column-name-list .", "explanation": "When a random distribution table is created with multiple unique or primary keys, the database manager uses the set of overlapping columns from all unique and primary keys as the distribution key.  If the distribution key contains duplicate values, this could end up skewing data to a subset of the members.", "response": "The distribution key that was selected by the database manager was column-name-list .  If the values for these columns contain duplicate values you may experience skew with data in the table.  To avoid this, recreate the table and explicitly set a different distribution key. The distribution key can be explicitly set using the DISTRIBUTE BY HASH clause. sqlcode :  +20568 sqlstate :  0169C", "version": "12.1"}
{"id": "SQL20569N", "message": "The external table operation failed due to a problem with the corresponding data file or diagnostic files. File name: file-name . Reason code: reason-code .", "explanation": "The data for an external table is stored in a file that can be located locally or remotely. This message is returned when a statement attempts to create, insert into, or select from an external table, but the corresponding operation failed due to a problem with the corresponding data file or log/bad files. The reason code identifies the specific problem: 1 Either data file could not be reached or log/bad files could not be written. 2 The user ID that issued the statement is not authorized to access the data file. 3 The attempt to process the data file ended unexpectedly. Probably, the contents of the data file are corrupt. For example, data fields may have delimiters or nullvalue as part of data and requires an escape character. 4 The data file met with operating system level size limitations, I/O issues or insufficient memory issues.", "response": "Take action that corresponds to the reason code: 1 Perform the following troubleshooting steps: Verify that the data file was specified correctly. Verify that the data file exists in the specified location. For a remote data file, verify that the network connection is open. For log/bad files, verify if filesystem has enough space. 2 Set the access permissions of the data file so that the user ID that issued the statement can read from and write to the data file. 3 Correct the field data in data file containing delimiters or nullvalue as part of data using proper escape character. 4 Make sure that the external table operation with data file is limited to operating system constraints. sqlcode :  -20569 sqlstate :  428IB", "version": "12.1"}
{"id": "SQL20570N", "message": "The statement failed because the number of rejected rows exceeds the limit set in the MaxErrors option value. Log file name: log-file-name .", "explanation": "The data for an external table is stored in a file that can be located locally or remotely. The data in the file might not perfectly match the column definitions of the external table. When you select data from an external table, the database manager might need to alter or convert the data to enable the SELECT statement to return a result set. However, sometimes the data from a particular row of data cannot be altered or converted successfully. When that happens, the row is rejected and is not included in the result set. You can use the MaxErrors external table option to specify a threshold for the number of rejected rows. When that threshold is exceeded, the attempt to process the SELECT statement is canceled. This message is returned when a SELECT statement is issued for data in an external table and the attempt to process the statement fails because more rows have been rejected than the threshold set by the MaxErrors option.", "response": "Address this error in one or more of the following ways: To reduce the number of rejected rows, alter the data in the file so that it matches the column definitions of the external table. To reduce the number of rejected rows, alter the column definitions of the external table so it better matches the data in the file. To allow the statement to be processed despite the mismatches between the column definitions of the external table and the data in the file, increase the value of the MaxErrors option. sqlcode :  -20570 sqlstate :  22551", "version": "12.1"}
{"id": "SQL20573N", "message": "Operation not allowed on object object-name of type type-name because schema schema-name is not accessible. Reason code = reason-code .", "explanation": "Access to schema <schema-name> is restricted as indicated by the reason code: The specific reason this message was returned is indicated by reason-code : 1 A schema restore operation is in progress.", "response": "Respond to this message according to the reason code: 1 Wait for the restore to complete successfully then retry the command. sqlcode :  -20573 sqlstate :  57007", "version": "12.1"}
{"id": "SQL20574W", "message": "The update completed successfully. The new SORTHEAP value will not be used for query optimization because the value provided by OPT_SORTHEAP overrides it.", "explanation": "OPT_SORTHEAP has a non-zero value, which will be used for query optimization. OPT_SORTHEAP may have been set manually or by AUTOCONFIGURE", "response": "Consider whether OPT_SORTHEAP should be cleared, so that the current SORTHEAP setting is used for query optimization. In a DPF environment, OPT_SORTHEAP is typically to the smallest SORTHEAP setting across all members. sqlcode :  +20574 sqlstate :  0169I", "version": "12.1"}
{"id": "SQL20575N", "message": "The statement conflicts with another statement that has already been issued in the current transaction.  Reason code = reason-code .", "explanation": "The statement cannot be executed because it conflicts with another statement that has already been issued in the current transaction.  The transaction must be committed or rolled back before the statement can be issued. The reason codes are: 1 CREATE TENANT or DROP TENANT statement has already been issued in the transaction.  Only one such statement can be executed within a unit of work.", "response": "COMMIT or ROLLBACK before reissuing the failing statement. sqlcode :  -20575 sqlstate :  560DF", "version": "12.1"}
{"id": "SQL20576N", "message": "The command or operation failed because a TLS connection could not be established with reason reason-code and additional information additional info .", "explanation": "The client in this context is the application or Db2 CLP and the server is the Db2 database server. 1 The connection has been configured to use TLS hostname validation. When connecting to the specified server, hostname validation failed because the server's TLS certificate does not contain a hostname or IP address that matches the value configured by the client. Details about the server's certificate have been logged to the db2diag.log file. In addition, the hostnames or IP addresses that the client used to match against the certificate have also been logged to this file.", "response": "1 In db2diag.log, examine the common name and subject alternate name (SAN) fields of the server's certificate. These fields contain the hostnames or IP addresses that the server's certificate is issued for. Please make sure that the database administrator has setup the correct certificate on this server. Consult the TLS Hostname Validation documentation for information about how to create correct server certificates for the different Db2 server topologies. If the server is using the correct certificate and the client is also configured to connect with the correct hostname, this error would suggest that there is a security risk. The communication might have been intercepted by a malicious host. Note that if the specified hostname does not match the value configured on the client, it means that the client has attempted to route to another host and hostname validation failed for this routed connection. These connections can happen on the client due to Automatic Client Reroute and Workload Balancing. sqlcode :  -20576 sqlstate :  08001", "version": "12.1"}
{"id": "SQL20581N", "message": "Failed to wait for incremental updates. Reason: reason . Library: library-name . Function: function-name .", "explanation": "This message is returned when the database manager is unable to wait for incremental updates from an external replication server.", "response": "Respond to this message according to the reason: 1 The library <library-name> specified by the registry variable DB2_WAITFOR_DATA_LIBNAME could not be loaded. More information has been logged to the db2diag.log file. 2 The library <library-name> specified by the registry variable DB2_WAITFOR_DATA_LIBNAME does not contain function <function-name>. More information has been logged to the db2diag.log file. 3 The library <library-name> specified by the registry variable DB2_WAITFOR_DATA_LIBNAME was loaded successfully, but could not be unloaded. More information has been logged to the db2diag.log file. 4 The replication server did not reply in the time limit given by the CURRENT QUERY WAITFORDATA special register. SUBSCRIPTION_NOT_RUNNING Replication is not enabled for one or more tables used in the query. Enable replication for all tables used in the query. INVALID_TABLE_STATE The state for one or more tables used in the query is invalid. More information is available at the replication server. TIMEOUT The replication server reported that replication for tables used in the query did not finish in the time limit given by the CURRENT QUERY WAITFORDATA special register. Reason not listed here The replication server may provide a reason not listed here. In that case, use the information in \"reason\" along with any documentation available for the replication server that is returning the information to determine how to handle this error situation. sqlcode :  -20581 sqlstate :  57019", "version": "12.1"}
{"id": "SQL20582N", "message": "CREATE/ALTER TRUSTED CONTEXT statement failed because the procedure specified for the TRUST PROCEDURE attribute, procedure-name , is not valid due to reason code reason-code .", "explanation": "The procedure specified for the TRUST PROCEDURE attribute is not valid. The possible reason codes are as follows: 1 The trust procedure must not contain any parameters. 2 An external C procedure must be defined with PARAMETER TYPE SQL or DB2SQL in order to be used as a trust procedure. 3 The trust procedure name is not unique. 4 Only a SYSTEM tenant trust procedure is allowed.", "response": "1-4 Specify a valid trust procedure. sqlcode :  -20582 sqlstate :  42639", "version": "12.1"}
{"id": "SQL20583N", "message": "The audit exception on object name of type type to be created for object name2 of type type2 is identical to an existing audit exception.", "explanation": "The AUDIT ADD EXCEPTION FOR statement tried to add an audit exception on object name of type type when an audit exception for object name2 of type type2 already exists on the application server or in the same statement. If name2 is empty and type2 is GLOBAL, the audit exception applies to all audit associations. The statement cannot be processed. No new audit exception is created, and the existing audit exception is not altered or modified.", "response": "Ensure that the target of the audit exception is correct. If the exception is not correct, correct the statement. sqlcode :  -20583 sqlstate :  428IF", "version": "12.1"}
{"id": "SQL20584N", "message": "The audit exception on object name of type type for object name2 of type type2 does not exist.", "explanation": "The audit exception on object name of type type for object name2 of type type2 is not defined in the database. If name2 is empty and type2 is GLOBAL, the audit exception applies to all audit associations. The statement cannot be processed.", "response": "Ensure that the object names are correctly specified in the SQL statement and that the audit exception exists. sqlcode :  -20584 sqlstate :  428IG", "version": "12.1"}
{"id": "SQL20585N", "message": "The procedure procedure-name is being used by a trusted connection. operation-type operation is not allowed.", "explanation": "Operations are restricted on any procedure with the same name as the trust procedure defined for a trusted context attribute. The trust procedure cannot be altered or dropped, either directly or as a result of the CREATE OR REPLACE operation. A new procedure with the same name cannot be created, even if it has a different procedure signature.", "response": "If you are creating a new procedure, use a different name for the procedure name or a different schema. If the trust procedure that is currently in use needs to be altered or dropped, the trusted context must be dropped or altered to drop the trust procedure. sqlcode :  -20585 sqlstate :  42858", "version": "12.1"}
{"id": "SQL20586N", "message": "A view cannot be defined on a transient external table", "explanation": "The SQL statement attempts to create a view on a transient external table, which is not permitted.", "response": "Ensure that the view is created on a named external table instead of a transient external table. sqlcode :  -20586 sqlstate :  428IE", "version": "12.1"}
{"id": "SQL20587N", "message": "A model operation did not complete on the target object. Object name: object-name . Object type: object-type . Reason code: reason-code .", "explanation": "A model operation did not complete successfully on the target\n\tobject. The reason code indicates the cause of the failure: 19 A table cardinality model is not supported for the target object.", "response": "Respond according to the reason code provided: 19 Verify that a table cardinality model is supported for the target object. sqlcode : -20587 sqlstate : 42809", "version": "12.1"}
{"id": "SQL20589W", "message": "The database is created with the Unicode Collation Algorithm (UCA); If an object of type object-type uses character data, the object might be impacted when Db2 refreshes the ICU level.", "explanation": "This warning is pertinent to Unicode Collation Algorithm (UCA) collated databases. This warning is returned in the following situations: An index is created using at least one text column or a transformed text column. A materialized query table (MQT) is created. A partitioned table is created by using a partition key with at least one text column or a transformed text column.", "response": "Consider recreating the object without using character data that might change after collation, when Db2 refreshes the ICU level. For example, create an index on a numeric column or use a FOR BIT DATA character column. Note: The creation of this object does not prevent the database from moving to a Db2 level with an ICU refresh, but an evaluation of the correctness of this object in an updated collation might be needed. The object might also need to be recreated. sqlcode : +20589 sqlstate : 0169K", "version": "12.1"}
